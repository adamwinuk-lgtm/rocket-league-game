<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Rocket Arena</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { overflow: hidden; background: #000; font-family: 'Segoe UI', system-ui, -apple-system, sans-serif; }
canvas { display: block; }

#hud {
  position: fixed; top: 0; left: 0; right: 0;
  display: flex; justify-content: center; align-items: flex-start;
  pointer-events: none; z-index: 10;
}
#scoreboard {
  background: linear-gradient(180deg, rgba(0,0,0,0.85) 0%, rgba(0,0,0,0.7) 100%);
  border-bottom: 2px solid rgba(255,255,255,0.08);
  padding: 0; display: flex; align-items: stretch; gap: 0;
  border-radius: 0 0 14px 14px; overflow: hidden;
  box-shadow: 0 4px 20px rgba(0,0,0,0.5);
}
.team-score {
  font-size: 52px; font-weight: 900; min-width: 70px; text-align: center;
  padding: 6px 20px;
  text-shadow: 0 0 25px currentColor, 0 0 50px currentColor;
}
.team-orange { color: #ff7b00; background: linear-gradient(180deg, rgba(255,123,0,0.2) 0%, rgba(255,85,0,0.05) 100%); }
.team-blue { color: #00aaff; background: linear-gradient(180deg, rgba(0,170,255,0.2) 0%, rgba(0,100,255,0.05) 100%); }
#timer {
  font-size: 22px; color: #ddd; font-weight: 700;
  font-variant-numeric: tabular-nums; min-width: 70px; text-align: center;
  padding: 10px 16px; background: rgba(0,0,0,0.3);
  border-left: 1px solid rgba(255,255,255,0.06);
  border-right: 1px solid rgba(255,255,255,0.06);
}
#boost-container {
  position: fixed; bottom: 30px; right: 30px;
  width: 80px; height: 80px; z-index: 10; pointer-events: none;
}
#boost-ring {
  width: 80px; height: 80px; border-radius: 50%;
  border: 4px solid rgba(255,255,255,0.15);
  position: relative; display: flex; align-items: center; justify-content: center;
}
#boost-fill {
  width: 64px; height: 64px; border-radius: 50%;
  background: conic-gradient(#ff7b00 0%, #ff7b00 var(--pct, 100%), transparent var(--pct, 100%));
  display: flex; align-items: center; justify-content: center;
  transition: --pct 0.1s;
}
#boost-text {
  font-size: 18px; font-weight: 700; color: #fff;
}
#ballcam-indicator {
  position: fixed; bottom: 30px; left: 30px; z-index: 10;
  color: rgba(255,255,255,0.5); font-size: 13px; pointer-events: none;
}
#ballcam-indicator.active { color: #ff7b00; }

#overlay {
  position: fixed; inset: 0; display: flex; align-items: center; justify-content: center;
  z-index: 20; pointer-events: none;
}
#overlay-text {
  font-size: 72px; font-weight: 900; color: #fff;
  text-shadow: 0 0 40px rgba(255,200,0,0.8), 0 0 80px rgba(255,100,0,0.4);
  opacity: 0; transform: scale(0.5);
  transition: opacity 0.3s, transform 0.3s;
}
#overlay-text.show {
  opacity: 1; transform: scale(1);
}
#overlay-text.goal {
  font-size: 96px;
  animation: goalPulse 0.6s ease-out;
}
@keyframes goalPulse {
  0% { transform: scale(0.3); opacity: 0; }
  50% { transform: scale(1.2); }
  100% { transform: scale(1); opacity: 1; }
}

#menu {
  position: fixed; inset: 0; display: flex; flex-direction: column;
  align-items: center; justify-content: center; z-index: 30;
  background: radial-gradient(ellipse at center, rgba(20,20,40,0.95), rgba(0,0,0,0.98));
}
#menu h1 {
  font-size: 72px; font-weight: 900; margin-bottom: 8px;
  background: linear-gradient(135deg, #ff7b00, #ffaa00, #ff7b00);
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  text-shadow: none; filter: drop-shadow(0 0 30px rgba(255,120,0,0.4));
}
#menu .subtitle {
  color: #888; font-size: 18px; margin-bottom: 40px; letter-spacing: 4px;
}
#menu .start-btn {
  background: linear-gradient(135deg, #ff7b00, #ff5500);
  border: none; color: #fff; font-size: 22px; font-weight: 700;
  padding: 14px 48px; border-radius: 8px; cursor: pointer;
  pointer-events: auto; margin-bottom: 32px;
  transition: transform 0.15s, box-shadow 0.15s;
}
#menu .start-btn:hover {
  transform: scale(1.05); box-shadow: 0 0 30px rgba(255,120,0,0.5);
}
#menu .controls {
  color: #666; font-size: 14px; line-height: 2;
  text-align: center;
}
#menu .controls kbd {
  background: rgba(255,255,255,0.1); padding: 2px 8px;
  border-radius: 4px; border: 1px solid rgba(255,255,255,0.15);
  font-family: inherit; color: #aaa;
}

#game-over {
  position: fixed; inset: 0; display: none; flex-direction: column;
  align-items: center; justify-content: center; z-index: 30;
  background: rgba(0,0,0,0.85);
}
#game-over h2 { font-size: 56px; font-weight: 900; margin-bottom: 16px; }
#game-over .final-score { font-size: 28px; color: #aaa; margin-bottom: 32px; }
#game-over .start-btn {
  background: linear-gradient(135deg, #ff7b00, #ff5500);
  border: none; color: #fff; font-size: 20px; font-weight: 700;
  padding: 12px 40px; border-radius: 8px; cursor: pointer;
}

/* Settings Panel */
#settings {
  position: fixed; inset: 0; display: none; flex-direction: column;
  align-items: center; justify-content: flex-start; z-index: 35;
  background: radial-gradient(ellipse at center, rgba(20,20,40,0.97), rgba(0,0,0,0.99));
  overflow-y: auto; padding: 30px 20px;
}
#settings h2 {
  font-size: 36px; font-weight: 900; margin-bottom: 24px;
  background: linear-gradient(135deg, #ff7b00, #ffaa00);
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
}
.settings-grid {
  display: grid; grid-template-columns: 1fr 1fr;
  gap: 16px 32px; max-width: 680px; width: 100%; margin-bottom: 28px;
}
@media (max-width: 600px) { .settings-grid { grid-template-columns: 1fr; } }
.setting-group {
  background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.08);
  border-radius: 10px; padding: 14px 16px;
}
.setting-group label {
  display: block; font-size: 11px; font-weight: 700; text-transform: uppercase;
  letter-spacing: 1.5px; color: #888; margin-bottom: 8px;
}
.setting-group select, .setting-group input[type="range"] {
  width: 100%; appearance: none; -webkit-appearance: none;
  background: rgba(255,255,255,0.08); color: #eee;
  border: 1px solid rgba(255,255,255,0.12); border-radius: 6px;
  padding: 8px 12px; font-size: 15px; font-family: inherit; cursor: pointer;
}
.setting-group select option { background: #1a1a2e; color: #eee; }
.setting-group input[type="range"] {
  padding: 0; height: 6px; border-radius: 3px; margin-top: 4px;
}
.setting-group input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none; width: 18px; height: 18px;
  background: #ff7b00; border-radius: 50%; cursor: pointer; border: 2px solid #fff;
}
.setting-group input[type="range"]::-moz-range-thumb {
  width: 18px; height: 18px;
  background: #ff7b00; border-radius: 50%; cursor: pointer; border: 2px solid #fff;
}
.range-val {
  display: inline-block; font-size: 14px; color: #ff7b00;
  font-weight: 700; min-width: 40px; text-align: right; float: right;
  margin-top: -2px;
}
.settings-section-title {
  grid-column: 1 / -1; font-size: 13px; font-weight: 700;
  text-transform: uppercase; letter-spacing: 2px; color: #ff7b00;
  border-bottom: 1px solid rgba(255,120,0,0.2); padding-bottom: 6px;
  margin-top: 4px;
}
.settings-btns {
  display: flex; gap: 12px; margin-bottom: 20px;
}
.settings-btns button {
  border: none; font-size: 18px; font-weight: 700;
  padding: 12px 36px; border-radius: 8px; cursor: pointer;
  transition: transform 0.15s;
}
.settings-btns button:hover { transform: scale(1.04); }
.btn-save {
  background: linear-gradient(135deg, #ff7b00, #ff5500); color: #fff;
}
.btn-back {
  background: rgba(255,255,255,0.1); color: #ccc;
}
.btn-reset-settings {
  background: rgba(255,60,60,0.15); color: #ff6666; font-size: 13px !important;
  padding: 8px 20px !important;
}
#menu .settings-btn {
  background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.12);
  color: #aaa; font-size: 16px; font-weight: 600;
  padding: 10px 32px; border-radius: 8px; cursor: pointer;
  pointer-events: auto; margin-bottom: 24px;
  transition: transform 0.15s, background 0.15s;
}
#menu .settings-btn:hover {
  transform: scale(1.04); background: rgba(255,255,255,0.12); color: #fff;
}

/* Control Binding */
.controls-grid {
  display: grid; grid-template-columns: 1fr 1fr;
  gap: 8px 20px; max-width: 680px; width: 100%; margin-bottom: 20px;
}
@media (max-width: 600px) { .controls-grid { grid-template-columns: 1fr; } }
.control-row {
  display: flex; align-items: center; justify-content: space-between;
  padding: 6px 14px; background: rgba(255,255,255,0.03); border-radius: 6px;
}
.control-label { color: #aaa; font-size: 13px; }
.control-key {
  background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.15);
  color: #ff7b00; font-size: 13px; font-weight: 700;
  padding: 4px 14px; border-radius: 4px; cursor: pointer;
  min-width: 52px; text-align: center; font-family: inherit;
  transition: background 0.15s, border-color 0.15s;
}
.control-key:hover { background: rgba(255,120,0,0.15); border-color: rgba(255,120,0,0.4); }
.control-key.listening {
  background: rgba(255,120,0,0.25); border-color: #ff7b00; color: #fff;
  animation: keyPulse 0.8s ease-in-out infinite;
}
@keyframes keyPulse {
  0%, 100% { border-color: #ff7b00; }
  50% { border-color: #ff5500; box-shadow: 0 0 12px rgba(255,120,0,0.4); }
}

/* Sticky settings buttons */
.settings-footer {
  position: sticky; bottom: 0; background: rgba(10,10,26,0.95);
  padding: 16px 0 8px; display: flex; flex-direction: column;
  align-items: center; gap: 12px; width: 100%;
  border-top: 1px solid rgba(255,255,255,0.06);
}

/* Powerslide indicator */
#powerslide-indicator {
  position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
  z-index: 10; color: rgba(255,255,255,0.4); font-size: 13px;
  pointer-events: none; opacity: 0; transition: opacity 0.15s;
}
#powerslide-indicator.active { opacity: 1; color: #ffaa00; }

/* Quick Chat */
#quick-chat-menu {
  position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%);
  z-index: 25; display: none; pointer-events: none;
}
#quick-chat-menu.open { display: flex; flex-direction: column; gap: 4px; align-items: center; }
.qc-row { display: flex; gap: 4px; }
.qc-btn {
  background: rgba(0,0,0,0.8); border: 1px solid rgba(255,255,255,0.2);
  color: #eee; font-size: 12px; font-weight: 600; padding: 6px 14px;
  border-radius: 6px; pointer-events: auto; cursor: pointer;
  transition: background 0.1s, transform 0.1s; white-space: nowrap;
}
.qc-btn:hover { background: rgba(255,120,0,0.4); transform: scale(1.06); border-color: #ff7b00; }
.qc-label { color: #888; font-size: 10px; text-transform: uppercase; letter-spacing: 1px; }
#chat-bubble {
  position: fixed; top: 20%; left: 50%; transform: translateX(-50%);
  z-index: 22; pointer-events: none;
  font-size: 24px; font-weight: 800; color: #fff;
  text-shadow: 0 0 20px rgba(255,200,0,0.6);
  opacity: 0; transition: opacity 0.3s;
}
#chat-bubble.show { opacity: 1; }

/* Ball speed display */
#ball-speed {
  position: fixed; top: 52px; left: 50%; transform: translateX(-50%);
  z-index: 10; pointer-events: none; font-size: 12px; font-weight: 700;
  color: rgba(255,255,255,0.4); font-variant-numeric: tabular-nums;
  text-align: center; letter-spacing: 1px;
}
#ball-speed.fast { color: #ffaa00; }
#ball-speed.super { color: #ff4400; text-shadow: 0 0 10px rgba(255,68,0,0.5); }

/* Supersonic indicator */
#supersonic {
  position: fixed; bottom: 120px; right: 35px; z-index: 10;
  pointer-events: none; font-size: 11px; font-weight: 800;
  letter-spacing: 2px; color: #9b59b6; opacity: 0;
  transition: opacity 0.2s; text-transform: uppercase;
}
#supersonic.active {
  opacity: 1; color: #e74c3c;
  text-shadow: 0 0 15px rgba(231,76,60,0.6);
  animation: supPulse 0.5s ease-in-out infinite alternate;
}
@keyframes supPulse {
  from { opacity: 0.7; } to { opacity: 1; }
}

/* Speed lines overlay */
#speed-lines {
  position: fixed; inset: 0; z-index: 9; pointer-events: none;
  opacity: 0; transition: opacity 0.3s;
  background: radial-gradient(ellipse at center, transparent 40%, rgba(255,255,255,0.03) 100%);
}
#speed-lines.active {
  opacity: 1;
  background: radial-gradient(ellipse at center, transparent 20%, rgba(255,200,100,0.06) 60%, rgba(255,120,0,0.1) 100%);
}

/* Screen shake */
@keyframes screenShake {
  0% { transform: translate(0,0); }
  25% { transform: translate(-3px, 2px); }
  50% { transform: translate(2px, -3px); }
  75% { transform: translate(-1px, 1px); }
  100% { transform: translate(0,0); }
}
body.shake canvas { animation: screenShake 0.15s ease-out; }

/* Goal flash */
#goal-flash {
  position: fixed; inset: 0; z-index: 19; pointer-events: none;
  opacity: 0; transition: opacity 0.1s;
}
#goal-flash.orange { opacity: 1; background: radial-gradient(ellipse, rgba(255,120,0,0.4) 0%, transparent 70%); }
#goal-flash.blue { opacity: 1; background: radial-gradient(ellipse, rgba(0,100,255,0.4) 0%, transparent 70%); }

/* Demo explosion text */
#demo-text {
  position: fixed; top: 35%; left: 50%; transform: translateX(-50%);
  z-index: 21; pointer-events: none;
  font-size: 36px; font-weight: 900; color: #ff4400;
  text-shadow: 0 0 30px rgba(255,68,0,0.8);
  opacity: 0; transition: opacity 0.2s, transform 0.3s;
}
#demo-text.show { opacity: 1; transform: translateX(-50%) scale(1.2); }
</style>
</head>
<body>

<div id="hud" style="display:none;">
  <div id="scoreboard">
    <span class="team-score team-orange" id="scoreOrange">0</span>
    <span id="timer">5:00</span>
    <span class="team-score team-blue" id="scoreBlue">0</span>
  </div>
</div>

<div id="boost-container" style="display:none;">
  <div id="boost-ring">
    <div id="boost-fill" style="--pct:100%">
      <span id="boost-text">100</span>
    </div>
  </div>
</div>

<div id="ball-speed" style="display:none;">0 km/h</div>
<div id="supersonic">SUPERSONIC</div>
<div id="speed-lines"></div>
<div id="goal-flash"></div>
<div id="demo-text"></div>
<div id="ballcam-indicator">BALL CAM [C]</div>
<div id="powerslide-indicator">DRIFT</div>

<div id="overlay"><div id="overlay-text"></div></div>

<div id="quick-chat-menu">
  <div class="qc-label">Quick Chat [T]</div>
  <div class="qc-row">
    <button class="qc-btn" data-msg="Nice shot!">Nice shot!</button>
    <button class="qc-btn" data-msg="Great pass!">Great pass!</button>
    <button class="qc-btn" data-msg="What a save!">What a save!</button>
  </div>
  <div class="qc-row">
    <button class="qc-btn" data-msg="Close one!">Close one!</button>
    <button class="qc-btn" data-msg="OMG!">OMG!</button>
    <button class="qc-btn" data-msg="Wow!">Wow!</button>
  </div>
  <div class="qc-row">
    <button class="qc-btn" data-msg="Thanks!">Thanks!</button>
    <button class="qc-btn" data-msg="No problem.">No problem.</button>
    <button class="qc-btn" data-msg="Sorry!">Sorry!</button>
  </div>
  <div class="qc-row">
    <button class="qc-btn" data-msg="I got it!">I got it!</button>
    <button class="qc-btn" data-msg="Need boost!">Need boost!</button>
    <button class="qc-btn" data-msg="Defending...">Defending...</button>
  </div>
</div>
<div id="chat-bubble"></div>

<div id="menu">
  <h1>ROCKET ARENA</h1>
  <div class="subtitle">CAR SOCCER</div>
  <button class="start-btn" id="startBtn">PLAY</button>
  <button class="settings-btn" id="settingsBtn">SETTINGS</button>
  <div class="controls" id="menu-controls"></div>
</div>

<div id="settings">
  <h2>SETTINGS</h2>
  <div class="settings-grid">

    <div class="settings-section-title">Game</div>

    <div class="setting-group">
      <label>Game Duration</label>
      <select id="s-duration">
        <option value="60">1 Minute</option>
        <option value="180">3 Minutes</option>
        <option value="300" selected>5 Minutes (Default)</option>
        <option value="600">10 Minutes</option>
        <option value="0">Unlimited</option>
      </select>
    </div>

    <div class="setting-group">
      <label>Score to Win</label>
      <select id="s-winscore">
        <option value="3">3 Goals</option>
        <option value="5">5 Goals</option>
        <option value="7" selected>7 Goals (Default)</option>
        <option value="10">10 Goals</option>
        <option value="0">Unlimited</option>
      </select>
    </div>

    <div class="setting-group">
      <label>AI Difficulty</label>
      <select id="s-ai">
        <option value="0">Easy</option>
        <option value="1" selected>Medium (Default)</option>
        <option value="2">Hard</option>
        <option value="3">Unfair</option>
      </select>
    </div>

    <div class="setting-group">
      <label>Teams</label>
      <select id="s-teams">
        <option value="1v1" selected>1v1 (Default)</option>
        <option value="2v2">2v2</option>
      </select>
    </div>

    <div class="setting-group">
      <label>Stadium</label>
      <select id="s-stadium">
        <option value="standard" selected>Standard (Default)</option>
        <option value="small">Small Arena</option>
        <option value="large">Grand Stadium</option>
        <option value="wide">Wide Field</option>
        <option value="neon">Neon Arena</option>
        <option value="night">Night Match</option>
      </select>
    </div>

    <div class="settings-section-title">Physics</div>

    <div class="setting-group">
      <label>Ball Speed</label>
      <select id="s-ballspeed">
        <option value="0.6">Slow</option>
        <option value="1" selected>Normal (Default)</option>
        <option value="1.5">Fast</option>
        <option value="2.5">Insane</option>
      </select>
    </div>

    <div class="setting-group">
      <label>Gravity</label>
      <select id="s-gravity">
        <option value="0.25">Moon</option>
        <option value="0.6">Low</option>
        <option value="1" selected>Normal (Default)</option>
        <option value="1.6">High</option>
      </select>
    </div>

    <div class="setting-group">
      <label>Ball Size</label>
      <select id="s-ballsize">
        <option value="0.6">Small</option>
        <option value="1" selected>Normal (Default)</option>
        <option value="1.6">Large</option>
        <option value="2.5">Giant</option>
      </select>
    </div>

    <div class="setting-group">
      <label>Boost Mode</label>
      <select id="s-boost">
        <option value="0">No Boost</option>
        <option value="1" selected>Normal (Default)</option>
        <option value="2">Unlimited</option>
        <option value="3">Recharging</option>
      </select>
    </div>

    <div class="setting-group">
      <label>Car Speed</label>
      <select id="s-carspeed">
        <option value="0.6">Slow</option>
        <option value="1" selected>Normal (Default)</option>
        <option value="1.4">Fast</option>
        <option value="2">Turbo</option>
      </select>
    </div>

    <div class="setting-group">
      <label>Bounce</label>
      <select id="s-bounce">
        <option value="0.35">Low</option>
        <option value="0.65" selected>Normal (Default)</option>
        <option value="0.9">High</option>
        <option value="1.05">Super</option>
      </select>
    </div>

    <div class="settings-section-title">Audio & Camera</div>

    <div class="setting-group">
      <label>Sound Volume <span class="range-val" id="s-vol-val">80%</span></label>
      <input type="range" id="s-volume" min="0" max="100" value="80">
    </div>

    <div class="setting-group">
      <label>Camera FOV <span class="range-val" id="s-fov-val">65</span></label>
      <input type="range" id="s-fov" min="45" max="110" value="65">
    </div>

    <div class="setting-group">
      <label>Camera Distance <span class="range-val" id="s-camdist-val">14</span></label>
      <input type="range" id="s-camdist" min="8" max="28" value="14">
    </div>

    <div class="setting-group">
      <label>Camera Height <span class="range-val" id="s-camheight-val">7</span></label>
      <input type="range" id="s-camheight" min="2" max="18" value="7">
    </div>

  </div>

  <div class="settings-section-title" style="margin-top: 8px;">Controls <span style="font-weight:400;font-size:11px;color:#888;text-transform:none;letter-spacing:0;">(click a key to rebind)</span></div>
  <div class="controls-grid" id="controls-grid"></div>

  <div class="settings-footer">
    <div class="settings-btns">
      <button class="btn-back" id="settingsBackBtn">BACK</button>
      <button class="btn-save" id="settingsSaveBtn">SAVE & CLOSE</button>
    </div>
    <button class="btn-reset-settings" id="settingsResetBtn">Reset to Defaults</button>
  </div>
</div>

<div id="game-over">
  <h2 id="go-title">GAME OVER</h2>
  <div class="final-score" id="go-score"></div>
  <button class="start-btn" id="restartBtn">PLAY AGAIN</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
(function() {
'use strict';

// ==========================================================================
// CONSTANTS
// ==========================================================================
var FW = 80, FL = 120, WH = 20;       // field width, length, wall height
var GW = 22, GH = 10, GD = 10;        // goal width, height, depth
var BR = 2;                            // ball radius
var CW = 3.6, CH = 1.2, CL = 5.2;    // car width, height, length
var GRAV = -38;
var BALL_BOUNCE = 0.65, BALL_FRIC = 0.984, BALL_DRAG = 0.9992;
var CAR_ACCEL = 32, CAR_BRAKE = 38, CAR_MAX = 38, CAR_BOOST_MAX = 58;
var CAR_TURN = 2.8, CAR_FRIC = 0.975, CAR_AIR_FRIC = 0.998;
var JUMP_V = 16, DODGE_V = 22;
var BOOST_MAX = 100, BOOST_USE = 33;
var GAME_DURATION = 300;
var WIN_SCORE = 7;

// ==========================================================================
// SETTINGS SYSTEM
// ==========================================================================
var settings = {
  duration: 300, winScore: 7, ai: 1, teams: '1v1', stadium: 'standard',
  ballSpeed: 1, gravity: 1, ballSize: 1, boost: 1,
  carSpeed: 1, bounce: 0.65,
  volume: 80, fov: 65, camDist: 14, camHeight: 7,
  controls: {
    forward: 'w', backward: 's', left: 'a', right: 'd',
    jump: ' ', boost: 'shift', ballcam: 'c', reset: 'r',
    powerslide: 'q', quickchat: 't'
  }
};
var DEFAULTS = JSON.parse(JSON.stringify(settings));

// Control action labels for the UI
var CONTROL_LABELS = {
  forward: 'Forward', backward: 'Backward', left: 'Turn Left', right: 'Turn Right',
  jump: 'Jump / Dodge', boost: 'Boost', ballcam: 'Ball Cam', reset: 'Reset Car',
  powerslide: 'Powerslide', quickchat: 'Quick Chat'
};

// Pretty display names for keys
function keyDisplayName(k) {
  if (k === ' ') return 'Space';
  if (k === 'shift') return 'Shift';
  if (k === 'control') return 'Ctrl';
  if (k === 'alt') return 'Alt';
  if (k === 'escape') return 'Esc';
  if (k === 'arrowup') return '\u2191';
  if (k === 'arrowdown') return '\u2193';
  if (k === 'arrowleft') return '\u2190';
  if (k === 'arrowright') return '\u2192';
  if (k === 'tab') return 'Tab';
  if (k === 'enter') return 'Enter';
  if (k === 'backspace') return 'Bksp';
  return k.toUpperCase();
}

// Check if a control action is currently pressed
function isControl(action) {
  var key = settings.controls[action];
  if (keys[key]) return true;
  // Arrow keys always work as secondary movement controls
  if (action === 'forward' && keys['arrowup']) return true;
  if (action === 'backward' && keys['arrowdown']) return true;
  if (action === 'left' && keys['arrowleft']) return true;
  if (action === 'right' && keys['arrowright']) return true;
  // Both shift keys for boost
  if (action === 'boost' && (keys['shiftleft'] || keys['shiftright'])) return true;
  return false;
}

// Key rebinding state
var _rebindingAction = null;
var _rebindingEl = null;

function loadSettings() {
  try {
    var saved = JSON.parse(localStorage.getItem('rocketArenaSettings'));
    if (saved) {
      for (var k in saved) {
        if (!settings.hasOwnProperty(k)) continue;
        if (k === 'controls' && typeof saved[k] === 'object') {
          for (var c in saved[k]) {
            if (settings.controls.hasOwnProperty(c)) settings.controls[c] = saved[k][c];
          }
        } else {
          settings[k] = saved[k];
        }
      }
    }
  } catch(e) {}
}

function saveSettings() {
  try { localStorage.setItem('rocketArenaSettings', JSON.stringify(settings)); } catch(e) {}
}

function settingsToUI() {
  document.getElementById('s-duration').value = settings.duration;
  document.getElementById('s-winscore').value = settings.winScore;
  document.getElementById('s-ai').value = settings.ai;
  document.getElementById('s-teams').value = settings.teams;
  document.getElementById('s-stadium').value = settings.stadium;
  document.getElementById('s-ballspeed').value = settings.ballSpeed;
  document.getElementById('s-gravity').value = settings.gravity;
  document.getElementById('s-ballsize').value = settings.ballSize;
  document.getElementById('s-boost').value = settings.boost;
  document.getElementById('s-carspeed').value = settings.carSpeed;
  document.getElementById('s-bounce').value = settings.bounce;
  document.getElementById('s-volume').value = settings.volume;
  document.getElementById('s-fov').value = settings.fov;
  document.getElementById('s-camdist').value = settings.camDist;
  document.getElementById('s-camheight').value = settings.camHeight;
  updateRangeDisplays();
  buildControlsUI();
}

function uiToSettings() {
  settings.duration = parseInt(document.getElementById('s-duration').value);
  settings.winScore = parseInt(document.getElementById('s-winscore').value);
  settings.ai = parseInt(document.getElementById('s-ai').value);
  settings.teams = document.getElementById('s-teams').value;
  settings.stadium = document.getElementById('s-stadium').value;
  settings.ballSpeed = parseFloat(document.getElementById('s-ballspeed').value);
  settings.gravity = parseFloat(document.getElementById('s-gravity').value);
  settings.ballSize = parseFloat(document.getElementById('s-ballsize').value);
  settings.boost = parseInt(document.getElementById('s-boost').value);
  settings.carSpeed = parseFloat(document.getElementById('s-carspeed').value);
  settings.bounce = parseFloat(document.getElementById('s-bounce').value);
  settings.volume = parseInt(document.getElementById('s-volume').value);
  settings.fov = parseInt(document.getElementById('s-fov').value);
  settings.camDist = parseInt(document.getElementById('s-camdist').value);
  settings.camHeight = parseInt(document.getElementById('s-camheight').value);
  // Controls are updated live via rebinding UI, no need to read from DOM
}

function buildControlsUI() {
  var grid = document.getElementById('controls-grid');
  grid.innerHTML = '';
  var actions = ['forward', 'backward', 'left', 'right', 'jump', 'boost', 'powerslide', 'ballcam', 'quickchat', 'reset'];
  actions.forEach(function(action) {
    var row = document.createElement('div');
    row.className = 'control-row';
    var label = document.createElement('span');
    label.className = 'control-label';
    label.textContent = CONTROL_LABELS[action];
    var keyBtn = document.createElement('button');
    keyBtn.className = 'control-key';
    keyBtn.textContent = keyDisplayName(settings.controls[action]);
    keyBtn.setAttribute('data-action', action);
    keyBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      startRebind(action, keyBtn);
    });
    row.appendChild(label);
    row.appendChild(keyBtn);
    grid.appendChild(row);
  });
}

function startRebind(action, el) {
  // Cancel any previous rebind
  cancelRebind();
  _rebindingAction = action;
  _rebindingEl = el;
  el.classList.add('listening');
  el.textContent = '...';
}

function cancelRebind() {
  if (_rebindingAction && _rebindingEl) {
    _rebindingEl.classList.remove('listening');
    _rebindingEl.textContent = keyDisplayName(settings.controls[_rebindingAction]);
  }
  _rebindingAction = null;
  _rebindingEl = null;
}

function handleRebindKey(e) {
  if (!_rebindingAction) return false;
  var key = e.key.toLowerCase();
  // Escape cancels rebinding
  if (key === 'escape') {
    cancelRebind();
    e.preventDefault();
    e.stopPropagation();
    return true;
  }
  // Don't allow binding certain keys
  if (key === 'f5' || key === 'f11' || key === 'f12') return true;
  settings.controls[_rebindingAction] = key;
  _rebindingEl.classList.remove('listening');
  _rebindingEl.textContent = keyDisplayName(key);
  _rebindingAction = null;
  _rebindingEl = null;
  updateMenuControls();
  e.preventDefault();
  e.stopPropagation();
  return true;
}

function updateMenuControls() {
  var c = settings.controls;
  var mc = document.getElementById('menu-controls');
  if (!mc) return;
  mc.innerHTML =
    '<kbd>' + keyDisplayName(c.forward) + '</kbd>' +
    '<kbd>' + keyDisplayName(c.left) + '</kbd>' +
    '<kbd>' + keyDisplayName(c.backward) + '</kbd>' +
    '<kbd>' + keyDisplayName(c.right) + '</kbd> Drive &nbsp;&nbsp;' +
    '<kbd>' + keyDisplayName(c.jump) + '</kbd> Jump/Dodge &nbsp;&nbsp;' +
    '<kbd>' + keyDisplayName(c.boost) + '</kbd> Boost<br>' +
    '<kbd>' + keyDisplayName(c.powerslide) + '</kbd> Powerslide &nbsp;&nbsp;' +
    '<kbd>' + keyDisplayName(c.ballcam) + '</kbd> Ball Cam &nbsp;&nbsp;' +
    '<kbd>' + keyDisplayName(c.quickchat) + '</kbd> Quick Chat<br>' +
    '<kbd>' + keyDisplayName(c.reset) + '</kbd> Reset &nbsp;&nbsp;' +
    '<kbd>Esc</kbd> Menu';
}

function updateRangeDisplays() {
  document.getElementById('s-vol-val').textContent = document.getElementById('s-volume').value + '%';
  document.getElementById('s-fov-val').textContent = document.getElementById('s-fov').value;
  document.getElementById('s-camdist-val').textContent = document.getElementById('s-camdist').value;
  document.getElementById('s-camheight-val').textContent = document.getElementById('s-camheight').value;
}

function applySettings() {
  // Apply settings that take effect immediately
  if (camera) {
    camera.fov = settings.fov;
    camera.updateProjectionMatrix();
  }
  // Ball size
  if (ball) {
    var s = settings.ballSize;
    ball.scale.setScalar(s);
    BR_ACTIVE = BR * s;
  }
}

// Active runtime values (modified by settings)
var BR_ACTIVE = BR;
var GRAV_ACTIVE = GRAV;
var BOUNCE_ACTIVE = BALL_BOUNCE;
var VOLUME_SCALE = 0.8;
var CAR_SPEED_MULT = 1;
var BALL_SPEED_MULT = 1;
var AI_MULT = 0.88;  // AI speed multiplier
var AI_REACT = 1;     // AI reaction quality
var CAM_DIST = 14;
var CAM_HEIGHT = 7;

function recalcActiveValues() {
  BR_ACTIVE = BR * settings.ballSize;
  GRAV_ACTIVE = GRAV * settings.gravity;
  BOUNCE_ACTIVE = settings.bounce;
  VOLUME_SCALE = settings.volume / 100;
  CAR_SPEED_MULT = settings.carSpeed;
  BALL_SPEED_MULT = settings.ballSpeed;
  CAM_DIST = settings.camDist;
  CAM_HEIGHT = settings.camHeight;

  // AI difficulty presets
  switch (settings.ai) {
    case 0: AI_MULT = 0.62; AI_REACT = 0.5; break;  // Easy
    case 1: AI_MULT = 0.85; AI_REACT = 1.0; break;   // Medium
    case 2: AI_MULT = 0.96; AI_REACT = 1.4; break;   // Hard
    case 3: AI_MULT = 1.05; AI_REACT = 1.8; break;   // Unfair
    default: AI_MULT = 0.85; AI_REACT = 1.0;
  }
}

// ==========================================================================
// STADIUM SYSTEM
// ==========================================================================
var STADIUMS = {
  standard: { fw: 80, fl: 120, wh: 20, gw: 22, gh: 10, gd: 10, floorColor: '#1f5c1f', stripe1: '#226322', stripe2: '#1c541c', fogColor: 0x0c0c20, ambientColor: 0x607090, wallColor: 0x3366cc, wallOpacity: 0.22, standColor: 0x1a1a2e, crowdColor1: 0xff6600, crowdColor2: 0x0066ff },
  small:    { fw: 56, fl: 84,  wh: 16, gw: 18, gh: 8,  gd: 8,  floorColor: '#1f5c1f', stripe1: '#226322', stripe2: '#1c541c', fogColor: 0x0c0c20, ambientColor: 0x607090, wallColor: 0x3366cc, wallOpacity: 0.22, standColor: 0x1a1a2e, crowdColor1: 0xff6600, crowdColor2: 0x0066ff },
  large:    { fw: 100, fl: 150, wh: 24, gw: 26, gh: 12, gd: 12, floorColor: '#1f5c1f', stripe1: '#226322', stripe2: '#1c541c', fogColor: 0x0c0c20, ambientColor: 0x607090, wallColor: 0x3366cc, wallOpacity: 0.22, standColor: 0x1a1a2e, crowdColor1: 0xff6600, crowdColor2: 0x0066ff },
  wide:     { fw: 110, fl: 100, wh: 18, gw: 24, gh: 10, gd: 10, floorColor: '#1f5c1f', stripe1: '#226322', stripe2: '#1c541c', fogColor: 0x0c0c20, ambientColor: 0x607090, wallColor: 0x3366cc, wallOpacity: 0.22, standColor: 0x1a1a2e, crowdColor1: 0xff6600, crowdColor2: 0x0066ff },
  neon:     { fw: 80, fl: 120, wh: 20, gw: 22, gh: 10, gd: 10, floorColor: '#0a0a2e', stripe1: '#0e0e38', stripe2: '#08082a', fogColor: 0x050520, ambientColor: 0x3030cc, wallColor: 0x4455ff, wallOpacity: 0.35, standColor: 0x0a0a20, crowdColor1: 0xff00ff, crowdColor2: 0x00ffff },
  night:    { fw: 80, fl: 120, wh: 20, gw: 22, gh: 10, gd: 10, floorColor: '#0f2f0f', stripe1: '#123512', stripe2: '#0c280c', fogColor: 0x020208, ambientColor: 0x203040, wallColor: 0x223388, wallOpacity: 0.18, standColor: 0x0f0f1e, crowdColor1: 0xff6600, crowdColor2: 0x0066ff }
};

function applyStadium() {
  var s = STADIUMS[settings.stadium] || STADIUMS.standard;
  FW = s.fw; FL = s.fl; WH = s.wh;
  GW = s.gw; GH = s.gh; GD = s.gd;
}

// ==========================================================================
// QUICK CHAT SYSTEM
// ==========================================================================
var _quickChatOpen = false;
var _chatBubbleTimer = 0;

function toggleQuickChat() {
  _quickChatOpen = !_quickChatOpen;
  document.getElementById('quick-chat-menu').className = _quickChatOpen ? 'open' : '';
}

function closeQuickChat() {
  _quickChatOpen = false;
  document.getElementById('quick-chat-menu').className = '';
}

function showChatBubble(msg) {
  var el = document.getElementById('chat-bubble');
  el.textContent = msg;
  el.className = 'show';
  _chatBubbleTimer = 2.5;
  closeQuickChat();
  // Play a small chirp
  var ctx = getAudio(); if (!ctx) return;
  var osc = ctx.createOscillator();
  var gain = ctx.createGain();
  osc.connect(gain); gain.connect(ctx.destination);
  osc.type = 'sine';
  osc.frequency.setValueAtTime(800, ctx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(1200, ctx.currentTime + 0.05);
  gain.gain.setValueAtTime(0.1 * VOLUME_SCALE, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.1);
  osc.start(); osc.stop(ctx.currentTime + 0.1);
}

function updateChatBubble(dt) {
  if (_chatBubbleTimer > 0) {
    _chatBubbleTimer -= dt;
    if (_chatBubbleTimer <= 0) {
      document.getElementById('chat-bubble').className = '';
    }
  }
}

// Extra AI cars for 2v2
var aiCar2 = null, aiCar3 = null;
var a2P = new THREE.Vector3(), a2V = new THREE.Vector3(), a2Rot = 0, a2Speed = 0, a2Ground = true, a2Boost = BOOST_MAX;
var a3P = new THREE.Vector3(), a3V = new THREE.Vector3(), a3Rot = Math.PI, a3Speed = 0, a3Ground = true, a3Boost = BOOST_MAX;

// Reusable temp vectors
var _v1 = new THREE.Vector3(), _v2 = new THREE.Vector3(), _v3 = new THREE.Vector3();

// ==========================================================================
// STATE
// ==========================================================================
var scene, camera, renderer, clock;
var ball, ballGlow;
var playerCar, aiCar;
var arenaGroup;
var particles = [];
var boostPads = [];
var audioCtx = null;

// Physics state
var bP = new THREE.Vector3();        // ball position
var bV = new THREE.Vector3();        // ball velocity
var pP = new THREE.Vector3();        // player position
var pV = new THREE.Vector3();        // player velocity
var pRot = 0, pSpeed = 0;           // player rotation Y, speed scalar
var pGround = true, pBoost = BOOST_MAX;
var pCanDodge = false, pDodgeTimer = 0;
var pSpin = 0;                       // spin animation timer
var pPowerslide = false;             // powerslide active
var pSupersonic = false;             // at supersonic speed
var pDemoed = false, pDemoTimer = 0; // demolished state
var aP = new THREE.Vector3();        // AI position
var aV = new THREE.Vector3();        // AI velocity
var aRot = Math.PI, aSpeed = 0;
var aGround = true, aBoost = BOOST_MAX;
var aDemoed = false, aDemoTimer = 0;

var score = [0, 0];                  // orange (player), blue (AI)
var gameTime = GAME_DURATION;
var gameState = 'menu';              // menu, countdown, playing, goal, gameover, overtime
var countdownVal = 3;
var countdownT = 0;
var goalT = 0;
var goalScorer = '';
var keys = {};
var ballCam = false;
var cameraTarget = new THREE.Vector3();
var cameraPos = new THREE.Vector3();

// Ball trail system
var ballTrail = [];
var BALL_TRAIL_MAX = 24;

// Screen shake
var _shakeIntensity = 0;
var _shakeTimer = 0;

// Goal flash
var _goalFlashTimer = 0;

// Demo text
var _demoTextTimer = 0;

// Supersonic threshold (% of max boost speed)
var SUPERSONIC_THRESH = 0.88;

// ==========================================================================
// INITIALIZATION
// ==========================================================================
function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0c0c20);
  scene.fog = new THREE.Fog(0x0c0c20, 100, 250);

  camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.5, 500);
  camera.position.set(0, 30, 60);

  renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.3;
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  document.body.appendChild(renderer.domElement);

  clock = new THREE.Clock();

  // Skybox — procedural starfield
  createSkybox();

  // Lights — realistic stadium floodlight system
  scene.add(new THREE.AmbientLight(0x607090, 0.7));

  var hemi = new THREE.HemisphereLight(0xaabbdd, 0x443322, 0.8);
  scene.add(hemi);

  // Main sun/overhead light with shadows
  var sun = new THREE.DirectionalLight(0xfff5e0, 1.6);
  sun.position.set(15, 70, 10);
  sun.castShadow = true;
  sun.shadow.mapSize.set(2048, 2048);
  sun.shadow.camera.left = -90; sun.shadow.camera.right = 90;
  sun.shadow.camera.top = 90; sun.shadow.camera.bottom = -90;
  sun.shadow.camera.far = 200;
  sun.shadow.bias = -0.0005;
  sun.shadow.normalBias = 0.02;
  scene.add(sun);

  // Second fill light from opposite side
  var fill = new THREE.DirectionalLight(0xdde8ff, 0.5);
  fill.position.set(-30, 50, -20);
  scene.add(fill);

  // Stadium floodlight towers (8 lights — 4 corners + 4 midfield)
  var floodPositions = [
    [-FW * 0.6, WH + 20, -FL * 0.45],
    [FW * 0.6, WH + 20, -FL * 0.45],
    [-FW * 0.6, WH + 20, FL * 0.45],
    [FW * 0.6, WH + 20, FL * 0.45],
    [-FW * 0.55, WH + 18, 0],
    [FW * 0.55, WH + 18, 0],
    [0, WH + 22, -FL * 0.45],
    [0, WH + 22, FL * 0.45]
  ];
  floodPositions.forEach(function(fp) {
    var spot = new THREE.SpotLight(0xfff8e8, 2.0, 250, Math.PI * 0.4, 0.6, 1.2);
    spot.position.set(fp[0], fp[1], fp[2]);
    spot.target.position.set(0, 0, fp[2] * 0.3);
    scene.add(spot);
    scene.add(spot.target);

    // Floodlight tower structure
    var poleMat = new THREE.MeshStandardMaterial({ color: 0x888899, metalness: 0.8, roughness: 0.3 });
    var pole = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.4, WH + 18, 6), poleMat);
    pole.position.set(fp[0], (WH + 18) / 2, fp[2]);
    scene.add(pole);

    // Light housing
    var housing = new THREE.Mesh(new THREE.BoxGeometry(2.5, 1.2, 2.5), poleMat);
    housing.position.set(fp[0], fp[1], fp[2]);
    scene.add(housing);

    // Visible light glow on housing
    var glowMat = new THREE.MeshBasicMaterial({ color: 0xffffdd, transparent: true, opacity: 0.9 });
    var glow = new THREE.Mesh(new THREE.PlaneGeometry(2, 1), glowMat);
    glow.position.set(fp[0], fp[1] - 0.6, fp[2]);
    glow.rotation.x = -Math.PI / 2;
    scene.add(glow);

    // Volumetric light cone (subtle)
    var coneGeo = new THREE.CylinderGeometry(0.5, 12, fp[1], 16, 1, true);
    var coneMat = new THREE.MeshBasicMaterial({
      color: 0xfff8e0, transparent: true, opacity: 0.015,
      side: THREE.DoubleSide, depthWrite: false
    });
    var cone = new THREE.Mesh(coneGeo, coneMat);
    cone.position.set(fp[0], fp[1] / 2, fp[2]);
    scene.add(cone);
  });

  // Goal area lights — warm orange and cool blue
  var orangeLight = new THREE.PointLight(0xff6600, 4, 60);
  orangeLight.position.set(0, 10, FL / 2 + 5);
  scene.add(orangeLight);
  var orangeLight2 = new THREE.PointLight(0xff8833, 2, 40);
  orangeLight2.position.set(0, 3, FL / 2 + 3);
  scene.add(orangeLight2);

  var blueLight = new THREE.PointLight(0x0088ff, 4, 60);
  blueLight.position.set(0, 10, -FL / 2 - 5);
  scene.add(blueLight);
  var blueLight2 = new THREE.PointLight(0x3388ff, 2, 40);
  blueLight2.position.set(0, 3, -FL / 2 - 3);
  scene.add(blueLight2);

  createArena();
  createBall();
  playerCar = createCar(0xff6600, 0xff8800);
  scene.add(playerCar);
  aiCar = createCar(0x0066ff, 0x0088ff);
  scene.add(aiCar);
  createBoostPads();

  resetPositions();
  setupInput();

  // Load and apply settings
  loadSettings();
  settingsToUI();
  recalcActiveValues();
  applySettings();
  updateMenuControls();

  window.addEventListener('resize', onResize);
}

function onResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

// ==========================================================================
// SKYBOX — Procedural starfield with nebula
// ==========================================================================
function createSkybox() {
  var c = document.createElement('canvas');
  c.width = 2048; c.height = 2048;
  var ctx = c.getContext('2d');

  // Stadium arena atmosphere — warm enclosed feel
  var grad = ctx.createRadialGradient(1024, 600, 100, 1024, 1024, 1400);
  grad.addColorStop(0, '#2a2a4a');
  grad.addColorStop(0.3, '#181830');
  grad.addColorStop(0.6, '#0e0e22');
  grad.addColorStop(1, '#060614');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, 2048, 2048);

  // Stadium floodlight glows (bright spots in the sky)
  var lightPositions = [
    [400, 300], [1648, 300], [400, 1748], [1648, 1748],
    [1024, 200], [1024, 1848], [200, 1024], [1848, 1024]
  ];
  lightPositions.forEach(function(lp) {
    var lg = ctx.createRadialGradient(lp[0], lp[1], 0, lp[0], lp[1], 180);
    lg.addColorStop(0, 'rgba(255,245,220,0.25)');
    lg.addColorStop(0.3, 'rgba(255,230,180,0.12)');
    lg.addColorStop(0.6, 'rgba(255,220,160,0.04)');
    lg.addColorStop(1, 'rgba(255,220,160,0)');
    ctx.fillStyle = lg;
    ctx.fillRect(0, 0, 2048, 2048);
  });

  // Subtle warm ambient glow from arena
  var arenaGlow = ctx.createRadialGradient(1024, 1024, 0, 1024, 1024, 900);
  arenaGlow.addColorStop(0, 'rgba(60,50,30,0.08)');
  arenaGlow.addColorStop(1, 'rgba(30,20,10,0)');
  ctx.fillStyle = arenaGlow;
  ctx.fillRect(0, 0, 2048, 2048);

  // Steel/rafters structure lines (faint)
  ctx.strokeStyle = 'rgba(100,110,130,0.06)';
  ctx.lineWidth = 2;
  for (var i = 0; i < 12; i++) {
    ctx.beginPath();
    ctx.moveTo(0, i * 170);
    ctx.lineTo(2048, i * 170);
    ctx.stroke();
  }
  for (var j = 0; j < 12; j++) {
    ctx.beginPath();
    ctx.moveTo(j * 170, 0);
    ctx.lineTo(j * 170, 2048);
    ctx.stroke();
  }

  var tex = new THREE.CanvasTexture(c);
  tex.mapping = THREE.EquirectangularReflectionMapping;
  scene.background = tex;
  scene.environment = tex;
}

// ==========================================================================
// ARENA
// ==========================================================================
function createArena() {
  arenaGroup = new THREE.Group();
  scene.add(arenaGroup);

  var st = STADIUMS[settings.stadium] || STADIUMS.standard;

  // Field floor with canvas texture
  var fieldTex = createFieldTexture();
  var floorMat = new THREE.MeshStandardMaterial({ map: fieldTex, roughness: 0.75, metalness: 0.05 });
  var floor = new THREE.Mesh(new THREE.PlaneGeometry(FW, FL), floorMat);
  floor.rotation.x = -Math.PI / 2;
  floor.receiveShadow = true;
  arenaGroup.add(floor);

  // Walls — RL-style transparent glass panels
  var wallMat = new THREE.MeshPhysicalMaterial({
    color: st.wallColor, transparent: true, opacity: st.wallOpacity,
    roughness: 0.05, metalness: 0.3, side: THREE.DoubleSide,
    transmission: 0.6, thickness: 0.5, clearcoat: 1.0, clearcoatRoughness: 0.1
  });

  // Wall frame material (dark metal border)
  var frameMat = new THREE.MeshStandardMaterial({ color: 0x333344, metalness: 0.9, roughness: 0.2 });

  // Side walls
  addWall(-FW / 2, WH / 2, 0, 0.5, WH, FL, wallMat);
  addWall(FW / 2, WH / 2, 0, 0.5, WH, FL, wallMat);

  // Side wall top rails
  var railGeo = new THREE.BoxGeometry(0.6, 0.6, FL);
  var railL = new THREE.Mesh(railGeo, frameMat); railL.position.set(-FW/2, WH, 0); arenaGroup.add(railL);
  var railR = new THREE.Mesh(railGeo, frameMat); railR.position.set(FW/2, WH, 0); arenaGroup.add(railR);

  // End walls with goal cutouts
  addWall(-FW / 2 + (FW / 2 - GW / 2) / 2, WH / 2, FL / 2, FW / 2 - GW / 2, WH, 0.5, wallMat);
  addWall(FW / 2 - (FW / 2 - GW / 2) / 2, WH / 2, FL / 2, FW / 2 - GW / 2, WH, 0.5, wallMat);
  addWall(0, GH + (WH - GH) / 2, FL / 2, GW, WH - GH, 0.5, wallMat);
  addWall(-FW / 2 + (FW / 2 - GW / 2) / 2, WH / 2, -FL / 2, FW / 2 - GW / 2, WH, 0.5, wallMat);
  addWall(FW / 2 - (FW / 2 - GW / 2) / 2, WH / 2, -FL / 2, FW / 2 - GW / 2, WH, 0.5, wallMat);
  addWall(0, GH + (WH - GH) / 2, -FL / 2, GW, WH - GH, 0.5, wallMat);

  // Curved corners (quarter-cylinders where walls meet — like RL)
  var cornerR = 8;
  var cornerSegs = 12;
  var cornerPositions = [
    { x: -FW/2 + cornerR, z: -FL/2 + cornerR, rotY: 0 },
    { x: FW/2 - cornerR, z: -FL/2 + cornerR, rotY: Math.PI / 2 },
    { x: FW/2 - cornerR, z: FL/2 - cornerR, rotY: Math.PI },
    { x: -FW/2 + cornerR, z: FL/2 - cornerR, rotY: -Math.PI / 2 }
  ];
  cornerPositions.forEach(function(cp) {
    var cornerShape = new THREE.Shape();
    cornerShape.moveTo(0, 0);
    cornerShape.absarc(0, 0, cornerR, Math.PI, Math.PI * 1.5, false);
    cornerShape.lineTo(0, 0);
    var extrudeSettings = { steps: 1, depth: WH, bevelEnabled: false };
    var cornerGeo = new THREE.ExtrudeGeometry(cornerShape, extrudeSettings);
    var corner = new THREE.Mesh(cornerGeo, wallMat);
    corner.position.set(cp.x, 0, cp.z);
    corner.rotation.set(-Math.PI / 2, 0, cp.rotY);
    arenaGroup.add(corner);
  });

  // Ceiling — subtle dark panel
  var ceilMat = new THREE.MeshStandardMaterial({
    color: 0x181830, transparent: true, opacity: 0.3, side: THREE.DoubleSide
  });
  var ceil = new THREE.Mesh(new THREE.PlaneGeometry(FW + 40, FL + 40), ceilMat);
  ceil.rotation.x = Math.PI / 2;
  ceil.position.y = WH + 25;
  arenaGroup.add(ceil);

  // Goal structures
  createGoal(FL / 2, 0xff6600);
  createGoal(-FL / 2, 0x0066ff);

  // Stadium stands (raised seating area around the arena)
  createStands(st);

  // Wall edge glow lines (RL-style illuminated floor borders)
  addEdgeLine(-FW/2, 0.05, -FL/2 + cornerR, -FW/2, 0.05, FL/2 - cornerR, 0x4488ff);
  addEdgeLine(FW/2, 0.05, -FL/2 + cornerR, FW/2, 0.05, FL/2 - cornerR, 0x4488ff);
  addEdgeLine(-FW/2 + cornerR, 0.05, FL/2, FW/2 - cornerR, 0.05, FL/2, 0xff7700);
  addEdgeLine(-FW/2 + cornerR, 0.05, -FL/2, FW/2 - cornerR, 0.05, -FL/2, 0x2266ff);

  // Floor border strip (glowing edge around entire field)
  var borderMat = new THREE.MeshBasicMaterial({ color: 0x4466aa, transparent: true, opacity: 0.25 });
  var borderW = new THREE.Mesh(new THREE.PlaneGeometry(FW + 2, 1), borderMat);
  borderW.rotation.x = -Math.PI / 2; borderW.position.set(0, 0.02, FL/2 + 0.5); arenaGroup.add(borderW);
  var borderE = new THREE.Mesh(new THREE.PlaneGeometry(FW + 2, 1), borderMat);
  borderE.rotation.x = -Math.PI / 2; borderE.position.set(0, 0.02, -FL/2 - 0.5); arenaGroup.add(borderE);
  var borderS = new THREE.Mesh(new THREE.PlaneGeometry(1, FL + 2), borderMat);
  borderS.rotation.x = -Math.PI / 2; borderS.position.set(-FW/2 - 0.5, 0.02, 0); arenaGroup.add(borderS);
  var borderN = new THREE.Mesh(new THREE.PlaneGeometry(1, FL + 2), borderMat);
  borderN.rotation.x = -Math.PI / 2; borderN.position.set(FW/2 + 0.5, 0.02, 0); arenaGroup.add(borderN);
}

function createStands(st) {
  var standMat = new THREE.MeshStandardMaterial({ color: st.standColor || 0x1a1a2e, roughness: 0.8, metalness: 0.2 });
  var standH = 15, standD = 20, standY = WH / 2;

  // Side stands (left and right)
  [-1, 1].forEach(function(side) {
    var standGeo = new THREE.BoxGeometry(standD, standH, FL + 20);
    var stand = new THREE.Mesh(standGeo, standMat);
    stand.position.set(side * (FW / 2 + standD / 2 + 1), standY + standH / 2 - 5, 0);
    arenaGroup.add(stand);

    // Tiered seating rows
    for (var row = 0; row < 4; row++) {
      var rowGeo = new THREE.BoxGeometry(standD * 0.85, 0.4, FL - 10);
      var rowMat = new THREE.MeshStandardMaterial({ color: 0x222238, roughness: 0.9 });
      var rowMesh = new THREE.Mesh(rowGeo, rowMat);
      rowMesh.position.set(
        side * (FW / 2 + 4 + row * 4.5),
        standY - 2 + row * 3.2,
        0
      );
      arenaGroup.add(rowMesh);
    }

    // Crowd dots (colored points simulating spectators)
    for (var ci = 0; ci < 200; ci++) {
      var crowdColor = Math.random() > 0.5 ? (st.crowdColor1 || 0xff6600) : (st.crowdColor2 || 0x0066ff);
      if (Math.random() > 0.6) crowdColor = [0xffaaaa, 0xaaffaa, 0xaaaaff, 0xffffaa, 0xffaaff, 0xffffff][Math.floor(Math.random() * 6)];
      var dotMat = new THREE.MeshBasicMaterial({ color: crowdColor });
      var dot = new THREE.Mesh(new THREE.SphereGeometry(0.35, 4, 4), dotMat);
      var row2 = Math.floor(Math.random() * 4);
      dot.position.set(
        side * (FW / 2 + 3 + row2 * 4.5 + (Math.random() - 0.5) * 3),
        standY - 0.5 + row2 * 3.2 + Math.random() * 1.5,
        (Math.random() - 0.5) * (FL - 12)
      );
      arenaGroup.add(dot);
    }
  });

  // End stands (behind each goal)
  [-1, 1].forEach(function(endDir) {
    var endGeo = new THREE.BoxGeometry(FW - 10, standH * 0.8, standD * 0.7);
    var endStand = new THREE.Mesh(endGeo, standMat);
    endStand.position.set(0, standY + standH / 2 - 8, endDir * (FL / 2 + GD + standD * 0.35 + 2));
    arenaGroup.add(endStand);

    // End crowd
    for (var ei = 0; ei < 100; ei++) {
      var eCrowdColor = endDir > 0 ? (st.crowdColor1 || 0xff6600) : (st.crowdColor2 || 0x0066ff);
      if (Math.random() > 0.7) eCrowdColor = 0xffffff;
      var eDot = new THREE.Mesh(new THREE.SphereGeometry(0.35, 4, 4), new THREE.MeshBasicMaterial({ color: eCrowdColor }));
      eDot.position.set(
        (Math.random() - 0.5) * (FW - 16),
        standY - 3 + Math.random() * 8,
        endDir * (FL / 2 + GD + 4 + Math.random() * 8)
      );
      arenaGroup.add(eDot);
    }
  });
}

function addWall(x, y, z, w, h, d, mat) {
  var mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
  mesh.position.set(x, y, z);
  mesh.receiveShadow = true;
  arenaGroup.add(mesh);
}

function createGoal(zPos, color) {
  var dir = zPos > 0 ? 1 : -1;
  var frameMat = new THREE.MeshPhysicalMaterial({
    color: color, metalness: 0.85, roughness: 0.15,
    emissive: color, emissiveIntensity: 0.4,
    clearcoat: 0.8, clearcoatRoughness: 0.1
  });

  // Goal posts (thicker, more prominent)
  var postGeo = new THREE.CylinderGeometry(0.45, 0.45, GH, 12);
  var leftPost = new THREE.Mesh(postGeo, frameMat);
  leftPost.position.set(-GW / 2, GH / 2, zPos);
  leftPost.castShadow = true;
  arenaGroup.add(leftPost);
  var rightPost = new THREE.Mesh(postGeo, frameMat);
  rightPost.position.set(GW / 2, GH / 2, zPos);
  rightPost.castShadow = true;
  arenaGroup.add(rightPost);

  // Crossbar
  var barGeo = new THREE.CylinderGeometry(0.45, 0.45, GW + 0.9, 12);
  var crossbar = new THREE.Mesh(barGeo, frameMat);
  crossbar.rotation.z = Math.PI / 2;
  crossbar.position.set(0, GH, zPos);
  crossbar.castShadow = true;
  arenaGroup.add(crossbar);

  // Back posts (goal depth frame)
  var backPostGeo = new THREE.CylinderGeometry(0.25, 0.25, GH, 8);
  var bpL = new THREE.Mesh(backPostGeo, frameMat);
  bpL.position.set(-GW / 2, GH / 2, zPos + dir * GD);
  arenaGroup.add(bpL);
  var bpR = new THREE.Mesh(backPostGeo, frameMat);
  bpR.position.set(GW / 2, GH / 2, zPos + dir * GD);
  arenaGroup.add(bpR);

  // Top back bar
  var topBackBar = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.25, GW, 8), frameMat);
  topBackBar.rotation.z = Math.PI / 2;
  topBackBar.position.set(0, GH, zPos + dir * GD);
  arenaGroup.add(topBackBar);

  // Depth bars connecting front to back
  var depthBarGeo = new THREE.CylinderGeometry(0.2, 0.2, GD, 8);
  [-1, 1].forEach(function(side) {
    var depthTop = new THREE.Mesh(depthBarGeo, frameMat);
    depthTop.rotation.x = Math.PI / 2;
    depthTop.position.set(side * GW / 2, GH, zPos + dir * GD / 2);
    arenaGroup.add(depthTop);
    var depthBot = new THREE.Mesh(depthBarGeo, frameMat);
    depthBot.rotation.x = Math.PI / 2;
    depthBot.position.set(side * GW / 2, 0.2, zPos + dir * GD / 2);
    arenaGroup.add(depthBot);
  });

  // Goal net — wireframe mesh panels
  var netMat = new THREE.MeshBasicMaterial({
    color: 0xffffff, wireframe: true, transparent: true, opacity: 0.12, side: THREE.DoubleSide
  });

  // Back net
  var backNet = new THREE.Mesh(new THREE.PlaneGeometry(GW, GH, 12, 6), netMat);
  backNet.position.set(0, GH / 2, zPos + dir * GD);
  arenaGroup.add(backNet);

  // Side nets
  var sideNetL = new THREE.Mesh(new THREE.PlaneGeometry(GD, GH, 6, 6), netMat);
  sideNetL.rotation.y = Math.PI / 2;
  sideNetL.position.set(-GW / 2, GH / 2, zPos + dir * GD / 2);
  arenaGroup.add(sideNetL);
  var sideNetR = new THREE.Mesh(new THREE.PlaneGeometry(GD, GH, 6, 6), netMat);
  sideNetR.rotation.y = Math.PI / 2;
  sideNetR.position.set(GW / 2, GH / 2, zPos + dir * GD / 2);
  arenaGroup.add(sideNetR);

  // Top net
  var topNet = new THREE.Mesh(new THREE.PlaneGeometry(GW, GD, 12, 4), netMat);
  topNet.rotation.x = Math.PI / 2;
  topNet.position.set(0, GH, zPos + dir * GD / 2);
  arenaGroup.add(topNet);

  // Goal floor highlight (glowing colored floor)
  var goalFloorMat = new THREE.MeshStandardMaterial({
    color: color, transparent: true, opacity: 0.2,
    emissive: color, emissiveIntensity: 0.15
  });
  var goalFloor = new THREE.Mesh(new THREE.PlaneGeometry(GW, GD), goalFloorMat);
  goalFloor.rotation.x = -Math.PI / 2;
  goalFloor.position.set(0, 0.03, zPos + dir * GD / 2);
  arenaGroup.add(goalFloor);

  // Goal line on the field (thick colored line at the mouth)
  var goalLineMat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.6 });
  var goalLine = new THREE.Mesh(new THREE.PlaneGeometry(GW + 2, 0.3), goalLineMat);
  goalLine.rotation.x = -Math.PI / 2;
  goalLine.position.set(0, 0.04, zPos);
  arenaGroup.add(goalLine);
}

function addEdgeLine(x1, y1, z1, x2, y2, z2, color) {
  var geo = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(x1, y1 + 0.05, z1),
    new THREE.Vector3(x2, y2 + 0.05, z2)
  ]);
  var mat = new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: 0.5 });
  arenaGroup.add(new THREE.Line(geo, mat));
}

function createFieldTexture() {
  var c = document.createElement('canvas');
  c.width = 1024; c.height = 1536;
  var ctx = c.getContext('2d');

  var st = STADIUMS[settings.stadium] || STADIUMS.standard;

  // Base field color
  ctx.fillStyle = st.floorColor;
  ctx.fillRect(0, 0, 1024, 1536);

  // Mow stripes (more subtle, realistic)
  for (var i = 0; i < 1536; i += 64) {
    ctx.fillStyle = (i / 64) % 2 === 0 ? st.stripe1 : st.stripe2;
    ctx.fillRect(0, i, 1024, 64);
  }

  // Subtle grass texture noise
  for (var n = 0; n < 8000; n++) {
    var nx = Math.random() * 1024, ny = Math.random() * 1536;
    ctx.fillStyle = 'rgba(255,255,255,' + (Math.random() * 0.02) + ')';
    ctx.fillRect(nx, ny, 1, 1);
  }

  // Field markings — brighter, thicker, more like RL
  ctx.strokeStyle = 'rgba(255,255,255,0.55)';
  ctx.lineWidth = 4;

  // Border
  ctx.strokeRect(20, 20, 984, 1496);

  // Center line
  ctx.beginPath();
  ctx.moveTo(20, 768);
  ctx.lineTo(1004, 768);
  ctx.stroke();

  // Center circle (larger, like RL)
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.arc(512, 768, 140, 0, Math.PI * 2);
  ctx.stroke();

  // Center dot
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.beginPath();
  ctx.arc(512, 768, 8, 0, Math.PI * 2);
  ctx.fill();

  // Kickoff positions (4 diagonal spots)
  var kickoffDist = 180;
  [[-1,-1],[1,-1],[-1,1],[1,1]].forEach(function(k) {
    ctx.beginPath();
    ctx.arc(512 + k[0] * kickoffDist, 768 + k[1] * kickoffDist, 6, 0, Math.PI * 2);
    ctx.fill();
  });

  // Goal areas — larger penalty boxes
  var gw = (GW / FW) * 984;
  var gdSmall = 80;
  var gdLarge = 140;

  // Small goal boxes
  ctx.lineWidth = 3;
  ctx.strokeRect(512 - gw / 2, 20, gw, gdSmall);
  ctx.strokeRect(512 - gw / 2, 1516 - gdSmall, gw, gdSmall);

  // Large penalty areas
  ctx.strokeStyle = 'rgba(255,255,255,0.3)';
  ctx.lineWidth = 2;
  var gwLarge = gw * 1.5;
  ctx.strokeRect(512 - gwLarge / 2, 20, gwLarge, gdLarge);
  ctx.strokeRect(512 - gwLarge / 2, 1516 - gdLarge, gwLarge, gdLarge);

  // Corner quarter-circles
  ctx.strokeStyle = 'rgba(255,255,255,0.35)';
  ctx.lineWidth = 3;
  [[20, 20, 0], [1004, 20, Math.PI/2], [1004, 1516, Math.PI], [20, 1516, -Math.PI/2]].forEach(function(corner) {
    ctx.beginPath();
    ctx.arc(corner[0], corner[1], 30, corner[2], corner[2] + Math.PI / 2);
    ctx.stroke();
  });

  // Half-way marks on sidelines
  ctx.strokeStyle = 'rgba(255,255,255,0.3)';
  ctx.lineWidth = 2;
  [20, 1004].forEach(function(x) {
    ctx.beginPath();
    ctx.moveTo(x, 768 - 15);
    ctx.lineTo(x, 768 + 15);
    ctx.stroke();
  });

  return new THREE.CanvasTexture(c);
}

// ==========================================================================
// BALL
// ==========================================================================
function createBall() {
  // High-poly ball with PBR materials — RL-style glowing ball
  var geo = new THREE.SphereGeometry(BR, 48, 48);
  var mat = new THREE.MeshPhysicalMaterial({
    color: 0xeeeef0, roughness: 0.08, metalness: 0.15,
    emissive: 0xffaa44, emissiveIntensity: 0.12,
    envMapIntensity: 1.8,
    clearcoat: 0.6, clearcoatRoughness: 0.05,
    reflectivity: 0.9
  });
  ball = new THREE.Mesh(geo, mat);
  ball.castShadow = true;
  scene.add(ball);

  // Hexagon panel pattern (RL ball style)
  var wireGeo = new THREE.IcosahedronGeometry(BR * 1.003, 2);
  var wireMat = new THREE.MeshBasicMaterial({
    color: 0x222222, wireframe: true, transparent: true, opacity: 0.15
  });
  var wireOverlay = new THREE.Mesh(wireGeo, wireMat);
  ball.add(wireOverlay);

  // Dynamic point light on ball
  ballGlow = new THREE.PointLight(0xffcc66, 1.5, 25);
  ball.add(ballGlow);

  // Inner energy glow (brighter, more dramatic)
  var glowGeo = new THREE.SphereGeometry(BR * 1.2, 24, 24);
  var glowMat = new THREE.MeshBasicMaterial({
    color: 0xffbb33, transparent: true, opacity: 0.1, side: THREE.BackSide
  });
  var glowSphere = new THREE.Mesh(glowGeo, glowMat);
  ball.add(glowSphere);

  // Outer haze (subtle bloom effect)
  var hazeMat = new THREE.MeshBasicMaterial({
    color: 0xffdd88, transparent: true, opacity: 0.04, side: THREE.BackSide,
    depthWrite: false
  });
  var haze = new THREE.Mesh(new THREE.SphereGeometry(BR * 1.6, 16, 16), hazeMat);
  ball.add(haze);
}

// ==========================================================================
// CARS
// ==========================================================================
function createCar(mainColor, accentColor) {
  var group = new THREE.Group();

  // RL-style car paint — MeshPhysicalMaterial with clearcoat
  var bodyMat = new THREE.MeshPhysicalMaterial({
    color: mainColor, metalness: 0.85, roughness: 0.12,
    envMapIntensity: 1.8, clearcoat: 1.0, clearcoatRoughness: 0.08,
    reflectivity: 0.95
  });

  // Main body (lower, wider — more like Octane)
  var body = new THREE.Mesh(new THREE.BoxGeometry(CW, CH * 0.55, CL * 0.95), bodyMat);
  body.position.y = CH * 0.28;
  body.castShadow = true;
  group.add(body);

  // Hood (sloped front wedge)
  var hoodGeo = new THREE.BoxGeometry(CW * 0.96, CH * 0.25, CL * 0.3);
  var hood = new THREE.Mesh(hoodGeo, bodyMat);
  hood.position.set(0, CH * 0.48, CL * 0.32);
  hood.rotation.x = -0.2;
  hood.castShadow = true;
  group.add(hood);

  // Nose (front lower curve)
  var noseMat = new THREE.MeshPhysicalMaterial({
    color: mainColor, metalness: 0.8, roughness: 0.15,
    clearcoat: 1.0, clearcoatRoughness: 0.1
  });
  var nose = new THREE.Mesh(new THREE.BoxGeometry(CW * 0.9, CH * 0.2, CL * 0.15), noseMat);
  nose.position.set(0, CH * 0.12, CL * 0.48);
  group.add(nose);

  // Cabin (windshield + roof — dark tinted glass)
  var cabMat = new THREE.MeshPhysicalMaterial({
    color: 0x080818, metalness: 0.3, roughness: 0.02,
    envMapIntensity: 3.0, clearcoat: 1.0, clearcoatRoughness: 0.02,
    transmission: 0.3, thickness: 0.5
  });
  var cab = new THREE.Mesh(new THREE.BoxGeometry(CW * 0.82, CH * 0.38, CL * 0.33), cabMat);
  cab.position.set(0, CH * 0.72, -CL * 0.04);
  cab.castShadow = true;
  group.add(cab);

  // Front bumper (accent colored)
  var bumpMat = new THREE.MeshPhysicalMaterial({
    color: accentColor, metalness: 0.6, roughness: 0.25,
    clearcoat: 0.8, clearcoatRoughness: 0.15
  });
  var bump = new THREE.Mesh(new THREE.BoxGeometry(CW * 1.06, CH * 0.28, CL * 0.1), bumpMat);
  bump.position.set(0, CH * 0.14, CL * 0.48);
  group.add(bump);

  // Side skirts (dark carbon fiber look)
  var skirtMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.9, roughness: 0.2 });
  [-1, 1].forEach(function(side) {
    var skirt = new THREE.Mesh(new THREE.BoxGeometry(0.18, CH * 0.22, CL * 0.82), skirtMat);
    skirt.position.set(side * CW * 0.53, CH * 0.11, 0);
    group.add(skirt);
  });

  // Fender flares (wider body above wheels)
  [-1, 1].forEach(function(side) {
    [1, -1].forEach(function(fwd) {
      var flare = new THREE.Mesh(new THREE.BoxGeometry(0.3, CH * 0.35, CL * 0.22), bodyMat);
      flare.position.set(side * CW * 0.55, CH * 0.28, fwd * CL * 0.3);
      group.add(flare);
    });
  });

  // Rear spoiler (larger, more dramatic)
  var spoilerMat = new THREE.MeshPhysicalMaterial({
    color: accentColor, metalness: 0.7, roughness: 0.2,
    clearcoat: 0.9, clearcoatRoughness: 0.1
  });
  var spoilerWing = new THREE.Mesh(new THREE.BoxGeometry(CW * 1.15, 0.1, 0.6), spoilerMat);
  spoilerWing.position.set(0, CH * 1.2, -CL * 0.36);
  spoilerWing.castShadow = true;
  group.add(spoilerWing);
  [-1, 1].forEach(function(side) {
    var support = new THREE.Mesh(new THREE.BoxGeometry(0.14, CH * 0.45, 0.14), skirtMat);
    support.position.set(side * CW * 0.42, CH * 0.98, -CL * 0.36);
    group.add(support);
  });

  // Headlights (bright emissive with lens)
  var headlightMat = new THREE.MeshStandardMaterial({
    color: 0xffffff, emissive: 0xffffee, emissiveIntensity: 1.0
  });
  var headlightLens = new THREE.MeshPhysicalMaterial({
    color: 0xffffff, transmission: 0.8, thickness: 0.2,
    roughness: 0.0, clearcoat: 1.0
  });
  [-1, 1].forEach(function(side) {
    var hl = new THREE.Mesh(new THREE.SphereGeometry(0.22, 10, 10), headlightMat);
    hl.position.set(side * CW * 0.4, CH * 0.32, CL * 0.5);
    group.add(hl);
    var lens = new THREE.Mesh(new THREE.SphereGeometry(0.28, 10, 10), headlightLens);
    lens.position.copy(hl.position);
    group.add(lens);
  });

  // Taillights (bright red)
  var tailMat = new THREE.MeshStandardMaterial({
    color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.8
  });
  [-1, 1].forEach(function(side) {
    var tl = new THREE.Mesh(new THREE.BoxGeometry(CW * 0.22, 0.18, 0.1), tailMat);
    tl.position.set(side * CW * 0.35, CH * 0.32, -CL * 0.5);
    group.add(tl);
  });

  // Wheels — high detail with alloy rims
  var wheelGeo = new THREE.CylinderGeometry(0.55, 0.55, 0.45, 16);
  var wheelMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.7, metalness: 0.3 });
  var rimMat = new THREE.MeshPhysicalMaterial({
    color: 0xdddddd, metalness: 0.95, roughness: 0.05,
    clearcoat: 1.0, clearcoatRoughness: 0.05
  });
  var rimSpokeGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.47, 5);
  [[-1, 1], [1, 1], [-1, -1], [1, -1]].forEach(function(p) {
    var w = new THREE.Mesh(wheelGeo, wheelMat);
    w.rotation.z = Math.PI / 2;
    w.position.set(p[0] * (CW / 2 + 0.18), 0.08, p[1] * CL * 0.33);
    w.castShadow = true;
    group.add(w);
    var rim = new THREE.Mesh(rimSpokeGeo, rimMat);
    rim.rotation.z = Math.PI / 2;
    rim.position.copy(w.position);
    group.add(rim);
    // Rim center cap
    var cap = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.48, 8), rimMat);
    cap.rotation.z = Math.PI / 2;
    cap.position.copy(w.position);
    group.add(cap);
  });

  // Boost nozzle — dual exhaust with orange glow
  var nozMat = new THREE.MeshPhysicalMaterial({
    color: 0x333333, metalness: 0.95, roughness: 0.1,
    clearcoat: 1.0, clearcoatRoughness: 0.05
  });
  var nozGlowMat = new THREE.MeshStandardMaterial({
    color: 0xff4400, emissive: 0xff4400, emissiveIntensity: 0.3,
    transparent: true, opacity: 0.6
  });
  [-1, 1].forEach(function(side) {
    var noz = new THREE.Mesh(new THREE.CylinderGeometry(0.18, 0.32, 0.4, 10), nozMat);
    noz.rotation.x = Math.PI / 2;
    noz.position.set(side * 0.55, CH * 0.22, -CL / 2 - 0.1);
    group.add(noz);
    // Inner glow
    var nozGlow = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.25, 0.15, 8), nozGlowMat);
    nozGlow.rotation.x = Math.PI / 2;
    nozGlow.position.set(side * 0.55, CH * 0.22, -CL / 2 - 0.2);
    group.add(nozGlow);
  });

  // Undercar glow (subtle team color light underneath)
  var underGlow = new THREE.PointLight(mainColor, 0.5, 6);
  underGlow.position.set(0, -0.3, 0);
  group.add(underGlow);

  return group;
}

// ==========================================================================
// BOOST PADS
// ==========================================================================
function createBoostPads() {
  // RL-accurate boost pad layout: 6 large (100%) + 28 small (12%)
  var positions = [
    // 6 Large pads — 4 corners + 2 midfield sides (RL standard)
    { x: -FW * 0.42, z: -FL * 0.38, big: true },
    { x: FW * 0.42, z: -FL * 0.38, big: true },
    { x: -FW * 0.42, z: FL * 0.38, big: true },
    { x: FW * 0.42, z: FL * 0.38, big: true },
    { x: -FW * 0.42, z: 0, big: true },
    { x: FW * 0.42, z: 0, big: true },
    // 28 Small pads — arranged in RL diamond/grid pattern
    // Row near blue goal
    { x: -FW * 0.08, z: -FL * 0.42, big: false },
    { x: FW * 0.08, z: -FL * 0.42, big: false },
    { x: 0, z: -FL * 0.42, big: false },
    // Row 2
    { x: -FW * 0.28, z: -FL * 0.32, big: false },
    { x: FW * 0.28, z: -FL * 0.32, big: false },
    { x: 0, z: -FL * 0.32, big: false },
    // Row 3
    { x: -FW * 0.15, z: -FL * 0.22, big: false },
    { x: FW * 0.15, z: -FL * 0.22, big: false },
    { x: -FW * 0.35, z: -FL * 0.2, big: false },
    { x: FW * 0.35, z: -FL * 0.2, big: false },
    // Row 4 (approaching midfield)
    { x: -FW * 0.08, z: -FL * 0.1, big: false },
    { x: FW * 0.08, z: -FL * 0.1, big: false },
    { x: -FW * 0.28, z: -FL * 0.08, big: false },
    { x: FW * 0.28, z: -FL * 0.08, big: false },
    // Center row
    { x: -FW * 0.15, z: 0, big: false },
    { x: FW * 0.15, z: 0, big: false },
    // Mirrored rows for orange half
    { x: -FW * 0.08, z: FL * 0.1, big: false },
    { x: FW * 0.08, z: FL * 0.1, big: false },
    { x: -FW * 0.28, z: FL * 0.08, big: false },
    { x: FW * 0.28, z: FL * 0.08, big: false },
    { x: -FW * 0.15, z: FL * 0.22, big: false },
    { x: FW * 0.15, z: FL * 0.22, big: false },
    { x: -FW * 0.35, z: FL * 0.2, big: false },
    { x: FW * 0.35, z: FL * 0.2, big: false },
    { x: -FW * 0.28, z: FL * 0.32, big: false },
    { x: FW * 0.28, z: FL * 0.32, big: false },
    { x: 0, z: FL * 0.32, big: false },
    { x: -FW * 0.08, z: FL * 0.42, big: false },
    { x: FW * 0.08, z: FL * 0.42, big: false },
    { x: 0, z: FL * 0.42, big: false },
  ];

  positions.forEach(function(p) {
    var padGroup = new THREE.Group();
    padGroup.position.set(p.x, 0, p.z);

    if (p.big) {
      // Large pad — RL-style floating glowing orb
      var orbGeo = new THREE.SphereGeometry(1.2, 16, 16);
      var orbMat = new THREE.MeshPhysicalMaterial({
        color: 0xffcc00, emissive: 0xffaa00, emissiveIntensity: 0.8,
        transparent: true, opacity: 0.85, metalness: 0.3, roughness: 0.1
      });
      var orb = new THREE.Mesh(orbGeo, orbMat);
      orb.position.y = 2.0; // floating above ground
      padGroup.add(orb);

      // Orb outer glow
      var orbGlow = new THREE.Mesh(
        new THREE.SphereGeometry(1.8, 12, 12),
        new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.12, side: THREE.BackSide, depthWrite: false })
      );
      orbGlow.position.y = 2.0;
      padGroup.add(orbGlow);

      // Ground circle marker
      var groundCircle = new THREE.Mesh(
        new THREE.CylinderGeometry(2.2, 2.2, 0.08, 24),
        new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0xffaa00, emissiveIntensity: 0.5, transparent: true, opacity: 0.6 })
      );
      groundCircle.position.y = 0.05;
      padGroup.add(groundCircle);

      // Point light on big pad
      var padLight = new THREE.PointLight(0xffaa00, 1.5, 12);
      padLight.position.y = 2.0;
      padGroup.add(padLight);

    } else {
      // Small pad — flat glowing disc on ground (RL penny pad style)
      var discGeo = new THREE.CylinderGeometry(0.7, 0.7, 0.12, 12);
      var discMat = new THREE.MeshStandardMaterial({
        color: 0xffaa00, emissive: 0xff8800, emissiveIntensity: 0.5,
        transparent: true, opacity: 0.75
      });
      var disc = new THREE.Mesh(discGeo, discMat);
      disc.position.y = 0.08;
      padGroup.add(disc);

      // Small glow above disc
      var smallGlow = new THREE.Mesh(
        new THREE.SphereGeometry(0.25, 8, 8),
        new THREE.MeshBasicMaterial({ color: 0xffcc44, transparent: true, opacity: 0.4 })
      );
      smallGlow.position.y = 0.4;
      padGroup.add(smallGlow);
    }

    scene.add(padGroup);
    boostPads.push({
      mesh: padGroup, x: p.x, z: p.z, big: p.big,
      r: p.big ? 2.2 : 0.7,
      active: true, respawnT: 0, cooldown: p.big ? 10 : 4
    });
  });
}

// ==========================================================================
// PARTICLES
// ==========================================================================
function spawnParticle(x, y, z, vx, vy, vz, color, life, size) {
  var geo = new THREE.SphereGeometry(size, 6, 6);
  var mat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 1 });
  var mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x, y, z);
  scene.add(mesh);
  particles.push({
    mesh: mesh, vx: vx, vy: vy, vz: vz,
    life: life, maxLife: life
  });
}

function spawnBoostTrail(carGroup, rot) {
  var backX = carGroup.position.x - Math.sin(rot) * CL * 0.5;
  var backZ = carGroup.position.z - Math.cos(rot) * CL * 0.5;
  var backY = carGroup.position.y + CH * 0.25;
  // Spawn 2 particles per frame for denser flame effect
  for (var b = 0; b < 2; b++) {
    var flameColor = Math.random() > 0.6 ? 0xff2200 : (Math.random() > 0.4 ? 0xff6600 : 0xffaa00);
    if (Math.random() > 0.85) flameColor = 0xffee88; // hot white core
    spawnParticle(
      backX + (Math.random() - 0.5) * 0.6,
      backY + (Math.random() - 0.5) * 0.4,
      backZ + (Math.random() - 0.5) * 0.6,
      (Math.random() - 0.5) * 4 - Math.sin(rot) * 7,
      Math.random() * 5 + 1.5,
      (Math.random() - 0.5) * 4 - Math.cos(rot) * 7,
      flameColor,
      0.35 + Math.random() * 0.35,
      0.2 + Math.random() * 0.35
    );
  }
}

function spawnGoalExplosion(zPos, color) {
  var dir = zPos > 0 ? -1 : 1;
  // Main explosion burst (more particles, more dramatic)
  for (var i = 0; i < 120; i++) {
    var angle = Math.random() * Math.PI * 2;
    var upV = Math.random() * 28 + 8;
    var outV = Math.random() * 22 + 5;
    var pColor = i % 4 === 0 ? 0xffffff : (i % 3 === 0 ? 0xffdd00 : color);
    spawnParticle(
      (Math.random() - 0.5) * GW,
      Math.random() * GH,
      zPos + dir * Math.random() * 3,
      Math.cos(angle) * outV + (Math.random() - 0.5) * 10,
      upV,
      dir * (Math.random() * 20 + 8) + Math.sin(angle) * outV * 0.3,
      pColor,
      1.5 + Math.random() * 2.0,
      0.25 + Math.random() * 0.7
    );
  }
  // Confetti-like sparkles
  for (var j = 0; j < 40; j++) {
    var confettiColors = [0xff4444, 0x44ff44, 0x4444ff, 0xffff44, 0xff44ff, 0x44ffff, 0xffffff];
    spawnParticle(
      (Math.random() - 0.5) * GW * 1.5,
      Math.random() * GH * 1.5 + 3,
      zPos + dir * Math.random() * 5,
      (Math.random() - 0.5) * 15,
      Math.random() * 15 + 10,
      dir * Math.random() * 10,
      confettiColors[Math.floor(Math.random() * confettiColors.length)],
      2.5 + Math.random() * 2,
      0.15 + Math.random() * 0.25
    );
  }
}

function updateParticles(dt) {
  for (var i = particles.length - 1; i >= 0; i--) {
    var p = particles[i];
    p.life -= dt;
    if (p.life <= 0) {
      scene.remove(p.mesh);
      p.mesh.geometry.dispose();
      p.mesh.material.dispose();
      particles.splice(i, 1);
      continue;
    }
    p.vy += GRAV * 0.3 * dt;
    p.mesh.position.x += p.vx * dt;
    p.mesh.position.y += p.vy * dt;
    p.mesh.position.z += p.vz * dt;
    if (p.mesh.position.y < 0) { p.mesh.position.y = 0; p.vy *= -0.3; }
    p.mesh.material.opacity = p.life / p.maxLife;
    var s = (p.life / p.maxLife) * p.mesh.geometry.parameters.radius * 2;
    p.mesh.scale.setScalar(Math.max(s, 0.01));
  }
}

// ==========================================================================
// BALL TRAIL — glowing trail behind fast-moving ball
// ==========================================================================
function updateBallTrail(dt) {
  var bSpd = bV.length();
  // Only show trail when ball is moving decently fast
  if (bSpd > 12 && gameState === 'playing') {
    // Add new trail point
    if (ballTrail.length < BALL_TRAIL_MAX) {
      var trailGeo = new THREE.SphereGeometry(BR_ACTIVE * 0.7, 6, 6);
      var trailColor = bSpd > 50 ? 0xff4400 : (bSpd > 30 ? 0xffaa00 : 0xffcc66);
      var trailMat = new THREE.MeshBasicMaterial({
        color: trailColor, transparent: true, opacity: 0.35
      });
      var trailMesh = new THREE.Mesh(trailGeo, trailMat);
      trailMesh.position.copy(bP);
      scene.add(trailMesh);
      ballTrail.push({ mesh: trailMesh, life: 0.3 + bSpd * 0.003, maxLife: 0.3 + bSpd * 0.003 });
    }
  }
  // Update existing trail
  for (var i = ballTrail.length - 1; i >= 0; i--) {
    var t = ballTrail[i];
    t.life -= dt;
    if (t.life <= 0) {
      scene.remove(t.mesh);
      t.mesh.geometry.dispose();
      t.mesh.material.dispose();
      ballTrail.splice(i, 1);
    } else {
      var frac = t.life / t.maxLife;
      t.mesh.material.opacity = frac * 0.35;
      t.mesh.scale.setScalar(frac * 0.8 + 0.2);
    }
  }
}

// ==========================================================================
// DEMOLITION SYSTEM
// ==========================================================================
function triggerDemo(isPlayer) {
  if (isPlayer) {
    pDemoed = true; pDemoTimer = 3.0;
    playerCar.visible = false;
    // Explosion particles at player position
    spawnDemoExplosion(pP.x, pP.y, pP.z, 0xff6600);
  } else {
    aDemoed = true; aDemoTimer = 3.0;
    aiCar.visible = false;
    spawnDemoExplosion(aP.x, aP.y, aP.z, 0x0066ff);
  }
  playDemoSound();
  showDemoText(isPlayer ? 'DEMOLISHED!' : 'DEMO!');
}

function spawnDemoExplosion(x, y, z, color) {
  // RL-style massive demo explosion
  for (var i = 0; i < 80; i++) {
    var angle = Math.random() * Math.PI * 2;
    var upV = Math.random() * 30 + 10;
    var outV = Math.random() * 25 + 8;
    var demoColor = i % 5 === 0 ? 0xffffff : (i % 4 === 0 ? 0xffee44 : (i % 3 === 0 ? 0xffaa00 : (i % 2 === 0 ? color : 0xff4400)));
    spawnParticle(
      x + (Math.random() - 0.5) * 3, y + Math.random() * 2.5, z + (Math.random() - 0.5) * 3,
      Math.cos(angle) * outV, upV, Math.sin(angle) * outV,
      demoColor,
      1.2 + Math.random() * 1.8, 0.25 + Math.random() * 0.6
    );
  }
  // Car debris chunks
  for (var d = 0; d < 8; d++) {
    var debrisAngle = Math.random() * Math.PI * 2;
    spawnParticle(
      x, y + 1, z,
      Math.cos(debrisAngle) * 15, Math.random() * 20 + 12, Math.sin(debrisAngle) * 15,
      0x444444, 2.0 + Math.random(), 0.5 + Math.random() * 0.5
    );
  }
  triggerScreenShake(1.0);
}

function updateDemos(dt) {
  if (pDemoed) {
    pDemoTimer -= dt;
    if (pDemoTimer <= 0) {
      pDemoed = false;
      playerCar.visible = true;
      pP.set(0, CH / 2, FL * 0.33);
      pV.set(0, 0, 0);
      pSpeed = 0; pRot = Math.PI;
      pBoost = BOOST_MAX;
    }
  }
  if (aDemoed) {
    aDemoTimer -= dt;
    if (aDemoTimer <= 0) {
      aDemoed = false;
      aiCar.visible = true;
      aP.set(0, CH / 2, -FL * 0.33);
      aV.set(0, 0, 0);
      aSpeed = 0; aRot = 0;
      aBoost = BOOST_MAX;
    }
  }
}

function showDemoText(text) {
  var el = document.getElementById('demo-text');
  el.textContent = text;
  el.className = 'show';
  _demoTextTimer = 1.5;
}

function updateDemoText(dt) {
  if (_demoTextTimer > 0) {
    _demoTextTimer -= dt;
    if (_demoTextTimer <= 0) {
      document.getElementById('demo-text').className = '';
    }
  }
}

function playDemoSound() {
  var ctx = getAudio(); if (!ctx) return;
  // Low boom + high crackle
  var osc1 = ctx.createOscillator();
  var osc2 = ctx.createOscillator();
  var gain1 = ctx.createGain();
  var gain2 = ctx.createGain();
  osc1.connect(gain1); gain1.connect(ctx.destination);
  osc2.connect(gain2); gain2.connect(ctx.destination);
  osc1.type = 'sawtooth'; osc1.frequency.setValueAtTime(80, ctx.currentTime);
  osc1.frequency.exponentialRampToValueAtTime(30, ctx.currentTime + 0.4);
  gain1.gain.setValueAtTime(0.3 * VOLUME_SCALE, ctx.currentTime);
  gain1.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.4);
  osc2.type = 'square'; osc2.frequency.setValueAtTime(2000, ctx.currentTime);
  osc2.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.15);
  gain2.gain.setValueAtTime(0.15 * VOLUME_SCALE, ctx.currentTime);
  gain2.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15);
  osc1.start(); osc1.stop(ctx.currentTime + 0.4);
  osc2.start(); osc2.stop(ctx.currentTime + 0.15);
}

// ==========================================================================
// SCREEN SHAKE
// ==========================================================================
function triggerScreenShake(intensity) {
  _shakeIntensity = intensity;
  _shakeTimer = 0.15;
  document.body.classList.add('shake');
}

function updateScreenShake(dt) {
  if (_shakeTimer > 0) {
    _shakeTimer -= dt;
    if (_shakeTimer <= 0) {
      document.body.classList.remove('shake');
      _shakeIntensity = 0;
    }
  }
}

// ==========================================================================
// GOAL FLASH
// ==========================================================================
function triggerGoalFlash(team) {
  var el = document.getElementById('goal-flash');
  el.className = team;
  _goalFlashTimer = 1.5;
}

function updateGoalFlash(dt) {
  if (_goalFlashTimer > 0) {
    _goalFlashTimer -= dt;
    if (_goalFlashTimer <= 0) {
      document.getElementById('goal-flash').className = '';
    } else if (_goalFlashTimer < 0.5) {
      document.getElementById('goal-flash').style.opacity = _goalFlashTimer / 0.5;
    }
  }
}

// ==========================================================================
// SUPERSONIC SPEED CHECK
// ==========================================================================
function updateSupersonic() {
  var maxSpd = CAR_BOOST_MAX * CAR_SPEED_MULT;
  pSupersonic = Math.abs(pSpeed) > maxSpd * SUPERSONIC_THRESH;
}

function spawnSupersonicTrail(carGroup, rot) {
  // Purple/white speed trail behind car — more intense like RL
  var backX = carGroup.position.x - Math.sin(rot) * CL * 0.55;
  var backZ = carGroup.position.z - Math.cos(rot) * CL * 0.55;
  var backY = carGroup.position.y + CH * 0.5;
  for (var s = 0; s < 2; s++) {
    var trailColor = Math.random() > 0.5 ? 0xbb55ff : (Math.random() > 0.5 ? 0xeeddff : 0x8844dd);
    spawnParticle(
      backX + (Math.random() - 0.5) * 1.0,
      backY + (Math.random() - 0.5) * 0.5,
      backZ + (Math.random() - 0.5) * 1.0,
      (Math.random() - 0.5) * 3 - Math.sin(rot) * 10,
      Math.random() * 3,
      (Math.random() - 0.5) * 3 - Math.cos(rot) * 10,
      trailColor,
      0.25 + Math.random() * 0.25,
      0.15 + Math.random() * 0.25
    );
  }
}

// ==========================================================================
// AUDIO
// ==========================================================================
function getAudio() {
  if (!audioCtx) {
    try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e) {}
  }
  if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
  return audioCtx;
}

function playHitSound(strength) {
  var ctx = getAudio(); if (!ctx) return;
  var osc = ctx.createOscillator();
  var gain = ctx.createGain();
  osc.connect(gain); gain.connect(ctx.destination);
  osc.frequency.value = 400 + strength * 15;
  osc.type = 'triangle';
  gain.gain.setValueAtTime(Math.min(strength / 50, 0.3) * VOLUME_SCALE, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15);
  osc.start(); osc.stop(ctx.currentTime + 0.15);
}

function playGoalHorn() {
  var ctx = getAudio(); if (!ctx) return;
  [220, 277, 330].forEach(function(freq, i) {
    var osc = ctx.createOscillator();
    var gain = ctx.createGain();
    osc.connect(gain); gain.connect(ctx.destination);
    osc.frequency.value = freq;
    osc.type = 'sawtooth';
    gain.gain.setValueAtTime(0.15 * VOLUME_SCALE, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 1.5);
    osc.start(ctx.currentTime + i * 0.05);
    osc.stop(ctx.currentTime + 1.5);
  });
}

function playJumpSound() {
  var ctx = getAudio(); if (!ctx) return;
  var osc = ctx.createOscillator();
  var gain = ctx.createGain();
  osc.connect(gain); gain.connect(ctx.destination);
  osc.type = 'sine';
  osc.frequency.setValueAtTime(200, ctx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(600, ctx.currentTime + 0.12);
  gain.gain.setValueAtTime(0.12 * VOLUME_SCALE, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15);
  osc.start(); osc.stop(ctx.currentTime + 0.15);
}

function playDodgeSound() {
  var ctx = getAudio(); if (!ctx) return;
  var osc = ctx.createOscillator();
  var gain = ctx.createGain();
  osc.connect(gain); gain.connect(ctx.destination);
  osc.type = 'sawtooth';
  osc.frequency.setValueAtTime(300, ctx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(800, ctx.currentTime + 0.08);
  osc.frequency.exponentialRampToValueAtTime(200, ctx.currentTime + 0.2);
  gain.gain.setValueAtTime(0.15 * VOLUME_SCALE, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.2);
  osc.start(); osc.stop(ctx.currentTime + 0.2);
}

function playCountdownBeep(high) {
  var ctx = getAudio(); if (!ctx) return;
  var osc = ctx.createOscillator();
  var gain = ctx.createGain();
  osc.connect(gain); gain.connect(ctx.destination);
  osc.frequency.value = high ? 880 : 440;
  osc.type = 'sine';
  gain.gain.setValueAtTime(0.2 * VOLUME_SCALE, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.3);
  osc.start(); osc.stop(ctx.currentTime + 0.3);
}

// ==========================================================================
// RESET & GAME FLOW
// ==========================================================================
function resetPositions() {
  bP.set(0, BR_ACTIVE + 0.5, 0);
  bV.set(0, 0, 0);
  pP.set(0, CH / 2, FL * 0.33);
  pV.set(0, 0, 0);
  pRot = Math.PI; pSpeed = 0; pGround = true; pBoost = BOOST_MAX;
  pCanDodge = false; pDodgeTimer = 0; pSpin = 0; pPowerslide = false;
  aP.set(0, CH / 2, -FL * 0.33);
  aV.set(0, 0, 0);
  aRot = 0; aSpeed = 0; aGround = true; aBoost = BOOST_MAX;

  // 2v2 positions
  if (settings.teams === '2v2') {
    a2P.set(-12, CH / 2, FL * 0.25);
    a2V.set(0, 0, 0); a2Rot = Math.PI; a2Speed = 0; a2Ground = true; a2Boost = BOOST_MAX;
    a3P.set(12, CH / 2, -FL * 0.25);
    a3V.set(0, 0, 0); a3Rot = 0; a3Speed = 0; a3Ground = true; a3Boost = BOOST_MAX;
  }
  syncVisuals();
}

var _currentStadium = 'standard';

function startGame() {
  recalcActiveValues();
  applySettings();

  // Rebuild arena if stadium changed
  if (settings.stadium !== _currentStadium) {
    applyStadium();
    rebuildArena();
    _currentStadium = settings.stadium;
  }

  score = [0, 0];
  gameTime = settings.duration || 99999;
  GAME_DURATION = settings.duration || 99999;
  WIN_SCORE = settings.winScore || 99999;
  pBoost = BOOST_MAX;
  aBoost = BOOST_MAX;

  // 2v2: create extra cars if needed
  setup2v2();

  resetPositions();
  gameState = 'countdown';
  countdownVal = 3;
  countdownT = 0;
  document.getElementById('menu').style.display = 'none';
  document.getElementById('settings').style.display = 'none';
  document.getElementById('game-over').style.display = 'none';
  document.getElementById('hud').style.display = 'flex';
  document.getElementById('boost-container').style.display = 'block';
  document.getElementById('ball-speed').style.display = 'block';
  pDemoed = false; pDemoTimer = 0; playerCar.visible = true;
  aDemoed = false; aDemoTimer = 0; aiCar.visible = true;
  pSupersonic = false;
  closeQuickChat();
  updateScoreboard();
  showOverlay(String(countdownVal));
  playCountdownBeep(false);
  // Reset boost pads
  boostPads.forEach(function(pad) { pad.active = true; pad.mesh.visible = true; pad.respawnT = 0; });
}

function rebuildArena() {
  // Remove old arena and boost pads
  if (arenaGroup) {
    scene.remove(arenaGroup);
    arenaGroup.traverse(function(obj) {
      if (obj.geometry) obj.geometry.dispose();
      if (obj.material) {
        if (obj.material.map) obj.material.map.dispose();
        obj.material.dispose();
      }
    });
  }
  boostPads.forEach(function(pad) {
    scene.remove(pad.mesh);
    pad.mesh.traverse(function(obj) {
      if (obj.geometry) obj.geometry.dispose();
      if (obj.material) obj.material.dispose();
    });
  });
  boostPads = [];

  // Apply stadium theme
  var s = STADIUMS[settings.stadium] || STADIUMS.standard;
  scene.fog = new THREE.Fog(s.fogColor, FL * 0.8, FL * 2.0);
  createSkybox(); // Regenerate skybox for environment reflections

  createArena();
  createBoostPads();
}

function setup2v2() {
  if (settings.teams === '2v2') {
    if (!aiCar2) {
      aiCar2 = createCar(0xff8800, 0xffaa00); // orange teammate
      scene.add(aiCar2);
    }
    if (!aiCar3) {
      aiCar3 = createCar(0x0044cc, 0x0066ee); // blue teammate
      scene.add(aiCar3);
    }
    aiCar2.visible = true;
    aiCar3.visible = true;
  } else {
    if (aiCar2) aiCar2.visible = false;
    if (aiCar3) aiCar3.visible = false;
  }
}

function showOverlay(text, cls) {
  var el = document.getElementById('overlay-text');
  el.textContent = text;
  el.className = 'show' + (cls ? ' ' + cls : '');
}

function hideOverlay() {
  document.getElementById('overlay-text').className = '';
}

function updateScoreboard() {
  document.getElementById('scoreOrange').textContent = score[0];
  document.getElementById('scoreBlue').textContent = score[1];
  var t = settings.duration > 0 ? gameTime : gameTime; // count down or up
  var m = Math.floor(Math.abs(t) / 60);
  var s = Math.floor(Math.abs(t) % 60);
  document.getElementById('timer').textContent = m + ':' + (s < 10 ? '0' : '') + s;
}

function onGoal(scorer) {
  if (scorer === 'player') {
    score[0]++;
    spawnGoalExplosion(-FL / 2, 0xff6600);
    triggerGoalFlash('orange');
  } else {
    score[1]++;
    spawnGoalExplosion(FL / 2, 0x0066ff);
    triggerGoalFlash('blue');
  }
  playGoalHorn();
  triggerScreenShake(1.0);
  updateScoreboard();
  goalScorer = scorer;
  goalT = 0;
  gameState = 'goal';
  showOverlay('GOAL!', 'goal');

  if (score[0] >= WIN_SCORE || score[1] >= WIN_SCORE) {
    setTimeout(endGame, 2500);
  }
}

function endGame() {
  gameState = 'gameover';
  hideOverlay();
  var go = document.getElementById('game-over');
  go.style.display = 'flex';
  var title = document.getElementById('go-title');
  if (score[0] > score[1]) {
    title.textContent = 'YOU WIN!';
    title.style.color = '#ff7b00';
  } else if (score[1] > score[0]) {
    title.textContent = 'YOU LOSE';
    title.style.color = '#0088ff';
  } else {
    title.textContent = 'DRAW';
    title.style.color = '#ccc';
  }
  document.getElementById('go-score').textContent = score[0] + ' - ' + score[1];
}

// ==========================================================================
// PHYSICS UPDATE
// ==========================================================================
function updatePlayer(dt) {
  if (gameState !== 'playing') return;
  if (pDemoed) return; // demolished, skip physics

  // Powerslide
  pPowerslide = isControl('powerslide') && pGround;

  // Acceleration
  var accel = 0;
  if (isControl('forward')) accel += CAR_ACCEL;
  if (isControl('backward')) accel -= CAR_BRAKE;

  var canBoost = settings.boost === 0 ? false : (settings.boost === 2 || pBoost > 0);
  var boosting = isControl('boost') && canBoost && accel >= 0;
  if (boosting) {
    accel += CAR_ACCEL * 0.8;
    if (settings.boost === 1) pBoost = Math.max(0, pBoost - BOOST_USE * dt);
    if (settings.boost === 3) pBoost = Math.max(0, pBoost - BOOST_USE * 0.5 * dt);
  } else if (settings.boost === 3) {
    pBoost = Math.min(BOOST_MAX, pBoost + 20 * dt);
  }

  pSpeed += accel * dt;

  // Speed limits
  var maxSpd = (boosting ? CAR_BOOST_MAX : CAR_MAX) * CAR_SPEED_MULT;
  pSpeed = Math.max(-CAR_MAX * CAR_SPEED_MULT * 0.45, Math.min(pSpeed, maxSpd));

  // Friction — powerslide preserves more speed but reduces grip
  if (pPowerslide) {
    pSpeed *= 0.993; // much less friction when drifting
  } else {
    pSpeed *= pGround ? CAR_FRIC : CAR_AIR_FRIC;
  }
  if (Math.abs(pSpeed) < 0.3 && accel === 0) pSpeed = 0;

  // Steering — powerslide allows sharper turns
  var baseTurn = pPowerslide ? CAR_TURN * 1.6 : CAR_TURN;
  var turnFactor = pPowerslide ? Math.min(Math.abs(pSpeed) / 6, 1) : Math.min(Math.abs(pSpeed) / 12, 1);
  var turnDir = pSpeed >= 0 ? 1 : -1;
  if (isControl('left')) pRot += baseTurn * dt * turnFactor * turnDir;
  if (isControl('right')) pRot -= baseTurn * dt * turnFactor * turnDir;

  // Velocity from speed + rotation
  if (pPowerslide) {
    // Powerslide: velocity lerps toward car facing direction (drift)
    var targetVx = Math.sin(pRot) * pSpeed;
    var targetVz = Math.cos(pRot) * pSpeed;
    pV.x += (targetVx - pV.x) * 3.5 * dt; // slow alignment = drift
    pV.z += (targetVz - pV.z) * 3.5 * dt;
  } else {
    pV.x = Math.sin(pRot) * pSpeed;
    pV.z = Math.cos(pRot) * pSpeed;
  }

  // Gravity
  pV.y += GRAV_ACTIVE * dt;

  // Aerial boost — boosting while airborne applies force in car's facing direction (RL flying)
  if (boosting && !pGround) {
    var aerialForce = CAR_ACCEL * 1.2;
    pV.x += Math.sin(pRot) * aerialForce * dt;
    pV.z += Math.cos(pRot) * aerialForce * dt;
    pV.y += 18 * dt; // counteract some gravity when boosting in air
    // Clamp aerial speed
    var aerialSpd = pV.length();
    if (aerialSpd > CAR_BOOST_MAX * CAR_SPEED_MULT * 1.1) {
      pV.multiplyScalar(CAR_BOOST_MAX * CAR_SPEED_MULT * 1.1 / aerialSpd);
    }
  }

  // Jump / Dodge (1.25s flip window like Rocket League)
  var jumpKey = isControl('jump');
  if (jumpKey && !keys['_jumpUsed']) {
    keys['_jumpUsed'] = true;
    if (pGround) {
      pV.y = JUMP_V;
      pGround = false;
      pCanDodge = true;
      pDodgeTimer = 1.25; // RL-accurate flip window
      playJumpSound();
    } else if (pCanDodge && pDodgeTimer > 0) {
      pCanDodge = false;
      // Dodge direction based on movement input
      var dx = 0, dz = 0;
      if (isControl('forward')) dz += 1;
      if (isControl('backward')) dz -= 1;
      if (isControl('left')) dx += 1;
      if (isControl('right')) dx -= 1;
      if (dx !== 0 || dz !== 0) {
        // Directional flip
        var dodgeX = Math.sin(pRot) * dz + Math.cos(pRot) * dx;
        var dodgeZ = Math.cos(pRot) * dz - Math.sin(pRot) * dx;
        var len = Math.sqrt(dodgeX * dodgeX + dodgeZ * dodgeZ);
        dodgeX /= len; dodgeZ /= len;

        // Forward flip speed burst (RL mechanic: front flips add extra speed)
        var flipBonus = 1.0;
        if (dz > 0 && dx === 0) flipBonus = 1.4; // forward flip is fastest
        else if (dz > 0) flipBonus = 1.2;          // diagonal forward flip

        pV.x += dodgeX * DODGE_V * flipBonus;
        pV.z += dodgeZ * DODGE_V * flipBonus;
        // Cancel vertical momentum for snappier flips
        pV.y = 0;
        pSpeed = Math.sqrt(pV.x * pV.x + pV.z * pV.z) * (pSpeed >= 0 ? 1 : -1);
        pSpin = 0.45;
        playDodgeSound();
      } else {
        // No direction = double jump (straight up)
        pV.y = JUMP_V * 0.8;
        playJumpSound();
      }
    }
  }
  if (!jumpKey) keys['_jumpUsed'] = false;

  if (!pGround) pDodgeTimer -= dt;
  if (pSpin > 0) pSpin -= dt;

  // Update position
  pP.x += pV.x * dt;
  pP.y += pV.y * dt;
  pP.z += pV.z * dt;

  // Ground check
  if (pP.y <= CH / 2) {
    pP.y = CH / 2;
    pV.y = 0;
    pGround = true;
  }

  // Wall collisions
  clampCar(pP, pV);

  // Reset position if stuck
  if (isControl('reset') && !keys['_rUsed']) {
    keys['_rUsed'] = true;
    pP.set(0, CH / 2, FL * 0.33);
    pV.set(0, 0, 0);
    pSpeed = 0;
    pRot = Math.PI;
  }
  if (!isControl('reset')) keys['_rUsed'] = false;

  // Boost trail
  if (boosting && Math.random() < 0.6) {
    spawnBoostTrail(playerCar, pRot);
  }

  // Powerslide smoke particles
  if (pPowerslide && Math.abs(pSpeed) > 8 && Math.random() < 0.5) {
    spawnParticle(
      pP.x + (Math.random() - 0.5) * CW,
      0.3,
      pP.z + (Math.random() - 0.5) * CL,
      (Math.random() - 0.5) * 4, Math.random() * 3 + 1, (Math.random() - 0.5) * 4,
      0x888888, 0.5 + Math.random() * 0.3, 0.3 + Math.random() * 0.4
    );
  }

  // Supersonic trail
  updateSupersonic();
  if (pSupersonic && Math.random() < 0.7) {
    spawnSupersonicTrail(playerCar, pRot);
  }
}

function updateAI(dt) {
  if (gameState !== 'playing') return;
  if (aDemoed) return; // demolished, skip

  // AI target: position behind ball relative to player's goal
  var ballToGoalX = 0 - bP.x;
  var ballToGoalZ = FL / 2 - bP.z;
  var bgLen = Math.sqrt(ballToGoalX * ballToGoalX + ballToGoalZ * ballToGoalZ) || 1;
  var offsetDist = 4;
  var targetX = bP.x - (ballToGoalX / bgLen) * offsetDist;
  var targetZ = bP.z - (ballToGoalZ / bgLen) * offsetDist;

  // If ball is behind AI (closer to AI's goal), go directly to ball
  if (bP.z < aP.z - 3) {
    targetX = bP.x;
    targetZ = bP.z;
  }

  // If ball is very close to AI's goal, panic and go straight to ball
  if (bP.z < -FL * 0.35) {
    targetX = bP.x;
    targetZ = bP.z;
  }

  // Steer toward target
  var desiredRot = Math.atan2(targetX - aP.x, targetZ - aP.z);
  var angleDiff = desiredRot - aRot;
  while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
  while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

  var turnAmount = CAR_TURN * dt * Math.min(Math.abs(aSpeed) / 12, 1);
  if (Math.abs(angleDiff) < turnAmount) {
    aRot = desiredRot;
  } else {
    aRot += Math.sign(angleDiff) * turnAmount;
  }

  // Accelerate
  var distToBall = Math.sqrt(
    (bP.x - aP.x) * (bP.x - aP.x) + (bP.z - aP.z) * (bP.z - aP.z)
  );

  var aiBoosting = distToBall > (30 - AI_REACT * 5) && aBoost > 15 && settings.boost !== 0;
  aSpeed += CAR_ACCEL * AI_REACT * dt;
  if (aiBoosting) {
    aSpeed += CAR_ACCEL * 0.5 * AI_REACT * dt;
    if (settings.boost === 2) { /* unlimited */ }
    else if (settings.boost === 3) aBoost = Math.max(0, aBoost - BOOST_USE * 0.5 * dt);
    else aBoost = Math.max(0, aBoost - BOOST_USE * dt);
  } else if (settings.boost === 3) {
    aBoost = Math.min(BOOST_MAX, aBoost + 20 * dt);
  }
  var aiMax = (aiBoosting ? CAR_BOOST_MAX : CAR_MAX) * AI_MULT * CAR_SPEED_MULT;
  aSpeed = Math.min(aSpeed, aiMax);
  aSpeed *= CAR_FRIC;

  // Velocity
  aV.x = Math.sin(aRot) * aSpeed;
  aV.z = Math.cos(aRot) * aSpeed;
  aV.y += GRAV_ACTIVE * dt;

  // Simple jump when ball is high and close
  var jumpChance = 0.01 + AI_REACT * 0.015;
  if (bP.y > 5 && distToBall < 18 && aGround && Math.random() < jumpChance) {
    aV.y = JUMP_V;
    aGround = false;
  }

  // Update position
  aP.x += aV.x * dt;
  aP.y += aV.y * dt;
  aP.z += aV.z * dt;

  // Ground
  if (aP.y <= CH / 2) {
    aP.y = CH / 2;
    aV.y = 0;
    aGround = true;
  }

  // Walls
  clampCar(aP, aV);

  // Boost trail
  if (aiBoosting && Math.random() < 0.4) {
    spawnBoostTrail(aiCar, aRot);
  }
}

// Extra AI for 2v2 mode (simplified version of updateAI)
function updateExtraAI(dt, pos, vel, rot, speed, onGnd, bst, goalZ, isOrange) {
  if (gameState !== 'playing') return;

  // Target: aim to hit ball toward opponent goal
  var oppGoalZ = isOrange ? -FL / 2 : FL / 2;
  var targetX = bP.x;
  var targetZ = bP.z + (bP.z < pos.z ? -3 : 3) * (isOrange ? -1 : 1);

  // If ball is behind us, go defensive
  if ((isOrange && bP.z > pos.z + 5) || (!isOrange && bP.z < pos.z - 5)) {
    targetX = bP.x;
    targetZ = bP.z;
  }

  var desiredRot = Math.atan2(targetX - pos.x, targetZ - pos.z);
  var angleDiff = desiredRot - rot;
  while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
  while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

  var turnAmount = CAR_TURN * dt * 0.8;
  rot += (Math.abs(angleDiff) < turnAmount) ? (angleDiff - rot + rot) * 0 + angleDiff : Math.sign(angleDiff) * turnAmount;
  // Simpler: just set rot
  if (Math.abs(angleDiff) < turnAmount) rot = desiredRot;
  else rot += Math.sign(angleDiff) * turnAmount;

  speed += CAR_ACCEL * AI_REACT * 0.8 * dt;
  speed = Math.min(speed, CAR_MAX * AI_MULT * CAR_SPEED_MULT * 0.9);
  speed *= CAR_FRIC;

  vel.x = Math.sin(rot) * speed;
  vel.z = Math.cos(rot) * speed;
  vel.y += GRAV_ACTIVE * dt;

  pos.x += vel.x * dt;
  pos.y += vel.y * dt;
  pos.z += vel.z * dt;

  if (pos.y <= CH / 2) { pos.y = CH / 2; vel.y = 0; }
  clampCar(pos, vel);

  // Store back (since JS passes objects by ref, pos/vel are updated in place)
  // But rot and speed are primitives — need to store them
  if (isOrange) { a2Rot = rot; a2Speed = speed; a2Ground = pos.y <= CH / 2 + 0.1; }
  else { a3Rot = rot; a3Speed = speed; a3Ground = pos.y <= CH / 2 + 0.1; }
}

function updateBall(dt) {
  if (gameState !== 'playing') {
    if (gameState === 'countdown') {
      bP.set(0, BR + 0.5, 0);
      bV.set(0, 0, 0);
    }
    return;
  }

  // Gravity
  bV.y += GRAV_ACTIVE * dt;

  // Air drag
  bV.x *= BALL_DRAG;
  bV.z *= BALL_DRAG;

  // Update position
  bP.x += bV.x * dt;
  bP.y += bV.y * dt;
  bP.z += bV.z * dt;

  // Floor bounce
  if (bP.y <= BR_ACTIVE) {
    bP.y = BR_ACTIVE;
    bV.y = -bV.y * BOUNCE_ACTIVE;
    bV.x *= BALL_FRIC;
    bV.z *= BALL_FRIC;
    if (Math.abs(bV.y) < 1) bV.y = 0;
  }

  // Ceiling bounce
  if (bP.y >= WH - BR_ACTIVE) {
    bP.y = WH - BR_ACTIVE;
    bV.y = -bV.y * BOUNCE_ACTIVE;
  }

  // Side wall bounce
  if (bP.x <= -FW / 2 + BR_ACTIVE) { bP.x = -FW / 2 + BR_ACTIVE; bV.x = Math.abs(bV.x) * BOUNCE_ACTIVE; }
  if (bP.x >= FW / 2 - BR_ACTIVE) { bP.x = FW / 2 - BR_ACTIVE; bV.x = -Math.abs(bV.x) * BOUNCE_ACTIVE; }

  // End walls (with goal openings)
  // Player's end (z = FL/2)
  if (bP.z >= FL / 2 - BR_ACTIVE) {
    if (Math.abs(bP.x) < GW / 2 && bP.y < GH) {
      // In goal opening — check if fully past goal line
      if (bP.z >= FL / 2 + GD - BR_ACTIVE) {
        bP.z = FL / 2 + GD - BR_ACTIVE;
        bV.z = -Math.abs(bV.z) * BOUNCE_ACTIVE;
      }
      // Check goal scored (past the goal line)
      if (bP.z > FL / 2 + 1 && gameState === 'playing') {
        onGoal('ai');
      }
    } else {
      bP.z = FL / 2 - BR_ACTIVE;
      bV.z = -Math.abs(bV.z) * BOUNCE_ACTIVE;
    }
  }

  // AI's end (z = -FL/2)
  if (bP.z <= -FL / 2 + BR_ACTIVE) {
    if (Math.abs(bP.x) < GW / 2 && bP.y < GH) {
      if (bP.z <= -FL / 2 - GD + BR_ACTIVE) {
        bP.z = -FL / 2 - GD + BR_ACTIVE;
        bV.z = Math.abs(bV.z) * BOUNCE_ACTIVE;
      }
      if (bP.z < -FL / 2 - 1 && gameState === 'playing') {
        onGoal('player');
      }
    } else {
      bP.z = -FL / 2 + BR_ACTIVE;
      bV.z = Math.abs(bV.z) * BOUNCE_ACTIVE;
    }
  }

  // Goal box side walls
  if (bP.z > FL / 2 && bP.z < FL / 2 + GD) {
    if (bP.x < -GW / 2 + BR) { bP.x = -GW / 2 + BR; bV.x = Math.abs(bV.x) * BALL_BOUNCE; }
    if (bP.x > GW / 2 - BR) { bP.x = GW / 2 - BR; bV.x = -Math.abs(bV.x) * BALL_BOUNCE; }
  }
  if (bP.z < -FL / 2 && bP.z > -FL / 2 - GD) {
    if (bP.x < -GW / 2 + BR) { bP.x = -GW / 2 + BR; bV.x = Math.abs(bV.x) * BALL_BOUNCE; }
    if (bP.x > GW / 2 - BR) { bP.x = GW / 2 - BR; bV.x = -Math.abs(bV.x) * BALL_BOUNCE; }
  }

  // Speed clamp
  var bSpd = bV.length();
  if (bSpd > 80) bV.multiplyScalar(80 / bSpd);
}

function clampCar(pos, vel) {
  var hw = CW / 2 + 0.2;
  var hl = CL / 2 + 0.2;
  // Side walls
  if (pos.x < -FW / 2 + hw) { pos.x = -FW / 2 + hw; vel.x = 0; }
  if (pos.x > FW / 2 - hw) { pos.x = FW / 2 - hw; vel.x = 0; }
  // End walls (allow into goal opening)
  if (pos.z > FL / 2 - hl) {
    if (Math.abs(pos.x) >= GW / 2 - hw || pos.y > GH) {
      pos.z = FL / 2 - hl; vel.z = 0;
    } else if (pos.z > FL / 2 + GD - hl) {
      pos.z = FL / 2 + GD - hl; vel.z = 0;
    }
  }
  if (pos.z < -FL / 2 + hl) {
    if (Math.abs(pos.x) >= GW / 2 - hw || pos.y > GH) {
      pos.z = -FL / 2 + hl; vel.z = 0;
    } else if (pos.z < -FL / 2 - GD + hl) {
      pos.z = -FL / 2 - GD + hl; vel.z = 0;
    }
  }
  // Ceiling
  if (pos.y > WH - CH / 2) { pos.y = WH - CH / 2; vel.y = 0; }
}

// ==========================================================================
// COLLISIONS
// ==========================================================================
function checkCarBall(carPos, carVel, carRot, carSpeed) {
  var dx = bP.x - carPos.x;
  var dy = bP.y - carPos.y;
  var dz = bP.z - carPos.z;
  var dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
  var minDist = BR_ACTIVE + Math.max(CW, CL) * 0.55;

  if (dist < minDist && dist > 0.01) {
    // Collision normal
    var nx = dx / dist;
    var ny = dy / dist;
    var nz = dz / dist;

    // Push ball out
    var overlap = minDist - dist;
    bP.x += nx * overlap;
    bP.y += ny * overlap;
    bP.z += nz * overlap;

    // Calculate hit impulse
    var carVelMag = Math.sqrt(carVel.x * carVel.x + carVel.y * carVel.y + carVel.z * carVel.z);
    var dotProduct = (carVel.x * nx + carVel.y * ny + carVel.z * nz);
    var hitStrength = Math.max(dotProduct, carVelMag * 0.3, 5);

    // Apply impulse to ball (scaled by ball speed multiplier)
    var sm = BALL_SPEED_MULT;
    bV.x = (nx * hitStrength * 1.3 + carVel.x * 0.35) * sm;
    bV.y = (ny * hitStrength * 1.3 + Math.abs(carVel.y) * 0.5 + 3) * sm;
    bV.z = (nz * hitStrength * 1.3 + carVel.z * 0.35) * sm;

    // Clamp ball velocity
    var bSpd = bV.length();
    if (bSpd > 70) bV.multiplyScalar(70 / bSpd);

    playHitSound(hitStrength);
    if (hitStrength > 15) triggerScreenShake(Math.min(hitStrength / 40, 0.7));
    return true;
  }
  return false;
}

function checkCarCar() {
  if (pDemoed || aDemoed) return;
  var dx = aP.x - pP.x;
  var dy = aP.y - pP.y;
  var dz = aP.z - pP.z;
  var dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
  var minDist = CL * 0.9;

  if (dist < minDist && dist > 0.01) {
    var nx = dx / dist;
    var ny = dy / dist;
    var nz = dz / dist;
    var overlap = (minDist - dist) / 2;

    // Demolition check — supersonic speed demolishes opponent
    var maxSpd = CAR_BOOST_MAX * CAR_SPEED_MULT;
    var playerSS = Math.abs(pSpeed) > maxSpd * SUPERSONIC_THRESH;
    var aiSS = Math.abs(aSpeed) > maxSpd * AI_MULT * SUPERSONIC_THRESH;

    if (playerSS && !aiSS) {
      triggerDemo(false); // demo the AI
      triggerScreenShake(0.6);
      return;
    } else if (aiSS && !playerSS) {
      triggerDemo(true); // demo the player
      triggerScreenShake(0.6);
      return;
    }
    // Both supersonic or neither — just bump
    pP.x -= nx * overlap;
    pP.z -= nz * overlap;
    aP.x += nx * overlap;
    aP.z += nz * overlap;

    // Exchange some momentum
    var pMom = pSpeed * 0.3;
    var aMom = aSpeed * 0.3;
    pSpeed -= pMom; pSpeed += aMom * 0.2;
    aSpeed -= aMom; aSpeed += pMom * 0.2;

    triggerScreenShake(0.3);
    playHitSound(Math.abs(pSpeed) + Math.abs(aSpeed));
  }
}

// ==========================================================================
// BOOST PAD COLLECTION
// ==========================================================================
function updateBoostPads(dt) {
  boostPads.forEach(function(pad) {
    if (!pad.active) {
      pad.respawnT -= dt;
      if (pad.respawnT <= 0) {
        pad.active = true;
        pad.mesh.visible = true;
      }
      return;
    }

    // Pulse animation — animate children materials
    var pulse = 0.8 + Math.sin(Date.now() * 0.004) * 0.2;
    pad.mesh.children.forEach(function(child) {
      if (child.material && child.material.emissiveIntensity !== undefined) {
        child.material.emissiveIntensity = 0.4 + pulse * 0.4;
      }
    });
    // Float animation for big pad orbs
    if (pad.big) {
      pad.mesh.children.forEach(function(child) {
        if (child.position.y > 1) child.position.y = 2.0 + Math.sin(Date.now() * 0.003) * 0.3;
      });
    }

    // Check player collection
    var pdx = pP.x - pad.x;
    var pdz = pP.z - pad.z;
    if (Math.sqrt(pdx * pdx + pdz * pdz) < pad.r + CW * 0.6 && pP.y < 3) {
      pBoost = pad.big ? BOOST_MAX : Math.min(BOOST_MAX, pBoost + 12);
      pad.active = false;
      pad.mesh.visible = false;
      pad.respawnT = pad.cooldown;
    }

    // Check AI collection
    var adx = aP.x - pad.x;
    var adz = aP.z - pad.z;
    if (Math.sqrt(adx * adx + adz * adz) < pad.r + CW * 0.6 && aP.y < 3) {
      aBoost = pad.big ? BOOST_MAX : Math.min(BOOST_MAX, aBoost + 12);
      pad.active = false;
      pad.mesh.visible = false;
      pad.respawnT = pad.cooldown;
    }
  });
}

// ==========================================================================
// CAMERA
// ==========================================================================
function updateCamera(dt) {
  var forward = new THREE.Vector3(Math.sin(pRot), 0, Math.cos(pRot));
  var idealPos, idealTarget;

  if (ballCam) {
    var toBall = _v1.copy(bP).sub(pP);
    toBall.y = 0;
    toBall.normalize();
    idealPos = _v2.copy(pP).sub(toBall.clone().multiplyScalar(CAM_DIST));
    idealPos.y = pP.y + CAM_HEIGHT;
    idealTarget = _v3.copy(bP);
  } else {
    idealPos = _v2.copy(pP).sub(forward.clone().multiplyScalar(CAM_DIST));
    idealPos.y = pP.y + CAM_HEIGHT;
    idealTarget = _v3.copy(pP).add(forward.clone().multiplyScalar(10));
  }

  // Keep camera in bounds
  idealPos.y = Math.max(idealPos.y, 3);

  var lerpSpeed = ballCam ? 4 : 6;
  cameraPos.lerp(idealPos, lerpSpeed * dt);
  cameraTarget.lerp(idealTarget, lerpSpeed * dt);

  camera.position.copy(cameraPos);
  camera.lookAt(cameraTarget);
}

// ==========================================================================
// SYNC VISUALS
// ==========================================================================
function syncVisuals() {
  ball.position.copy(bP);
  // Ball spin based on velocity
  var bSpd = Math.sqrt(bV.x * bV.x + bV.z * bV.z);
  if (bSpd > 0.5) {
    ball.rotation.x += bV.z * 0.02;
    ball.rotation.z -= bV.x * 0.02;
  }

  playerCar.position.copy(pP);
  playerCar.rotation.y = pRot;
  // Spin animation for dodge
  if (pSpin > 0) {
    playerCar.rotation.x = Math.sin((1 - pSpin / 0.4) * Math.PI * 2) * Math.PI;
  } else {
    playerCar.rotation.x = 0;
  }

  aiCar.position.copy(aP);
  aiCar.rotation.y = aRot;

  // 2v2 extra cars
  if (aiCar2 && aiCar2.visible) {
    aiCar2.position.copy(a2P);
    aiCar2.rotation.y = a2Rot;
  }
  if (aiCar3 && aiCar3.visible) {
    aiCar3.position.copy(a3P);
    aiCar3.rotation.y = a3Rot;
  }

  // Ball glow intensity based on speed
  ballGlow.intensity = 0.5 + bSpd * 0.02;
}

// ==========================================================================
// UI UPDATE
// ==========================================================================
function updateUI() {
  // Boost meter
  var pct = Math.round(pBoost);
  document.getElementById('boost-fill').style.setProperty('--pct', pct + '%');
  document.getElementById('boost-text').textContent = pct;

  // Ball cam indicator
  var bcEl = document.getElementById('ballcam-indicator');
  bcEl.className = ballCam ? 'active' : '';

  // Powerslide indicator
  var psEl = document.getElementById('powerslide-indicator');
  psEl.className = pPowerslide ? 'active' : '';

  // Ball speed display (convert to "km/h" for feel)
  var bSpd = Math.round(bV.length() * 2.5);
  var bsEl = document.getElementById('ball-speed');
  bsEl.textContent = bSpd + ' km/h';
  bsEl.className = bSpd > 150 ? 'super' : (bSpd > 80 ? 'fast' : '');

  // Supersonic indicator
  var ssEl = document.getElementById('supersonic');
  ssEl.className = pSupersonic ? 'active' : '';

  // Speed lines overlay
  var slEl = document.getElementById('speed-lines');
  slEl.className = (pSupersonic || Math.abs(pSpeed) > CAR_MAX * CAR_SPEED_MULT * 0.8) ? 'active' : '';

  // Timer
  updateScoreboard();
}

// ==========================================================================
// INPUT
// ==========================================================================
function setupInput() {
  window.addEventListener('keydown', function(e) {
    // Handle key rebinding first
    if (_rebindingAction) {
      handleRebindKey(e);
      return;
    }

    keys[e.key.toLowerCase()] = true;

    // Ball cam toggle
    if (e.key.toLowerCase() === settings.controls.ballcam) {
      ballCam = !ballCam;
    }

    // Quick chat toggle
    if (e.key.toLowerCase() === settings.controls.quickchat && (gameState === 'playing' || gameState === 'goal')) {
      toggleQuickChat();
    }

    // Escape to menu (or close quick chat)
    if (e.key === 'Escape' && _quickChatOpen) {
      closeQuickChat();
    } else if (e.key === 'Escape' && gameState === 'playing') {
      gameState = 'menu';
      closeQuickChat();
      document.getElementById('menu').style.display = 'flex';
      document.getElementById('hud').style.display = 'none';
      document.getElementById('boost-container').style.display = 'none';
      hideOverlay();
    }

    // Prevent scrolling for game keys
    if ([' ', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].indexOf(e.key) > -1) {
      e.preventDefault();
    }
  });

  window.addEventListener('keyup', function(e) {
    keys[e.key.toLowerCase()] = false;
  });

  // Cancel rebinding when clicking outside a key button
  document.addEventListener('click', function(e) {
    if (_rebindingAction && !e.target.classList.contains('control-key')) {
      cancelRebind();
    }
  });

  document.getElementById('startBtn').addEventListener('click', function() {
    getAudio(); // Init audio on user gesture
    startGame();
  });

  document.getElementById('restartBtn').addEventListener('click', function() {
    getAudio();
    startGame();
  });

  // Settings UI
  document.getElementById('settingsBtn').addEventListener('click', function() {
    settingsToUI();
    document.getElementById('menu').style.display = 'none';
    document.getElementById('settings').style.display = 'flex';
  });

  document.getElementById('settingsBackBtn').addEventListener('click', function() {
    cancelRebind();
    document.getElementById('settings').style.display = 'none';
    document.getElementById('menu').style.display = 'flex';
  });

  document.getElementById('settingsSaveBtn').addEventListener('click', function() {
    cancelRebind();
    uiToSettings();
    saveSettings();
    recalcActiveValues();
    applySettings();
    updateMenuControls();
    document.getElementById('settings').style.display = 'none';
    document.getElementById('menu').style.display = 'flex';
  });

  document.getElementById('settingsResetBtn').addEventListener('click', function() {
    cancelRebind();
    settings = JSON.parse(JSON.stringify(DEFAULTS));
    saveSettings();
    settingsToUI();
    recalcActiveValues();
    applySettings();
    updateMenuControls();
  });

  // Range slider live update displays
  ['s-volume', 's-fov', 's-camdist', 's-camheight'].forEach(function(id) {
    document.getElementById(id).addEventListener('input', updateRangeDisplays);
  });

  // Quick chat buttons
  document.querySelectorAll('.qc-btn').forEach(function(btn) {
    btn.addEventListener('click', function() {
      showChatBubble(btn.getAttribute('data-msg'));
    });
  });
}

// ==========================================================================
// MAIN GAME LOOP
// ==========================================================================
function update() {
  requestAnimationFrame(update);

  var dt = clock.getDelta();
  dt = Math.min(dt, 0.05); // Prevent physics explosions

  if (gameState === 'countdown') {
    countdownT += dt;
    if (countdownT >= 1) {
      countdownT -= 1;
      countdownVal--;
      if (countdownVal > 0) {
        showOverlay(String(countdownVal));
        playCountdownBeep(false);
      } else if (countdownVal === 0) {
        showOverlay('GO!');
        playCountdownBeep(true);
      } else {
        hideOverlay();
        gameState = 'playing';
      }
    }
  }

  if (gameState === 'playing') {
    if (settings.duration > 0) {
      gameTime -= dt;
      if (gameTime <= 0) {
        gameTime = 0;
        if (score[0] === score[1]) {
          showOverlay('OVERTIME!');
          gameState = 'overtime_announce';
          goalT = 0;
        } else {
          endGame();
        }
      }
    } else {
      gameTime += dt; // Count up for unlimited
    }
  }

  if (gameState === 'overtime_announce') {
    goalT += dt;
    if (goalT > 2) {
      hideOverlay();
      gameState = 'playing'; // Sudden death overtime
    }
  }

  if (gameState === 'goal') {
    goalT += dt;
    if (goalT > 2.5) {
      if (score[0] >= WIN_SCORE || score[1] >= WIN_SCORE) {
        // endGame was already scheduled
      } else {
        hideOverlay();
        resetPositions();
        gameState = 'countdown';
        countdownVal = 3;
        countdownT = 0;
        showOverlay(String(countdownVal));
        playCountdownBeep(false);
      }
    }
  }

  // Physics updates
  updatePlayer(dt);
  updateAI(dt);
  updateBall(dt);

  // 2v2 extra AI updates
  if (settings.teams === '2v2') {
    updateExtraAI(dt, a2P, a2V, a2Rot, a2Speed, a2Ground, a2Boost, FL / 2, true);   // orange teammate
    updateExtraAI(dt, a3P, a3V, a3Rot, a3Speed, a3Ground, a3Boost, -FL / 2, false);  // blue enemy
  }

  // Collisions
  if (gameState === 'playing' || gameState === 'overtime_announce') {
    checkCarBall(pP, pV, pRot, pSpeed);
    checkCarBall(aP, aV, aRot, aSpeed);
    checkCarCar();
    if (settings.teams === '2v2') {
      checkCarBall(a2P, a2V, a2Rot, a2Speed);
      checkCarBall(a3P, a3V, a3Rot, a3Speed);
    }
  }

  // Boost pads
  updateBoostPads(dt);

  // Particles
  updateParticles(dt);

  // Ball trail
  updateBallTrail(dt);

  // Demolitions
  updateDemos(dt);

  // Screen shake
  updateScreenShake(dt);

  // Goal flash
  updateGoalFlash(dt);

  // Demo text
  updateDemoText(dt);

  // Quick chat bubble
  updateChatBubble(dt);

  // Sync Three.js visuals
  syncVisuals();

  // Camera
  updateCamera(dt);

  // UI
  updateUI();

  // Render
  renderer.render(scene, camera);
}

// ==========================================================================
// START
// ==========================================================================
init();
cameraPos.set(0, 30, 60);
cameraTarget.set(0, 0, 0);
update();

})();
</script>
</body>
</html>
