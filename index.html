<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Rocket Arena</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { overflow: hidden; background: #000; font-family: 'Segoe UI', system-ui, -apple-system, sans-serif; }
canvas { display: block; }

#hud {
  position: fixed; top: 0; left: 0; right: 0;
  display: flex; justify-content: center; align-items: flex-start;
  pointer-events: none; z-index: 10;
}
#scoreboard {
  background: linear-gradient(180deg, rgba(0,0,0,0.85) 0%, rgba(0,0,0,0.7) 100%);
  border-bottom: 2px solid rgba(255,255,255,0.08);
  padding: 0; display: flex; align-items: stretch; gap: 0;
  border-radius: 0 0 14px 14px; overflow: hidden;
  box-shadow: 0 4px 20px rgba(0,0,0,0.5);
}
.team-score {
  font-size: 52px; font-weight: 900; min-width: 70px; text-align: center;
  padding: 6px 20px;
  text-shadow: 0 0 25px currentColor, 0 0 50px currentColor;
}
.team-orange { color: #ff7b00; background: linear-gradient(180deg, rgba(255,123,0,0.2) 0%, rgba(255,85,0,0.05) 100%); }
.team-blue { color: #00aaff; background: linear-gradient(180deg, rgba(0,170,255,0.2) 0%, rgba(0,100,255,0.05) 100%); }
#timer {
  font-size: 22px; color: #ddd; font-weight: 700;
  font-variant-numeric: tabular-nums; min-width: 70px; text-align: center;
  padding: 10px 16px; background: rgba(0,0,0,0.3);
  border-left: 1px solid rgba(255,255,255,0.06);
  border-right: 1px solid rgba(255,255,255,0.06);
}
#boost-container {
  position: fixed; bottom: 30px; right: 30px;
  width: 80px; height: 80px; z-index: 10; pointer-events: none;
}
#boost-ring {
  width: 80px; height: 80px; border-radius: 50%;
  border: 4px solid rgba(255,255,255,0.15);
  position: relative; display: flex; align-items: center; justify-content: center;
}
@property --pct {
  syntax: '<percentage>';
  inherits: false;
  initial-value: 100%;
}
#boost-fill {
  width: 64px; height: 64px; border-radius: 50%;
  background: conic-gradient(#ff7b00 0%, #ff7b00 var(--pct, 100%), transparent var(--pct, 100%));
  display: flex; align-items: center; justify-content: center;
  transition: --pct 0.1s;
}
#boost-text {
  font-size: 18px; font-weight: 700; color: #fff;
}
#ballcam-indicator {
  position: fixed; bottom: 30px; left: 30px; z-index: 10;
  color: rgba(255,255,255,0.5); font-size: 13px; pointer-events: none;
}
#ballcam-indicator.active { color: #ff7b00; }
#gamemode-hud {
  position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
  z-index: 10; color: #ffcc00; font-size: 14px; font-weight: 700;
  pointer-events: none; letter-spacing: 2px;
  text-shadow: 0 0 10px rgba(255,200,0,0.5);
}

#overlay {
  position: fixed; inset: 0; display: flex; align-items: center; justify-content: center;
  z-index: 20; pointer-events: none;
}
#overlay-text {
  font-size: 72px; font-weight: 900; color: #fff;
  text-shadow: 0 0 40px rgba(255,200,0,0.8), 0 0 80px rgba(255,100,0,0.4);
  opacity: 0; transform: scale(0.5);
  transition: opacity 0.3s, transform 0.3s;
}
#overlay-text.show {
  opacity: 1; transform: scale(1);
}
#overlay-text.goal {
  font-size: 96px;
  animation: goalPulse 0.6s ease-out;
}
@keyframes goalPulse {
  0% { transform: scale(0.3); opacity: 0; }
  50% { transform: scale(1.2); }
  100% { transform: scale(1); opacity: 1; }
}

#menu {
  position: fixed; inset: 0; display: flex; flex-direction: column;
  align-items: center; justify-content: center; z-index: 30;
  background: radial-gradient(ellipse at center, rgba(20,20,40,0.95), rgba(0,0,0,0.98));
}
#menu h1 {
  font-size: 72px; font-weight: 900; margin-bottom: 8px;
  background: linear-gradient(135deg, #ff7b00, #ffaa00, #ff7b00);
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  text-shadow: none; filter: drop-shadow(0 0 30px rgba(255,120,0,0.4));
}
#menu .subtitle {
  color: #888; font-size: 18px; margin-bottom: 40px; letter-spacing: 4px;
}
#menu .start-btn {
  background: linear-gradient(135deg, #ff7b00, #ff5500);
  border: none; color: #fff; font-size: 22px; font-weight: 700;
  padding: 14px 48px; border-radius: 8px; cursor: pointer;
  pointer-events: auto; margin-bottom: 32px;
  transition: transform 0.15s, box-shadow 0.15s;
}
#menu .start-btn:hover {
  transform: scale(1.05); box-shadow: 0 0 30px rgba(255,120,0,0.5);
}
#menu .controls {
  color: #666; font-size: 14px; line-height: 2;
  text-align: center;
}
#menu .controls kbd {
  background: rgba(255,255,255,0.1); padding: 2px 8px;
  border-radius: 4px; border: 1px solid rgba(255,255,255,0.15);
  font-family: inherit; color: #aaa;
}

#game-over {
  position: fixed; inset: 0; display: none; flex-direction: column;
  align-items: center; justify-content: center; z-index: 30;
  background: rgba(0,0,0,0.9);
}
#game-over h2 { font-size: 56px; font-weight: 900; margin-bottom: 8px; }
#game-over .final-score { font-size: 28px; color: #aaa; margin-bottom: 12px; }
#game-over .mvp-badge {
  color: #ffcc00; font-size: 16px; font-weight: 700; letter-spacing: 2px;
  margin-bottom: 16px; text-shadow: 0 0 20px rgba(255,204,0,0.4);
}
#match-stats {
  display: flex; gap: 40px; margin-bottom: 20px; text-align: center;
}
.stats-col { min-width: 100px; }
.stats-col h3 { font-size: 14px; color: #888; font-weight: 600; letter-spacing: 1px; margin-bottom: 8px; }
.stats-col .stat-row { color: #ccc; font-size: 15px; padding: 3px 0; }
.stats-col .stat-row span { color: #fff; font-weight: 700; }
#xp-bar-container {
  width: 300px; margin-bottom: 20px; text-align: center;
}
#xp-label { color: #aaa; font-size: 13px; margin-bottom: 4px; }
#xp-bar {
  width: 100%; height: 8px; background: rgba(255,255,255,0.08);
  border-radius: 4px; overflow: hidden;
}
#xp-bar-fill {
  height: 100%; background: linear-gradient(90deg, #ff7b00, #ffcc00);
  border-radius: 4px; transition: width 1.5s ease-out;
}
#level-display {
  position: fixed; top: 8px; right: 12px; z-index: 10;
  color: rgba(255,255,255,0.3); font-size: 12px; font-weight: 600;
  pointer-events: none;
}
#game-over .start-btn {
  background: linear-gradient(135deg, #ff7b00, #ff5500);
  border: none; color: #fff; font-size: 20px; font-weight: 700;
  padding: 12px 40px; border-radius: 8px; cursor: pointer;
}

/* Settings Panel */
#settings {
  position: fixed; inset: 0; display: none; flex-direction: column;
  align-items: center; justify-content: flex-start; z-index: 35;
  background: radial-gradient(ellipse at center, rgba(20,20,40,0.97), rgba(0,0,0,0.99));
  overflow-y: auto; padding: 30px 20px;
}
#settings h2 {
  font-size: 36px; font-weight: 900; margin-bottom: 24px;
  background: linear-gradient(135deg, #ff7b00, #ffaa00);
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
}
.settings-grid {
  display: grid; grid-template-columns: 1fr 1fr;
  gap: 16px 32px; max-width: 680px; width: 100%; margin-bottom: 28px;
}
@media (max-width: 600px) { .settings-grid { grid-template-columns: 1fr; } }
.setting-group {
  background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.08);
  border-radius: 10px; padding: 14px 16px;
}
.setting-group label {
  display: block; font-size: 11px; font-weight: 700; text-transform: uppercase;
  letter-spacing: 1.5px; color: #888; margin-bottom: 8px;
}
.setting-group select, .setting-group input[type="range"] {
  width: 100%; appearance: none; -webkit-appearance: none;
  background: rgba(255,255,255,0.08); color: #eee;
  border: 1px solid rgba(255,255,255,0.12); border-radius: 6px;
  padding: 8px 12px; font-size: 15px; font-family: inherit; cursor: pointer;
}
.setting-group select option { background: #1a1a2e; color: #eee; }
.setting-group input[type="range"] {
  padding: 0; height: 6px; border-radius: 3px; margin-top: 4px;
}
.setting-group input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none; width: 18px; height: 18px;
  background: #ff7b00; border-radius: 50%; cursor: pointer; border: 2px solid #fff;
}
.setting-group input[type="range"]::-moz-range-thumb {
  width: 18px; height: 18px;
  background: #ff7b00; border-radius: 50%; cursor: pointer; border: 2px solid #fff;
}
.range-val {
  display: inline-block; font-size: 14px; color: #ff7b00;
  font-weight: 700; min-width: 40px; text-align: right; float: right;
  margin-top: -2px;
}
.settings-section-title {
  grid-column: 1 / -1; font-size: 13px; font-weight: 700;
  text-transform: uppercase; letter-spacing: 2px; color: #ff7b00;
  border-bottom: 1px solid rgba(255,120,0,0.2); padding-bottom: 6px;
  margin-top: 4px;
}
.settings-btns {
  display: flex; gap: 12px; margin-bottom: 20px;
}
.settings-btns button {
  border: none; font-size: 18px; font-weight: 700;
  padding: 12px 36px; border-radius: 8px; cursor: pointer;
  transition: transform 0.15s;
}
.settings-btns button:hover { transform: scale(1.04); }
.btn-save {
  background: linear-gradient(135deg, #ff7b00, #ff5500); color: #fff;
}
.btn-back {
  background: rgba(255,255,255,0.1); color: #ccc;
}
.btn-reset-settings {
  background: rgba(255,60,60,0.15); color: #ff6666; font-size: 13px !important;
  padding: 8px 20px !important;
}
#menu .settings-btn, #menu .tutorial-btn {
  background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.12);
  color: #aaa; font-size: 16px; font-weight: 600;
  padding: 10px 32px; border-radius: 8px; cursor: pointer;
  pointer-events: auto; margin-bottom: 12px;
  transition: transform 0.15s, background 0.15s;
}
#menu .settings-btn:hover, #menu .tutorial-btn:hover {
  transform: scale(1.04); background: rgba(255,255,255,0.12); color: #fff;
}
#menu .tutorial-btn {
  border-color: rgba(255,170,0,0.25); color: #cc9944; margin-bottom: 24px;
}
#menu .tutorial-btn:hover {
  border-color: rgba(255,170,0,0.4); color: #ffbb44;
}

/* Tutorial overlay */
#tutorial-hud {
  position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%);
  z-index: 25; pointer-events: none; text-align: center;
}
#tutorial-prompt {
  background: rgba(0,0,0,0.85); border: 1px solid rgba(255,170,0,0.3);
  border-radius: 12px; padding: 16px 28px; max-width: 520px;
  color: #fff; font-size: 18px; font-weight: 600; line-height: 1.5;
  box-shadow: 0 4px 30px rgba(0,0,0,0.5);
}
#tutorial-prompt .step-title {
  color: #ffaa00; font-size: 14px; font-weight: 700; letter-spacing: 2px;
  margin-bottom: 6px; text-transform: uppercase;
}
#tutorial-prompt kbd {
  background: rgba(255,255,255,0.12); padding: 2px 8px; border-radius: 4px;
  border: 1px solid rgba(255,255,255,0.2); font-family: inherit; color: #ffcc66;
}
#tutorial-prompt .progress-dots {
  margin-top: 10px; display: flex; justify-content: center; gap: 6px;
}
#tutorial-prompt .dot {
  width: 8px; height: 8px; border-radius: 50%; background: rgba(255,255,255,0.15);
}
#tutorial-prompt .dot.done { background: #ff7b00; }
#tutorial-prompt .dot.current { background: #ffcc00; box-shadow: 0 0 8px rgba(255,204,0,0.5); }
#tutorial-check {
  color: #44ff44; font-size: 22px; font-weight: 900; margin-top: 8px;
  opacity: 0; transition: opacity 0.3s;
}
#tutorial-check.show { opacity: 1; }

/* Control Binding */
.controls-grid {
  display: flex; flex-direction: column;
  gap: 6px; max-width: 680px; width: 100%; margin-bottom: 20px;
}
.controls-header {
  display: grid; grid-template-columns: 1fr 90px 90px;
  gap: 8px; padding: 0 14px 4px; border-bottom: 1px solid rgba(255,255,255,0.08);
}
.controls-header span {
  font-size: 10px; font-weight: 700; text-transform: uppercase;
  letter-spacing: 1.5px; color: #666; text-align: center;
}
.controls-header span:first-child { text-align: left; }
.control-row {
  display: grid; grid-template-columns: 1fr 90px 90px;
  align-items: center; gap: 8px;
  padding: 6px 14px; background: rgba(255,255,255,0.03); border-radius: 6px;
}
.control-label { color: #aaa; font-size: 13px; }
.control-key, .control-gp {
  background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.15);
  font-size: 13px; font-weight: 700;
  padding: 4px 8px; border-radius: 4px; cursor: pointer;
  min-width: 52px; text-align: center; font-family: inherit;
  transition: background 0.15s, border-color 0.15s;
}
.control-key { color: #ff7b00; }
.control-gp { color: #5bc0de; }
.control-gp.static { cursor: default; opacity: 0.5; }
.control-key:hover { background: rgba(255,120,0,0.15); border-color: rgba(255,120,0,0.4); }
.control-gp:not(.static):hover { background: rgba(91,192,222,0.15); border-color: rgba(91,192,222,0.4); }
.control-key.listening, .control-gp.listening {
  color: #fff; animation: keyPulse 0.8s ease-in-out infinite;
}
.control-key.listening { background: rgba(255,120,0,0.25); border-color: #ff7b00; }
.control-gp.listening { background: rgba(91,192,222,0.25); border-color: #5bc0de; }
@keyframes keyPulse {
  0%, 100% { border-color: inherit; }
  50% { box-shadow: 0 0 12px rgba(255,120,0,0.4); }
}
.controller-status {
  font-size: 11px; color: #666; text-align: center; margin-bottom: 8px;
}
.controller-status.connected { color: #5bc0de; }
.settings-focus {
  outline: 2px solid rgba(255,120,0,0.5) !important; outline-offset: 2px;
}
.menu-focus {
  outline: 2px solid rgba(255,160,0,0.7) !important; outline-offset: 3px;
  transform: scale(1.05);
  transition: transform 0.1s;
}
.garage-focus {
  outline: 2px solid rgba(255,160,0,0.8) !important; outline-offset: 2px;
  transform: scale(1.08);
  transition: transform 0.1s;
}
/* Garage */
#garage {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(5,5,20,0.97); z-index: 200;
  display: flex; flex-direction: column; align-items: center;
  overflow-y: auto; padding: 30px 20px; box-sizing: border-box;
}
.garage-section { margin-bottom: 14px; width: 100%; max-width: 500px; }
.garage-label { color: #aaa; font-size: 11px; letter-spacing: 2px; text-transform: uppercase; margin-bottom: 6px; }
.garage-grid { display: flex; flex-wrap: wrap; gap: 8px; }
.garage-item {
  width: 52px; height: 52px; border-radius: 8px; border: 2px solid rgba(255,255,255,0.15);
  cursor: pointer; display: flex; align-items: center; justify-content: center;
  font-size: 11px; color: #ccc; text-align: center; transition: all 0.15s;
  background: rgba(255,255,255,0.05); position: relative; overflow: hidden;
}
.garage-item:hover { border-color: rgba(255,160,0,0.5); transform: scale(1.08); }
.garage-item.selected { border-color: #ff8800; box-shadow: 0 0 12px rgba(255,136,0,0.4); }
.garage-item.locked { opacity: 0.35; cursor: default; }
.garage-item.locked::after {
  content: 'ðŸ”’'; position: absolute; font-size: 16px; top: 50%; left: 50%;
  transform: translate(-50%, -50%);
}
.garage-item .color-swatch {
  width: 36px; height: 36px; border-radius: 6px;
}

/* Sticky settings buttons */
.settings-footer {
  position: sticky; bottom: 0; background: rgba(10,10,26,0.95);
  padding: 16px 0 8px; display: flex; flex-direction: column;
  align-items: center; gap: 12px; width: 100%;
  border-top: 1px solid rgba(255,255,255,0.06);
}

/* Powerslide indicator */
#powerslide-indicator {
  position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
  z-index: 10; color: rgba(255,255,255,0.4); font-size: 13px;
  pointer-events: none; opacity: 0; transition: opacity 0.15s;
}
#powerslide-indicator.active { opacity: 1; color: #ffaa00; }

/* Quick Chat */
#quick-chat-menu {
  position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%);
  z-index: 25; display: none; pointer-events: none;
}
#quick-chat-menu.open { display: flex; flex-direction: column; gap: 4px; align-items: center; }
.qc-row { display: flex; gap: 4px; }
.qc-btn {
  background: rgba(0,0,0,0.8); border: 1px solid rgba(255,255,255,0.2);
  color: #eee; font-size: 12px; font-weight: 600; padding: 6px 14px;
  border-radius: 6px; pointer-events: auto; cursor: pointer;
  transition: background 0.1s, transform 0.1s; white-space: nowrap;
}
.qc-btn:hover { background: rgba(255,120,0,0.4); transform: scale(1.06); border-color: #ff7b00; }
.qc-label { color: #888; font-size: 10px; text-transform: uppercase; letter-spacing: 1px; }
#chat-bubble {
  position: fixed; top: 20%; left: 50%; transform: translateX(-50%);
  z-index: 22; pointer-events: none;
  font-size: 24px; font-weight: 800; color: #fff;
  text-shadow: 0 0 20px rgba(255,200,0,0.6);
  opacity: 0; transition: opacity 0.3s;
}
#chat-bubble.show { opacity: 1; }

/* Ball speed display */
#ball-speed {
  position: fixed; top: 52px; left: 50%; transform: translateX(-50%);
  z-index: 10; pointer-events: none; font-size: 12px; font-weight: 700;
  color: rgba(255,255,255,0.4); font-variant-numeric: tabular-nums;
  text-align: center; letter-spacing: 1px;
}
#ball-speed.fast { color: #ffaa00; }
#ball-speed.super { color: #ff4400; text-shadow: 0 0 10px rgba(255,68,0,0.5); }

/* Supersonic indicator */
#supersonic {
  position: fixed; bottom: 120px; right: 35px; z-index: 10;
  pointer-events: none; font-size: 11px; font-weight: 800;
  letter-spacing: 2px; color: #9b59b6; opacity: 0;
  transition: opacity 0.2s; text-transform: uppercase;
}
#supersonic.active {
  opacity: 1; color: #e74c3c;
  text-shadow: 0 0 15px rgba(231,76,60,0.6);
  animation: supPulse 0.5s ease-in-out infinite alternate;
}
@keyframes supPulse {
  from { opacity: 0.7; } to { opacity: 1; }
}

/* Speed lines overlay */
#speed-lines {
  position: fixed; inset: 0; z-index: 9; pointer-events: none;
  opacity: 0; transition: opacity 0.3s;
  background: radial-gradient(ellipse at center, transparent 40%, rgba(255,255,255,0.03) 100%);
}
#speed-lines.active {
  opacity: 1;
  background: radial-gradient(ellipse at center, transparent 20%, rgba(255,200,100,0.06) 60%, rgba(255,120,0,0.1) 100%);
}

/* Screen shake */
@keyframes screenShake {
  0% { transform: translate(0,0); }
  25% { transform: translate(-3px, 2px); }
  50% { transform: translate(2px, -3px); }
  75% { transform: translate(-1px, 1px); }
  100% { transform: translate(0,0); }
}
body.shake canvas { animation: screenShake 0.15s ease-out; }

/* Goal flash */
#goal-flash {
  position: fixed; inset: 0; z-index: 19; pointer-events: none;
  opacity: 0; transition: opacity 0.1s;
}
#goal-flash.orange { opacity: 1; background: radial-gradient(ellipse, rgba(255,120,0,0.4) 0%, transparent 70%); }
#goal-flash.blue { opacity: 1; background: radial-gradient(ellipse, rgba(0,100,255,0.4) 0%, transparent 70%); }

/* Demo explosion text */
#demo-text {
  position: fixed; top: 35%; left: 50%; transform: translateX(-50%);
  z-index: 21; pointer-events: none;
  font-size: 36px; font-weight: 900; color: #ff4400;
  text-shadow: 0 0 30px rgba(255,68,0,0.8);
  opacity: 0; transition: opacity 0.2s, transform 0.3s;
}
#demo-text.show { opacity: 1; transform: translateX(-50%) scale(1.2); }

/* Last touch indicator */
#last-touch {
  position: fixed; top: 72px; left: 50%; transform: translateX(-50%);
  z-index: 10; pointer-events: none; font-size: 11px; font-weight: 700;
  color: rgba(255,255,255,0.35); letter-spacing: 1px;
  transition: color 0.2s;
}
#last-touch.orange { color: rgba(255,123,0,0.7); }
#last-touch.blue { color: rgba(0,170,255,0.7); }

/* Goal scorer banner */
#goal-scorer {
  position: fixed; top: 42%; left: 50%; transform: translate(-50%, -50%);
  z-index: 21; pointer-events: none;
  font-size: 28px; font-weight: 800; letter-spacing: 3px;
  opacity: 0; transition: opacity 0.3s;
  text-shadow: 0 0 20px currentColor;
}
#goal-scorer.show { opacity: 1; }

/* Replay badge */
#replay-badge {
  position: fixed; top: 12px; left: 12px; z-index: 22;
  pointer-events: none; font-size: 14px; font-weight: 800;
  color: #ff4444; letter-spacing: 2px; opacity: 0;
  text-shadow: 0 0 10px rgba(255,68,68,0.6);
}
#replay-badge.show { opacity: 1; animation: replayPulse 1s ease-in-out infinite alternate; }
@keyframes replayPulse { from { opacity: 0.6; } to { opacity: 1; } }

/* Skip tutorial button */
#tutorial-skip {
  position: fixed; top: 20px; right: 20px; z-index: 26;
  background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2);
  color: #aaa; font-size: 13px; font-weight: 600; padding: 8px 18px;
  border-radius: 6px; cursor: pointer; pointer-events: auto;
  display: none; transition: background 0.15s;
}
#tutorial-skip:hover { background: rgba(255,255,255,0.2); color: #fff; }

/* Ground contact sparks indicator */
#landing-flash {
  position: fixed; inset: 0; z-index: 8; pointer-events: none;
  opacity: 0; transition: opacity 0.05s;
  background: radial-gradient(ellipse at 50% 80%, rgba(255,255,255,0.06) 0%, transparent 50%);
}
#gamepad-toast {
  position: fixed; top: 60px; left: 50%; transform: translateX(-50%);
  background: rgba(0,0,0,0.85); color: #fff; padding: 8px 20px;
  border-radius: 8px; font-size: 14px; font-weight: 600; z-index: 50;
  border: 1px solid rgba(255,255,255,0.15); pointer-events: none;
  animation: toastFade 2.5s ease-out forwards;
}
@keyframes toastFade {
  0% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
  15% { opacity: 1; transform: translateX(-50%) translateY(0); }
  70% { opacity: 1; }
  100% { opacity: 0; }
}
</style>
</head>
<body>

<div id="hud" style="display:none;">
  <div id="scoreboard">
    <span class="team-score team-orange" id="scoreOrange">0</span>
    <span id="timer">5:00</span>
    <span class="team-score team-blue" id="scoreBlue">0</span>
  </div>
</div>

<div id="boost-container" style="display:none;">
  <div id="boost-ring">
    <div id="boost-fill" style="--pct:100%">
      <span id="boost-text">100</span>
    </div>
  </div>
</div>

<div id="ball-speed" style="display:none;">0 km/h</div>
<div id="supersonic">SUPERSONIC</div>
<div id="speed-lines"></div>
<div id="goal-flash"></div>
<div id="demo-text"></div>
<div id="ballcam-indicator">BALL CAM [C]</div>
<div id="gamemode-hud" style="display:none;"></div>
<div id="powerslide-indicator">DRIFT</div>
<div id="last-touch">LAST TOUCH</div>
<div id="goal-scorer"></div>
<div id="replay-badge">REPLAY</div>
<div id="landing-flash"></div>
<div id="gamepad-toast" style="display:none;"></div>
<button id="tutorial-skip">SKIP TUTORIAL</button>

<div id="overlay"><div id="overlay-text"></div></div>

<div id="quick-chat-menu">
  <div class="qc-label">Quick Chat [T]</div>
  <div class="qc-row">
    <button class="qc-btn" data-msg="Nice shot!">Nice shot!</button>
    <button class="qc-btn" data-msg="Great pass!">Great pass!</button>
    <button class="qc-btn" data-msg="What a save!">What a save!</button>
  </div>
  <div class="qc-row">
    <button class="qc-btn" data-msg="Close one!">Close one!</button>
    <button class="qc-btn" data-msg="OMG!">OMG!</button>
    <button class="qc-btn" data-msg="Wow!">Wow!</button>
  </div>
  <div class="qc-row">
    <button class="qc-btn" data-msg="Thanks!">Thanks!</button>
    <button class="qc-btn" data-msg="No problem.">No problem.</button>
    <button class="qc-btn" data-msg="Sorry!">Sorry!</button>
  </div>
  <div class="qc-row">
    <button class="qc-btn" data-msg="I got it!">I got it!</button>
    <button class="qc-btn" data-msg="Need boost!">Need boost!</button>
    <button class="qc-btn" data-msg="Defending...">Defending...</button>
  </div>
</div>
<div id="chat-bubble"></div>

<div id="menu">
  <h1>ROCKET ARENA</h1>
  <div class="subtitle">CAR SOCCER</div>
  <button class="start-btn" id="startBtn">PLAY</button>
  <button class="tutorial-btn" id="tutorialBtn">TUTORIAL</button>
  <button class="settings-btn" id="garageBtn">GARAGE</button>
  <button class="settings-btn" id="settingsBtn">SETTINGS</button>
  <div class="controls" id="menu-controls"></div>
</div>

<div id="garage" style="display:none;">
  <h2 style="color:#ff8800;font-size:28px;letter-spacing:3px;margin-bottom:16px;">GARAGE</h2>
  <div class="garage-section">
    <div class="garage-label">CAR BODY</div>
    <div class="garage-grid" id="garage-bodies"></div>
  </div>
  <div class="garage-section">
    <div class="garage-label">PRIMARY COLOR</div>
    <div class="garage-grid" id="garage-colors"></div>
  </div>
  <div class="garage-section">
    <div class="garage-label">ACCENT COLOR</div>
    <div class="garage-grid" id="garage-accents"></div>
  </div>
  <div class="garage-section">
    <div class="garage-label">BOOST TRAIL</div>
    <div class="garage-grid" id="garage-boosts"></div>
  </div>
  <div class="garage-section">
    <div class="garage-label">TOPPER</div>
    <div class="garage-grid" id="garage-toppers"></div>
  </div>
  <div style="margin-top:16px;">
    <button class="btn-save" id="garageBackBtn">BACK</button>
  </div>
</div>

<div id="tutorial-hud" style="display:none;">
  <div id="tutorial-prompt">
    <div class="step-title" id="tutorial-step-title">STEP 1</div>
    <div id="tutorial-text">Use <kbd>W</kbd> to drive forward</div>
    <div id="tutorial-check">NICE!</div>
    <div class="progress-dots" id="tutorial-dots"></div>
  </div>
</div>

<div id="settings">
  <h2>SETTINGS</h2>
  <div class="settings-grid">

    <div class="settings-section-title">Game</div>

    <div class="setting-group">
      <label>Game Duration</label>
      <select id="s-duration">
        <option value="60">1 Minute</option>
        <option value="180">3 Minutes</option>
        <option value="300" selected>5 Minutes (Default)</option>
        <option value="600">10 Minutes</option>
        <option value="0">Unlimited</option>
      </select>
    </div>

    <div class="setting-group">
      <label>Score to Win</label>
      <select id="s-winscore">
        <option value="3">3 Goals</option>
        <option value="5">5 Goals</option>
        <option value="7">7 Goals</option>
        <option value="10">10 Goals</option>
        <option value="0" selected>Unlimited (Default)</option>
      </select>
    </div>

    <div class="setting-group">
      <label>AI Difficulty</label>
      <select id="s-ai">
        <option value="0" selected>Easy (Default)</option>
        <option value="1">Medium</option>
        <option value="2">Hard</option>
        <option value="3">Unfair</option>
      </select>
    </div>

    <div class="setting-group">
      <label>Teams</label>
      <select id="s-teams">
        <option value="1v1" selected>1v1 (Default)</option>
        <option value="2v2">2v2</option>
        <option value="3v3">3v3</option>
      </select>
    </div>

    <div class="setting-group">
      <label>Stadium</label>
      <select id="s-stadium">
        <option value="standard" selected>Standard (Default)</option>
        <option value="small">Small Arena</option>
        <option value="large">Grand Stadium</option>
        <option value="wide">Wide Field</option>
        <option value="neon">Neon Arena</option>
        <option value="night">Night Match</option>
      </select>
    </div>

    <div class="setting-group">
      <label>Game Mode</label>
      <select id="s-gamemode">
        <option value="standard" selected>Standard (Default)</option>
        <option value="heatseeker">Heatseeker</option>
        <option value="snowday">Snow Day</option>
        <option value="hoops">Hoops</option>
        <option value="rumble">Rumble</option>
        <option value="dropshot">Dropshot</option>
      </select>
    </div>

    <div class="settings-section-title">Physics</div>

    <div class="setting-group">
      <label>Ball Speed</label>
      <select id="s-ballspeed">
        <option value="0.6">Slow</option>
        <option value="1" selected>Normal (Default)</option>
        <option value="1.5">Fast</option>
        <option value="2.5">Insane</option>
      </select>
    </div>

    <div class="setting-group">
      <label>Gravity</label>
      <select id="s-gravity">
        <option value="0.25">Moon</option>
        <option value="0.6">Low</option>
        <option value="1" selected>Normal (Default)</option>
        <option value="1.6">High</option>
      </select>
    </div>

    <div class="setting-group">
      <label>Ball Size</label>
      <select id="s-ballsize">
        <option value="0.6">Small</option>
        <option value="1" selected>Normal (Default)</option>
        <option value="1.6">Large</option>
        <option value="2.5">Giant</option>
      </select>
    </div>

    <div class="setting-group">
      <label>Boost Mode</label>
      <select id="s-boost">
        <option value="0">No Boost</option>
        <option value="1" selected>Normal (Default)</option>
        <option value="2">Unlimited</option>
        <option value="3">Recharging</option>
      </select>
    </div>

    <div class="setting-group">
      <label>Car Color</label>
      <input type="color" id="s-carcolor" value="#ff6600" style="width:60px;height:30px;border:none;cursor:pointer;background:transparent;">
    </div>

    <div class="setting-group">
      <label>Car Speed</label>
      <select id="s-carspeed">
        <option value="0.6">Slow</option>
        <option value="1" selected>Normal (Default)</option>
        <option value="1.4">Fast</option>
        <option value="2">Turbo</option>
      </select>
    </div>

    <div class="setting-group">
      <label>Bounce</label>
      <select id="s-bounce">
        <option value="0.35">Low</option>
        <option value="0.65" selected>Normal (Default)</option>
        <option value="0.9">High</option>
        <option value="1.05">Super</option>
      </select>
    </div>

    <div class="settings-section-title">Audio & Camera</div>

    <div class="setting-group">
      <label>Sound Volume <span class="range-val" id="s-vol-val">80%</span></label>
      <input type="range" id="s-volume" min="0" max="100" value="80">
    </div>

    <div class="setting-group">
      <label>Camera FOV <span class="range-val" id="s-fov-val">100</span></label>
      <input type="range" id="s-fov" min="45" max="120" value="100">
    </div>

    <div class="setting-group">
      <label>Camera Distance <span class="range-val" id="s-camdist-val">18</span></label>
      <input type="range" id="s-camdist" min="8" max="32" value="18">
    </div>

    <div class="setting-group">
      <label>Camera Height <span class="range-val" id="s-camheight-val">9</span></label>
      <input type="range" id="s-camheight" min="2" max="20" value="9">
    </div>

    <div class="setting-group">
      <label>Camera Angle <span class="range-val" id="s-camangle-val">-3</span></label>
      <input type="range" id="s-camangle" min="-15" max="0" step="1" value="-3">
    </div>

    <div class="setting-group">
      <label>Camera Stiffness <span class="range-val" id="s-camstiff-val">0.5</span></label>
      <input type="range" id="s-camstiff" min="0" max="1" step="0.05" value="0.5">
    </div>

    <div class="setting-group">
      <label>Camera Swivel Speed <span class="range-val" id="s-camswivel-val">5</span></label>
      <input type="range" id="s-camswivel" min="1" max="10" step="0.5" value="5">
    </div>

    <div class="setting-group">
      <label>Camera Transition <span class="range-val" id="s-camtransition-val">1.2</span></label>
      <input type="range" id="s-camtransition" min="0.5" max="2" step="0.1" value="1.2">
    </div>

  </div>

  <div class="settings-section-title" style="margin-top: 8px;">Controller</div>
  <div class="settings-grid">
    <div class="setting-group">
      <label>Controller Preset</label>
      <select id="s-controller-preset">
        <option value="">Custom</option>
        <option value="xbox">Xbox One / Series</option>
        <option value="playstation">PlayStation DualSense / DS4</option>
        <option value="nintendo">Nintendo Pro Controller</option>
      </select>
    </div>
    <div class="setting-group">
      <label>Deadzone <span class="range-val" id="s-deadzone-val">0.12</span></label>
      <input type="range" id="s-deadzone" min="0" max="0.5" step="0.01" value="0.12">
    </div>
    <div class="setting-group">
      <label>Steering Sensitivity <span class="range-val" id="s-sensitivity-val">1.0</span></label>
      <input type="range" id="s-sensitivity" min="0.5" max="2.0" step="0.1" value="1.0">
    </div>
    <div class="setting-group">
      <label style="display:flex;align-items:center;gap:8px;">Vibration <input type="checkbox" id="s-vibration" checked></label>
    </div>
  </div>

  <div class="settings-section-title" style="margin-top: 8px;">Controls <span style="font-weight:400;font-size:11px;color:#888;text-transform:none;letter-spacing:0;">(click to rebind)</span></div>
  <div class="controller-status" id="controller-status">No Controller Detected</div>
  <div class="controls-grid" id="controls-grid"></div>

  <div class="settings-footer">
    <div class="settings-btns">
      <button class="btn-back" id="settingsBackBtn">BACK</button>
      <button class="btn-save" id="settingsSaveBtn">SAVE & CLOSE</button>
    </div>
    <button class="btn-reset-settings" id="settingsResetBtn">Reset to Defaults</button>
  </div>
</div>

<div id="game-over">
  <h2 id="go-title">GAME OVER</h2>
  <div class="final-score" id="go-score"></div>
  <div class="mvp-badge" id="mvp-badge"></div>
  <div id="match-stats">
    <div class="stats-col">
      <h3>YOU</h3>
      <div class="stat-row">Goals: <span id="stat-p-goals">0</span></div>
      <div class="stat-row">Shots: <span id="stat-p-shots">0</span></div>
      <div class="stat-row">Saves: <span id="stat-p-saves">0</span></div>
      <div class="stat-row">Demos: <span id="stat-p-demos">0</span></div>
    </div>
    <div class="stats-col">
      <h3>BOT</h3>
      <div class="stat-row">Goals: <span id="stat-a-goals">0</span></div>
      <div class="stat-row">Shots: <span id="stat-a-shots">0</span></div>
      <div class="stat-row">Saves: <span id="stat-a-saves">0</span></div>
    </div>
  </div>
  <div id="xp-bar-container">
    <div id="xp-label">LEVEL 1 &mdash; 0 / 100 XP</div>
    <div id="xp-bar"><div id="xp-bar-fill" style="width:0%"></div></div>
  </div>
  <button class="start-btn" id="restartBtn">PLAY AGAIN</button>
  <button class="start-btn" id="menuBtn" style="background:linear-gradient(135deg,#445,#334);margin-top:8px;font-size:16px;padding:10px 30px;">MAIN MENU</button>
</div>
<div id="level-display">LVL 1</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
(function() {
'use strict';

// ==========================================================================
// CONSTANTS
// ==========================================================================
var FW = 96, FL = 120, WH = 24;       // field width, length, wall height (RL: 8192x10240x2044 uu)
var GW = 21, GH = 8, GD = 10;         // goal width, height, depth (RL: 1786x643x880 uu)
var CURVE_R = 5;                       // radius of curved ramps at floor-wall and wall-ceiling junctions (fixed â€” not per-stadium; both geometry and physics read this same constant so they stay consistent)
var CORNER_R = 8;                      // radius of rounded corners where side walls meet end walls (per-stadium â€” updated by applyStadium() from STADIUMS[].cornerR)
var BR = 1.5;                          // ball radius (RL: 91.25 uu â‰ˆ 1.07 at scale, compromise for visibility)
var CW = 2.8, CH = 0.9, CL = 4.0;    // car width, height, length (RL: 84x36x118 uu, scaled up for visibility)
var GRAV = -30;                        // less gravity = more floaty like RL
var BALL_BOUNCE = 0.7, BALL_FRIC = 0.988, BALL_DRAG = 0.9994;
var CAR_ACCEL = 34, CAR_BRAKE = 36, CAR_MAX = 40, CAR_THROTTLE_MAX = 37, CAR_BOOST_MAX = 60;
var CAR_TURN = 2.6, CAR_FRIC = 0.978, CAR_AIR_FRIC = 0.998;
var AIR_PITCH_ACC = 12.46, AIR_YAW_ACC = 9.11, AIR_ROLL_ACC = 38.34; // aerial angular accel (rad/sÂ²)
var AIR_ANG_MAX = 5.5, AIR_DAMP = 15, AIR_ROLL_DAMP = 14;            // max ang vel + damping (rad/sÂ²)
var JUMP_V = 17, DODGE_V = 23;
var BOOST_MAX = 100, BOOST_USE = 30;   // slightly less boost consumption
var GAME_DURATION = 300;
var WIN_SCORE = 7;

// ==========================================================================
// SETTINGS SYSTEM
// ==========================================================================
var settings = {
  duration: 300, winScore: 0, ai: 0, teams: '1v1', stadium: 'standard', gameMode: 'standard',
  ballSpeed: 1, gravity: 1, ballSize: 1, boost: 1,
  carSpeed: 1, bounce: 0.65, carColor: '#ff6600',
  volume: 80, fov: 110, camDist: 18, camHeight: 9, camAngle: -3, camStiffness: 0.5, camSwivel: 5, camTransition: 1.2,
  deadzone: 0.12, steeringSensitivity: 1.0, vibration: true,
  controls: {
    forward: 'w', backward: 's', left: 'a', right: 'd',
    jump: ' ', boost: 'shift', ballcam: 'c', reset: 'r',
    powerslide: 'q', quickchat: 't',
    airRollLeft: '', airRollRight: ''
  },
  gamepadControls: {
    jump: 'buttonA', boost: 'buttonB', powerslide: 'buttonX',
    ballcam: 'buttonY', quickchat: 'bumperR', reset: 'bumperL',
    airRollLeft: '', airRollRight: ''
  }
};
var DEFAULTS = JSON.parse(JSON.stringify(settings));

// Control action labels for the UI
var CONTROL_LABELS = {
  forward: 'Forward', backward: 'Backward', left: 'Turn Left', right: 'Turn Right',
  jump: 'Jump / Dodge', boost: 'Boost', ballcam: 'Ball Cam', reset: 'Reset Car',
  powerslide: 'Powerslide', quickchat: 'Quick Chat',
  airRollLeft: 'Air Roll Left', airRollRight: 'Air Roll Right'
};

// Pretty display names for keys
function keyDisplayName(k) {
  if (!k) return 'None';
  if (k === ' ') return 'Space';
  if (k === 'shift') return 'Shift';
  if (k === 'control') return 'Ctrl';
  if (k === 'alt') return 'Alt';
  if (k === 'escape') return 'Esc';
  if (k === 'arrowup') return '\u2191';
  if (k === 'arrowdown') return '\u2193';
  if (k === 'arrowleft') return '\u2190';
  if (k === 'arrowright') return '\u2192';
  if (k === 'tab') return 'Tab';
  if (k === 'enter') return 'Enter';
  if (k === 'backspace') return 'Bksp';
  return k.toUpperCase();
}

// Check if a control action is currently pressed
function isControl(action) {
  var key = settings.controls[action];
  if (key && keys[key]) return true;
  // Arrow keys always work as secondary movement controls
  if (action === 'forward' && keys['arrowup']) return true;
  if (action === 'backward' && keys['arrowdown']) return true;
  if (action === 'left' && keys['arrowleft']) return true;
  if (action === 'right' && keys['arrowright']) return true;
  // Both shift keys for boost
  if (action === 'boost' && (keys['shiftleft'] || keys['shiftright'])) return true;
  // Gamepad support â€” analog axes handled separately by getAnalogThrottle/getAnalogSteer
  // isControl for movement is only used for binary checks (air control, dodge direction)
  if (gamepad.connected) {
    if (action === 'forward' && (gamepad.rightTrigger > 0.15 || gamepad.leftStickY < -0.3)) return true;
    if (action === 'backward' && (gamepad.leftTrigger > 0.15 || gamepad.leftStickY > 0.3)) return true;
    if (action === 'left' && gamepad.leftStickX < -0.25) return true;
    if (action === 'right' && gamepad.leftStickX > 0.25) return true;
    var gpBinding = settings.gamepadControls[action];
    if (gpBinding) {
      var prevKey = '_prev' + gpBinding.charAt(0).toUpperCase() + gpBinding.slice(1);
      if (action === 'jump') {
        // Edge-triggered: only fire on press, not hold
        if (gamepad[gpBinding] && !gamepad[prevKey]) return true;
      } else {
        if (gamepad[gpBinding]) return true;
      }
    }
  }
  return false;
}

// Gamepad analog values for smoother control
function getAnalogSteer() {
  if (!gamepad.connected) return 0;
  var raw = gamepad.leftStickX;
  if (raw === 0) return 0;
  var dz = settings.deadzone || 0.12;
  var sign = raw > 0 ? -1 : 1; // invert: stick right = steer right (decrease pRot)
  // Re-normalize to [0,1] over usable range after deadzone, then apply quadratic curve
  var mag = (Math.abs(raw) - dz) / (1 - dz);
  mag = Math.max(0, Math.min(1, mag));
  mag = mag * mag;
  return sign * mag;
}
function getAnalogThrottle() {
  if (!gamepad.connected) return 0;
  // Triggers take priority (most controllers have analog triggers)
  var triggerVal = gamepad.rightTrigger - gamepad.leftTrigger;
  if (Math.abs(triggerVal) > 0.05) return triggerVal;
  // Fall back to left stick Y for controllers without analog triggers
  // Use higher deadzone to avoid accidental input when steering
  if (Math.abs(gamepad.leftStickY) > 0.25) return -gamepad.leftStickY;
  return 0;
}

// Key rebinding state
var _rebindingAction = null;
var _rebindingEl = null;

// Gamepad rebinding state
var _rebindingGpAction = null;
var _rebindingGpEl = null;

function loadSettings() {
  try {
    var saved = JSON.parse(localStorage.getItem('rocketArenaSettings'));
    if (saved) {
      for (var k in saved) {
        if (!settings.hasOwnProperty(k)) continue;
        if (k === 'controls' && typeof saved[k] === 'object') {
          for (var c in saved[k]) {
            if (settings.controls.hasOwnProperty(c)) settings.controls[c] = saved[k][c];
          }
        } else if (k === 'gamepadControls' && typeof saved[k] === 'object') {
          for (var g in saved[k]) {
            if (settings.gamepadControls.hasOwnProperty(g)) settings.gamepadControls[g] = saved[k][g];
          }
        } else {
          settings[k] = saved[k];
        }
      }
    }
  } catch(e) { console.warn('[RocketArena]', e); }
}

function saveSettings() {
  try { localStorage.setItem('rocketArenaSettings', JSON.stringify(settings)); } catch(e) { console.warn('[RocketArena]', e); }
}

function settingsToUI() {
  document.getElementById('s-duration').value = settings.duration;
  document.getElementById('s-winscore').value = settings.winScore;
  document.getElementById('s-ai').value = settings.ai;
  document.getElementById('s-teams').value = settings.teams;
  document.getElementById('s-stadium').value = settings.stadium;
  document.getElementById('s-gamemode').value = settings.gameMode;
  document.getElementById('s-ballspeed').value = settings.ballSpeed;
  document.getElementById('s-gravity').value = settings.gravity;
  document.getElementById('s-ballsize').value = settings.ballSize;
  document.getElementById('s-boost').value = settings.boost;
  document.getElementById('s-carcolor').value = settings.carColor;
  document.getElementById('s-carspeed').value = settings.carSpeed;
  document.getElementById('s-bounce').value = settings.bounce;
  document.getElementById('s-volume').value = settings.volume;
  document.getElementById('s-fov').value = settings.fov;
  document.getElementById('s-camdist').value = settings.camDist;
  document.getElementById('s-camheight').value = settings.camHeight;
  document.getElementById('s-camangle').value = settings.camAngle;
  document.getElementById('s-camstiff').value = settings.camStiffness;
  document.getElementById('s-camswivel').value = settings.camSwivel;
  document.getElementById('s-camtransition').value = settings.camTransition;
  document.getElementById('s-deadzone').value = settings.deadzone;
  document.getElementById('s-sensitivity').value = settings.steeringSensitivity;
  document.getElementById('s-vibration').checked = settings.vibration;
  var presetEl = document.getElementById('s-controller-preset');
  if (presetEl && gamepad.connected && gamepad.type !== 'generic') {
    presetEl.value = gamepad.type;
  }
  updateRangeDisplays();
  buildControlsUI();
}

function uiToSettings() {
  settings.duration = parseInt(document.getElementById('s-duration').value);
  settings.winScore = parseInt(document.getElementById('s-winscore').value);
  settings.ai = parseInt(document.getElementById('s-ai').value);
  settings.teams = document.getElementById('s-teams').value;
  settings.stadium = document.getElementById('s-stadium').value;
  settings.gameMode = document.getElementById('s-gamemode').value;
  settings.ballSpeed = parseFloat(document.getElementById('s-ballspeed').value);
  settings.gravity = parseFloat(document.getElementById('s-gravity').value);
  settings.ballSize = parseFloat(document.getElementById('s-ballsize').value);
  settings.boost = parseInt(document.getElementById('s-boost').value);
  settings.carColor = document.getElementById('s-carcolor').value;
  settings.carSpeed = parseFloat(document.getElementById('s-carspeed').value);
  settings.bounce = parseFloat(document.getElementById('s-bounce').value);
  settings.volume = parseInt(document.getElementById('s-volume').value);
  settings.fov = parseInt(document.getElementById('s-fov').value);
  settings.camDist = parseInt(document.getElementById('s-camdist').value);
  settings.camHeight = parseInt(document.getElementById('s-camheight').value);
  settings.camAngle = parseInt(document.getElementById('s-camangle').value);
  settings.camStiffness = parseFloat(document.getElementById('s-camstiff').value);
  settings.camSwivel = parseFloat(document.getElementById('s-camswivel').value);
  settings.camTransition = parseFloat(document.getElementById('s-camtransition').value);
  settings.deadzone = parseFloat(document.getElementById('s-deadzone').value);
  settings.steeringSensitivity = parseFloat(document.getElementById('s-sensitivity').value);
  settings.vibration = document.getElementById('s-vibration').checked;
  // Controls are updated live via rebinding UI, no need to read from DOM
}

var GAMEPAD_ANALOG_ACTIONS = { forward: 'RT / Stick', backward: 'LT / Stick', left: 'Stick', right: 'Stick' };

function buildControlsUI() {
  var grid = document.getElementById('controls-grid');
  grid.innerHTML = '';
  // Update controller status
  var statusEl = document.getElementById('controller-status');
  if (statusEl) {
    if (gamepad.connected) {
      statusEl.textContent = controllerTypeName(gamepad.type) + ' Connected';
      statusEl.className = 'controller-status connected';
    } else {
      statusEl.textContent = 'No Controller Detected';
      statusEl.className = 'controller-status';
    }
  }
  // Header row
  var header = document.createElement('div');
  header.className = 'controls-header';
  header.innerHTML = '<span>Action</span><span>Keyboard</span><span>Controller</span>';
  grid.appendChild(header);
  var actions = ['forward', 'backward', 'left', 'right', 'jump', 'boost', 'powerslide', 'ballcam', 'quickchat', 'reset', 'airRollLeft', 'airRollRight'];
  actions.forEach(function(action) {
    var row = document.createElement('div');
    row.className = 'control-row';
    var label = document.createElement('span');
    label.className = 'control-label';
    label.textContent = CONTROL_LABELS[action];
    var keyBtn = document.createElement('button');
    keyBtn.className = 'control-key';
    keyBtn.textContent = keyDisplayName(settings.controls[action]);
    keyBtn.setAttribute('data-action', action);
    keyBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      startRebind(action, keyBtn);
    });
    // Gamepad column
    var gpBtn = document.createElement('button');
    var isAnalog = GAMEPAD_ANALOG_ACTIONS.hasOwnProperty(action);
    if (isAnalog) {
      gpBtn.className = 'control-gp static';
      gpBtn.textContent = GAMEPAD_ANALOG_ACTIONS[action];
    } else {
      gpBtn.className = 'control-gp';
      gpBtn.textContent = gamepadButtonName(settings.gamepadControls[action]);
      gpBtn.setAttribute('data-gp-action', action);
      gpBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        startGamepadRebind(action, gpBtn);
      });
    }
    row.appendChild(label);
    row.appendChild(keyBtn);
    row.appendChild(gpBtn);
    grid.appendChild(row);
  });
}

function startRebind(action, el) {
  cancelRebind();
  cancelGamepadRebind();
  _rebindingAction = action;
  _rebindingEl = el;
  el.classList.add('listening');
  el.textContent = '...';
}

function cancelRebind() {
  if (_rebindingAction && _rebindingEl) {
    _rebindingEl.classList.remove('listening');
    _rebindingEl.textContent = keyDisplayName(settings.controls[_rebindingAction]);
  }
  _rebindingAction = null;
  _rebindingEl = null;
}

function handleRebindKey(e) {
  if (!_rebindingAction) return false;
  var key = e.key.toLowerCase();
  if (key === 'escape') {
    cancelRebind();
    e.preventDefault();
    e.stopPropagation();
    return true;
  }
  if (key === 'f5' || key === 'f11' || key === 'f12') return true;
  settings.controls[_rebindingAction] = key;
  _rebindingEl.classList.remove('listening');
  _rebindingEl.textContent = keyDisplayName(key);
  var _reboundAction = _rebindingAction;
  _rebindingAction = null;
  _rebindingEl = null;
  saveSettings();
  updateMenuControls();
  // Sync ball cam HUD indicator only if that binding changed
  if (_reboundAction === 'ballcam') {
    var _bcEl = document.getElementById('ballcam-indicator');
    if (_bcEl) _bcEl.textContent = 'BALL CAM [' + keyDisplayName(settings.controls.ballcam).toUpperCase() + ']';
  }
  e.preventDefault();
  e.stopPropagation();
  return true;
}

function startGamepadRebind(action, el) {
  cancelRebind();
  cancelGamepadRebind();
  _rebindingGpAction = action;
  _rebindingGpEl = el;
  el.classList.add('listening');
  el.textContent = '...';
}

function cancelGamepadRebind() {
  if (_rebindingGpAction && _rebindingGpEl) {
    _rebindingGpEl.classList.remove('listening');
    _rebindingGpEl.textContent = gamepadButtonName(settings.gamepadControls[_rebindingGpAction]);
  }
  _rebindingGpAction = null;
  _rebindingGpEl = null;
}

function pollGamepadRebind() {
  if (!_rebindingGpAction || !gamepad.connected) return;
  // Check face buttons and bumpers for a newly pressed button
  var buttons = ['buttonA', 'buttonB', 'buttonX', 'buttonY', 'bumperL', 'bumperR'];
  for (var i = 0; i < buttons.length; i++) {
    if (gamepad[buttons[i]] && !gamepad['_prev' + buttons[i].charAt(0).toUpperCase() + buttons[i].slice(1)]) {
      settings.gamepadControls[_rebindingGpAction] = buttons[i];
      _rebindingGpEl.classList.remove('listening');
      _rebindingGpEl.textContent = gamepadButtonName(buttons[i]);
      _rebindingGpAction = null;
      _rebindingGpEl = null;
      saveSettings();
      updateMenuControls();
      return;
    }
  }
}

// Settings navigation with controller
var _settingsFocusIdx = -1;

function getSettingsFocusables() {
  var panel = document.getElementById('settings');
  if (!panel || panel.style.display === 'none') return [];
  var items = [];
  // Collect all interactive elements in the settings panel
  var groups = panel.querySelectorAll('.setting-group');
  for (var i = 0; i < groups.length; i++) items.push(groups[i]);
  // Control rows (each row is a focusable item)
  var crows = panel.querySelectorAll('.control-row');
  for (var j = 0; j < crows.length; j++) items.push(crows[j]);
  // Footer buttons
  var btns = panel.querySelectorAll('.settings-footer button');
  for (var k = 0; k < btns.length; k++) items.push(btns[k]);
  return items;
}

function updateSettingsFocus(items) {
  // Remove old focus
  var old = document.querySelector('.settings-focus');
  if (old) old.classList.remove('settings-focus');
  if (_settingsFocusIdx < 0 || _settingsFocusIdx >= items.length) return;
  var el = items[_settingsFocusIdx];
  el.classList.add('settings-focus');
  el.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
}

function pollSettingsNav() {
  if (!gamepad.connected) return;
  var panel = document.getElementById('settings');
  if (!panel || panel.style.display === 'none') return;
  // Skip if rebinding
  if (_rebindingGpAction || _rebindingAction) return;
  var items = getSettingsFocusables();
  if (!items.length) return;

  // D-pad up/down (edge-triggered)
  var moved = false;
  if (gamepad.dpadDown && !gamepad._prevDpadDown) {
    _settingsFocusIdx = Math.min(_settingsFocusIdx + 1, items.length - 1);
    moved = true;
  }
  if (gamepad.dpadUp && !gamepad._prevDpadUp) {
    _settingsFocusIdx = Math.max(_settingsFocusIdx - 1, 0);
    moved = true;
  }
  // Left stick as fallback (with repeat prevention)
  if (!moved && !gamepad._settingsStickMoved) {
    if (gamepad.leftStickY > 0.5) {
      _settingsFocusIdx = Math.min(_settingsFocusIdx + 1, items.length - 1);
      gamepad._settingsStickMoved = true;
      moved = true;
    } else if (gamepad.leftStickY < -0.5) {
      _settingsFocusIdx = Math.max(_settingsFocusIdx - 1, 0);
      gamepad._settingsStickMoved = true;
      moved = true;
    }
  }
  if (Math.abs(gamepad.leftStickY) < 0.3) gamepad._settingsStickMoved = false;

  if (moved) updateSettingsFocus(items);

  // A button = activate focused element
  if (gamepad.buttonA && !gamepad._prevButtonA && _settingsFocusIdx >= 0 && _settingsFocusIdx < items.length) {
    var focused = items[_settingsFocusIdx];
    // For setting-groups, focus the input/select inside
    var checkbox = focused.querySelector('input[type="checkbox"]');
    if (checkbox) {
      checkbox.checked = !checkbox.checked;
      checkbox.dispatchEvent(new Event('change'));
    } else {
      var input = focused.querySelector('select, input[type="range"]');
      if (input) {
        input.focus();
      } else if (focused.classList.contains('control-row')) {
        // Click the gamepad button if present, else keyboard button
        var gpBtn = focused.querySelector('.control-gp:not(.static)');
        var kbBtn = focused.querySelector('.control-key');
        if (gpBtn) gpBtn.click();
        else if (kbBtn) kbBtn.click();
      } else {
        focused.click();
      }
    }
  }

  // D-pad left/right for sliders and selects
  if (_settingsFocusIdx >= 0 && _settingsFocusIdx < items.length) {
    var focused2 = items[_settingsFocusIdx];
    var slider = focused2.querySelector('input[type="range"]');
    var select = focused2.querySelector('select');
    if (slider) {
      if (gamepad.dpadRight && !gamepad._prevDpadRight) {
        slider.value = Math.min(Number(slider.value) + Number(slider.step || 1), Number(slider.max));
        slider.dispatchEvent(new Event('input'));
      }
      if (gamepad.dpadLeft && !gamepad._prevDpadLeft) {
        slider.value = Math.max(Number(slider.value) - Number(slider.step || 1), Number(slider.min));
        slider.dispatchEvent(new Event('input'));
      }
    }
    if (select) {
      if (gamepad.dpadRight && !gamepad._prevDpadRight) {
        select.selectedIndex = Math.min(select.selectedIndex + 1, select.options.length - 1);
        select.dispatchEvent(new Event('change'));
      }
      if (gamepad.dpadLeft && !gamepad._prevDpadLeft) {
        select.selectedIndex = Math.max(select.selectedIndex - 1, 0);
        select.dispatchEvent(new Event('change'));
      }
    }
  }

  // B button = Back
  if (gamepad.buttonB && !gamepad._prevButtonB) {
    var saveBtn = document.getElementById('settingsSaveBtn');
    if (saveBtn) saveBtn.click();
  }
}

// Controller navigation for main menu and game-over screen
var _menuFocusIdx = -1;

function getMenuFocusables() {
  // Get visible buttons in whichever screen is showing
  var menu = document.getElementById('menu');
  var gameover = document.getElementById('game-over');
  var container = null;
  if (menu && menu.style.display !== 'none') container = menu;
  else if (gameover && gameover.style.display !== 'none') container = gameover;
  if (!container) return [];
  return Array.from(container.querySelectorAll('button')).filter(function(b) {
    return b.offsetParent !== null;
  });
}

function updateMenuFocus(items) {
  var old = document.querySelector('.menu-focus');
  if (old) old.classList.remove('menu-focus');
  if (_menuFocusIdx < 0 || _menuFocusIdx >= items.length) return;
  var el = items[_menuFocusIdx];
  el.classList.add('menu-focus');
  el.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
}

function pollMenuGamepad() {
  if (!gamepad.connected) return;
  // Only when menu or game-over is visible, and settings is NOT open
  var settings_panel = document.getElementById('settings');
  if (settings_panel && settings_panel.style.display !== 'none') return;
  var items = getMenuFocusables();
  if (!items.length) { _menuFocusIdx = -1; return; }

  // Auto-focus first item if none selected
  if (_menuFocusIdx < 0) _menuFocusIdx = 0;
  if (_menuFocusIdx >= items.length) _menuFocusIdx = items.length - 1;

  // D-pad up/down (edge-triggered)
  var moved = false;
  if (gamepad.dpadDown && !gamepad._prevDpadDown) {
    _menuFocusIdx = Math.min(_menuFocusIdx + 1, items.length - 1);
    moved = true;
  }
  if (gamepad.dpadUp && !gamepad._prevDpadUp) {
    _menuFocusIdx = Math.max(_menuFocusIdx - 1, 0);
    moved = true;
  }
  // Left stick as fallback
  if (!moved && !gamepad._menuStickMoved) {
    if (gamepad.leftStickY > 0.5) {
      _menuFocusIdx = Math.min(_menuFocusIdx + 1, items.length - 1);
      gamepad._menuStickMoved = true;
      moved = true;
    } else if (gamepad.leftStickY < -0.5) {
      _menuFocusIdx = Math.max(_menuFocusIdx - 1, 0);
      gamepad._menuStickMoved = true;
      moved = true;
    }
  }
  if (Math.abs(gamepad.leftStickY) < 0.3) gamepad._menuStickMoved = false;

  if (moved) updateMenuFocus(items);

  // A button = click focused button
  if (gamepad.buttonA && !gamepad._prevButtonA && _menuFocusIdx >= 0 && _menuFocusIdx < items.length) {
    items[_menuFocusIdx].click();
  }

  // Maintain focus highlight
  if (!moved && _menuFocusIdx >= 0) updateMenuFocus(items);
}

// Controller navigation for garage screen
var _garageFocusIdx = -1;

function getGarageFocusables() {
  var panel = document.getElementById('garage');
  if (!panel || panel.style.display === 'none') return [];
  // Get all garage items and buttons
  var items = Array.from(panel.querySelectorAll('.garage-item, button'));
  return items.filter(function(el) { return el.offsetParent !== null; });
}

function updateGarageFocus(items) {
  var old = document.querySelector('.garage-focus');
  if (old) old.classList.remove('garage-focus');
  if (_garageFocusIdx < 0 || _garageFocusIdx >= items.length) return;
  var el = items[_garageFocusIdx];
  el.classList.add('garage-focus');
  el.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
}

function pollGarageNav() {
  if (!gamepad.connected) return;
  var panel = document.getElementById('garage');
  if (!panel || panel.style.display === 'none') return;
  var items = getGarageFocusables();
  if (!items.length) { _garageFocusIdx = -1; return; }

  if (_garageFocusIdx < 0) _garageFocusIdx = 0;
  if (_garageFocusIdx >= items.length) _garageFocusIdx = items.length - 1;

  var moved = false;
  // D-pad navigation
  if (gamepad.dpadRight && !gamepad._prevDpadRight) {
    _garageFocusIdx = Math.min(_garageFocusIdx + 1, items.length - 1);
    moved = true;
  }
  if (gamepad.dpadLeft && !gamepad._prevDpadLeft) {
    _garageFocusIdx = Math.max(_garageFocusIdx - 1, 0);
    moved = true;
  }
  if (gamepad.dpadDown && !gamepad._prevDpadDown) {
    // Jump to next section (find next item in a different garage-grid)
    var cur = items[_garageFocusIdx];
    var curGrid = cur.closest('.garage-grid');
    for (var i = _garageFocusIdx + 1; i < items.length; i++) {
      if (items[i].closest('.garage-grid') !== curGrid || items[i].tagName === 'BUTTON') {
        _garageFocusIdx = i; moved = true; break;
      }
    }
    if (!moved) { _garageFocusIdx = items.length - 1; moved = true; }
  }
  if (gamepad.dpadUp && !gamepad._prevDpadUp) {
    var cur2 = items[_garageFocusIdx];
    var curGrid2 = cur2.closest('.garage-grid');
    for (var i = _garageFocusIdx - 1; i >= 0; i--) {
      if (items[i].closest('.garage-grid') !== curGrid2 || items[i].tagName === 'BUTTON') {
        _garageFocusIdx = i; moved = true; break;
      }
    }
    if (!moved) { _garageFocusIdx = 0; moved = true; }
  }
  // Left stick
  if (!moved && !gamepad._garageStickMoved) {
    if (gamepad.leftStickX > 0.5) {
      _garageFocusIdx = Math.min(_garageFocusIdx + 1, items.length - 1);
      gamepad._garageStickMoved = true; moved = true;
    } else if (gamepad.leftStickX < -0.5) {
      _garageFocusIdx = Math.max(_garageFocusIdx - 1, 0);
      gamepad._garageStickMoved = true; moved = true;
    } else if (gamepad.leftStickY > 0.5) {
      var cur3 = items[_garageFocusIdx];
      var cg3 = cur3.closest('.garage-grid');
      var found3 = false;
      for (var i = _garageFocusIdx + 1; i < items.length; i++) {
        if (items[i].closest('.garage-grid') !== cg3 || items[i].tagName === 'BUTTON') {
          _garageFocusIdx = i; found3 = true; break;
        }
      }
      if (!found3) _garageFocusIdx = items.length - 1; // already at last section
      gamepad._garageStickMoved = true; moved = true;
    } else if (gamepad.leftStickY < -0.5) {
      var cur4 = items[_garageFocusIdx];
      var cg4 = cur4.closest('.garage-grid');
      var found4 = false;
      for (var i = _garageFocusIdx - 1; i >= 0; i--) {
        if (items[i].closest('.garage-grid') !== cg4 || items[i].tagName === 'BUTTON') {
          _garageFocusIdx = i; found4 = true; break;
        }
      }
      if (!found4) _garageFocusIdx = 0; // already at first section
      gamepad._garageStickMoved = true; moved = true;
    }
  }
  if (Math.abs(gamepad.leftStickX) < 0.3 && Math.abs(gamepad.leftStickY) < 0.3) gamepad._garageStickMoved = false;

  if (moved) updateGarageFocus(items);

  // A button = select item
  if (gamepad.buttonA && !gamepad._prevButtonA && _garageFocusIdx >= 0 && _garageFocusIdx < items.length) {
    items[_garageFocusIdx].click();
  }

  // B button = Back
  if (gamepad.buttonB && !gamepad._prevButtonB) {
    var backBtn = document.getElementById('garageBackBtn');
    if (backBtn) backBtn.click();
  }

  if (!moved && _garageFocusIdx >= 0) updateGarageFocus(items);
}

function updateMenuControls() {
  var c = settings.controls;
  var gc = settings.gamepadControls;
  var mc = document.getElementById('menu-controls');
  if (!mc) return;
  var html =
    '<kbd>' + keyDisplayName(c.forward) + '</kbd>' +
    '<kbd>' + keyDisplayName(c.left) + '</kbd>' +
    '<kbd>' + keyDisplayName(c.backward) + '</kbd>' +
    '<kbd>' + keyDisplayName(c.right) + '</kbd> Drive &nbsp;&nbsp;' +
    '<kbd>' + keyDisplayName(c.jump) + '</kbd> Jump/Dodge &nbsp;&nbsp;' +
    '<kbd>' + keyDisplayName(c.boost) + '</kbd> Boost<br>' +
    '<kbd>' + keyDisplayName(c.powerslide) + '</kbd> Powerslide &nbsp;&nbsp;' +
    '<kbd>' + keyDisplayName(c.ballcam) + '</kbd> Ball Cam &nbsp;&nbsp;' +
    '<kbd>' + keyDisplayName(c.quickchat) + '</kbd> Quick Chat<br>' +
    '<kbd>' + keyDisplayName(c.reset) + '</kbd> Reset &nbsp;&nbsp;' +
    '<kbd>Esc</kbd> Menu';
  if (gamepad.connected) {
    var gn = function(a) { return gamepadButtonName(gc[a]); };
    html += '<br><span style="color:#5bc0de;font-size:11px;">' +
      'RT/LT Drive &nbsp;&nbsp;' +
      gn('jump') + ' Jump &nbsp;&nbsp;' +
      gn('boost') + ' Boost &nbsp;&nbsp;' +
      gn('powerslide') + ' Powerslide &nbsp;&nbsp;' +
      gn('ballcam') + ' Ball Cam &nbsp;&nbsp;' +
      gn('quickchat') + ' Quick Chat &nbsp;&nbsp;' +
      gn('reset') + ' Reset</span>';
  }
  mc.innerHTML = html;
}

function updateRangeDisplays() {
  document.getElementById('s-vol-val').textContent = document.getElementById('s-volume').value + '%';
  document.getElementById('s-fov-val').textContent = document.getElementById('s-fov').value;
  document.getElementById('s-camdist-val').textContent = document.getElementById('s-camdist').value;
  document.getElementById('s-camheight-val').textContent = document.getElementById('s-camheight').value;
  document.getElementById('s-camangle-val').textContent = document.getElementById('s-camangle').value;
  document.getElementById('s-camstiff-val').textContent = document.getElementById('s-camstiff').value;
  document.getElementById('s-camswivel-val').textContent = document.getElementById('s-camswivel').value;
  document.getElementById('s-camtransition-val').textContent = document.getElementById('s-camtransition').value;
  document.getElementById('s-deadzone-val').textContent = document.getElementById('s-deadzone').value;
  document.getElementById('s-sensitivity-val').textContent = document.getElementById('s-sensitivity').value;
}

// ==========================================================================
// GARAGE SYSTEM
// ==========================================================================
var garage = {
  body: 'octane',
  color: '#ff6600',
  accent: '#ff8800',
  boost: 'standard',
  topper: 'none'
};

var GARAGE_BODIES = [
  { id: 'octane', name: 'Octane', level: 1 },
  { id: 'dominus', name: 'Dominus', level: 1 },
  { id: 'breakout', name: 'Breakout', level: 2 },
  { id: 'merc', name: 'Merc', level: 3 },
  { id: 'hotshot', name: 'Hotshot', level: 5 },
  { id: 'batmobile', name: 'Batcar', level: 8 }
];

var GARAGE_COLORS = [
  '#ff6600', '#ff0000', '#0088ff', '#00cc44', '#ffcc00',
  '#ff00ff', '#00ffcc', '#8844ff', '#ffffff', '#222222',
  '#ff4488', '#44ddff'
];

var GARAGE_ACCENTS = [
  '#ff8800', '#ffcc00', '#ffffff', '#00ccff', '#ff00aa',
  '#44ff44', '#8888ff', '#ff4444', '#cccccc', '#000000'
];

var GARAGE_BOOSTS = [
  { id: 'standard', name: 'Standard', level: 1, color: 0xff6600 },
  { id: 'blue', name: 'Ion Blue', level: 1, color: 0x4488ff },
  { id: 'green', name: 'Toxic', level: 2, color: 0x44ff44 },
  { id: 'pink', name: 'Hearts', level: 3, color: 0xff44aa },
  { id: 'gold', name: 'Gold Rush', level: 5, color: 0xffcc00 },
  { id: 'white', name: 'Alpha', level: 8, color: 0xffffff },
  { id: 'rainbow', name: 'Rainbow', level: 12, color: 0xff00ff }
];

var GARAGE_TOPPERS = [
  { id: 'none', name: 'None', level: 1 },
  { id: 'antenna', name: 'Antenna', level: 1 },
  { id: 'hat', name: 'Top Hat', level: 2 },
  { id: 'crown', name: 'Crown', level: 4 },
  { id: 'halo', name: 'Halo', level: 6 },
  { id: 'mohawk', name: 'Mohawk', level: 8 }
];

function loadGarage() {
  try {
    var saved = JSON.parse(localStorage.getItem('rocketArenaGarage'));
    if (saved) {
      if (saved.body) garage.body = saved.body;
      if (saved.color) garage.color = saved.color;
      if (saved.accent) garage.accent = saved.accent;
      if (saved.boost) garage.boost = saved.boost;
      if (saved.topper) garage.topper = saved.topper;
    }
  } catch(e) { console.warn('[RocketArena]', e); }
  // Validate loaded values against allowed options to guard against corruption
  if (!GARAGE_BODIES.find(function(b) { return b.id === garage.body; })) garage.body = GARAGE_BODIES[0].id;
  if (!GARAGE_COLORS.includes(garage.color)) garage.color = GARAGE_COLORS[0];
  if (!GARAGE_ACCENTS.includes(garage.accent)) garage.accent = GARAGE_ACCENTS[0];
  if (!GARAGE_BOOSTS.find(function(b) { return b.id === garage.boost; })) garage.boost = GARAGE_BOOSTS[0].id;
  if (!GARAGE_TOPPERS.find(function(t) { return t.id === garage.topper; })) garage.topper = GARAGE_TOPPERS[0].id;
}

function saveGarage() {
  try { localStorage.setItem('rocketArenaGarage', JSON.stringify(garage)); } catch(e) { console.warn('[RocketArena]', e); }
}

// Generic garage section builder â€” eliminates repeated forEach patterns
function buildSection(containerId, items, getContent, isSelected, onSelect) {
  var el = document.getElementById(containerId);
  el.innerHTML = '';
  var lvl = playerLevel || 1;
  items.forEach(function(it) {
    var div = document.createElement('div');
    var locked = it.level && lvl < it.level;
    div.className = 'garage-item' + (isSelected(it) ? ' selected' : '') + (locked ? ' locked' : '');
    if (it.name) div.title = locked ? 'Unlocks at Level ' + it.level : it.name;
    getContent(div, it);
    if (!locked) {
      div.addEventListener('click', function() { onSelect(it); saveGarage(); buildGarageUI(); applyGarage(); });
    }
    el.appendChild(div);
  });
}

function buildGarageUI() {
  buildSection('garage-bodies', GARAGE_BODIES,
    function(div, b) { div.textContent = b.name; },
    function(b) { return b.id === garage.body; },
    function(b) { garage.body = b.id; });

  buildSection('garage-colors', GARAGE_COLORS,
    function(div, c) { var s = document.createElement('div'); s.className = 'color-swatch'; s.style.background = c; div.appendChild(s); },
    function(c) { return c === garage.color; },
    function(c) { garage.color = c; settings.carColor = c; });

  buildSection('garage-accents', GARAGE_ACCENTS,
    function(div, c) { var s = document.createElement('div'); s.className = 'color-swatch'; s.style.background = c; div.appendChild(s); },
    function(c) { return c === garage.accent; },
    function(c) { garage.accent = c; });

  buildSection('garage-boosts', GARAGE_BOOSTS,
    function(div, b) { var s = document.createElement('div'); s.className = 'color-swatch'; s.style.background = '#' + b.color.toString(16).padStart(6, '0'); div.appendChild(s); },
    function(b) { return b.id === garage.boost; },
    function(b) { garage.boost = b.id; });

  buildSection('garage-toppers', GARAGE_TOPPERS,
    function(div, t) { div.textContent = t.name; },
    function(t) { return t.id === garage.topper; },
    function(t) { garage.topper = t.id; });
}

var _currentPlayerBody = 'octane';
function applyGarage() {
  if (!playerCar || !scene) return;

  // Rebuild car mesh if body type changed
  if (garage.body !== _currentPlayerBody) {
    var oldPos = playerCar.position.clone();
    var oldQuat = playerCar.quaternion.clone();
    scene.remove(playerCar);
    playerCar = createCar(new THREE.Color(garage.color).getHex(), new THREE.Color(garage.accent).getHex(), garage.body);
    playerCar.position.copy(oldPos);
    playerCar.quaternion.copy(oldQuat);
    scene.add(playerCar);
    _currentPlayerBody = garage.body;
  }

  // Apply colors
  var cc = new THREE.Color(garage.color);
  var ac = new THREE.Color(garage.accent);
  playerCar.traverse(function(child) {
    if (child.isMesh && child.material) {
      if (child.material.color) {
        if (child._isAccent) child.material.color.copy(ac);
        else if (child._isBody) child.material.color.copy(cc);
      }
    }
  });

  // Remove old topper
  var oldTopper = playerCar.getObjectByName('topper');
  if (oldTopper) playerCar.remove(oldTopper);

  // Add topper
  if (garage.topper !== 'none') {
    var topperGroup = new THREE.Group();
    topperGroup.name = 'topper';
    var topMat = new THREE.MeshStandardMaterial({ color: 0xffcc00, metalness: 0.5, roughness: 0.3 });
    if (garage.topper === 'antenna') {
      var pole = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 1.5, 6), new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8 }));
      pole.position.set(CW * 0.3, CH + 0.75, -CL * 0.1);
      topperGroup.add(pole);
      var ball = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), topMat);
      ball.position.set(CW * 0.3, CH + 1.55, -CL * 0.1);
      topperGroup.add(ball);
    } else if (garage.topper === 'hat') {
      var brim = new THREE.Mesh(new THREE.CylinderGeometry(0.55, 0.55, 0.08, 12), new THREE.MeshStandardMaterial({ color: 0x111111 }));
      brim.position.set(0, CH + 0.05, 0);
      topperGroup.add(brim);
      var top = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.4, 0.6, 12), new THREE.MeshStandardMaterial({ color: 0x111111 }));
      top.position.set(0, CH + 0.38, 0);
      topperGroup.add(top);
    } else if (garage.topper === 'crown') {
      var crown = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.4, 0.3, 8), topMat);
      crown.position.set(0, CH + 0.2, 0);
      topperGroup.add(crown);
    } else if (garage.topper === 'halo') {
      var haloGeo = new THREE.TorusGeometry(0.4, 0.06, 8, 24);
      var haloMat = new THREE.MeshStandardMaterial({ color: 0xffff44, emissive: 0xffff00, emissiveIntensity: 0.5 });
      var halo = new THREE.Mesh(haloGeo, haloMat);
      halo.position.set(0, CH + 0.5, 0);
      halo.rotation.x = Math.PI / 2;
      topperGroup.add(halo);
    } else if (garage.topper === 'mohawk') {
      for (var mi = 0; mi < 5; mi++) {
        var spike = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.5, 6), new THREE.MeshStandardMaterial({ color: 0xff0044 }));
        spike.position.set(0, CH + 0.3, -CL * 0.2 + mi * CL * 0.1);
        topperGroup.add(spike);
      }
    }
    playerCar.add(topperGroup);
  }
}

function applySettings() {
  // Apply settings that take effect immediately
  if (camera) {
    camera.fov = settings.fov;
    camera.updateProjectionMatrix();
  }
  // Ball size
  if (ball) {
    var s = settings.ballSize;
    ball.scale.setScalar(s);
    BR_ACTIVE = BR * s;
  }
  // Car color â€” use garage system for consistency
  if (playerCar) {
    applyGarage();
  }
}

// Active runtime values (modified by settings)
var BR_ACTIVE = BR;
var GRAV_ACTIVE = GRAV;
var BOUNCE_ACTIVE = BALL_BOUNCE;
var VOLUME_SCALE = 0.8;
var CAR_SPEED_MULT = 1;
var BALL_SPEED_MULT = 1;
var AI_MULT = 0.88;  // AI speed multiplier
var AI_REACT = 1;     // AI reaction quality
var CAM_DIST = 14;
var CAM_HEIGHT = 7;
var CAM_ANGLE = -3;
var CAM_STIFFNESS = 0.5;
var CAM_SWIVEL = 5;
var CAM_TRANSITION = 1.2;

function recalcActiveValues() {
  BR_ACTIVE = BR * settings.ballSize;
  GRAV_ACTIVE = GRAV * settings.gravity;
  BOUNCE_ACTIVE = settings.bounce;
  VOLUME_SCALE = settings.volume / 100;
  CAR_SPEED_MULT = settings.carSpeed;
  BALL_SPEED_MULT = settings.ballSpeed;
  CAM_DIST = settings.camDist;
  CAM_HEIGHT = settings.camHeight;
  CAM_ANGLE = settings.camAngle;
  CAM_STIFFNESS = settings.camStiffness;
  CAM_SWIVEL = settings.camSwivel;
  CAM_TRANSITION = settings.camTransition;

  // AI difficulty presets
  switch (settings.ai) {
    case 0: AI_MULT = 0.62; AI_REACT = 0.5; break;  // Easy
    case 1: AI_MULT = 0.85; AI_REACT = 1.0; break;   // Medium
    case 2: AI_MULT = 0.96; AI_REACT = 1.4; break;   // Hard
    case 3: AI_MULT = 1.05; AI_REACT = 1.8; break;   // Unfair
    default: AI_MULT = 0.85; AI_REACT = 1.0;
  }
}

// ==========================================================================
// STADIUM SYSTEM
// ==========================================================================
var STADIUMS = {
  standard: { fw: 96,  fl: 120, wh: 24, gw: 21, gh: 8,  gd: 10, cornerR: 8,  floorColor: '#06080e', stripe1: '#080a12', stripe2: '#04060a', fogColor: 0x06080e, ambientColor: 0x404860, wallColor: 0x1c1e24, wallOpacity: 0.9, rampColor: 0x181a20, ceilColor: 0x141618, standColor: 0x1a1a30, crowdColor1: 0xff6600, crowdColor2: 0x0066ff },
  small:    { fw: 68,  fl: 84,  wh: 16, gw: 17, gh: 7,  gd: 8,  cornerR: 6,  floorColor: '#3a9a3a', stripe1: '#3eaa3e', stripe2: '#2e882e', fogColor: 0x101828, ambientColor: 0xc0d0e8, wallColor: 0x556677, wallOpacity: 0.9, rampColor: 0x4a5a6a, standColor: 0x1a1a30, crowdColor1: 0xff6600, crowdColor2: 0x0066ff },
  large:    { fw: 120, fl: 150, wh: 24, gw: 26, gh: 11, gd: 12, cornerR: 10, floorColor: '#3a9a3a', stripe1: '#3eaa3e', stripe2: '#2e882e', fogColor: 0x101828, ambientColor: 0xc0d0e8, wallColor: 0x556677, wallOpacity: 0.9, rampColor: 0x4a5a6a, standColor: 0x1a1a30, crowdColor1: 0xff6600, crowdColor2: 0x0066ff },
  wide:     { fw: 130, fl: 100, wh: 18, gw: 24, gh: 8,  gd: 10, cornerR: 10, floorColor: '#3a9a3a', stripe1: '#3eaa3e', stripe2: '#2e882e', fogColor: 0x101828, ambientColor: 0xc0d0e8, wallColor: 0x556677, wallOpacity: 0.9, rampColor: 0x4a5a6a, standColor: 0x1a1a30, crowdColor1: 0xff6600, crowdColor2: 0x0066ff },
  neon:     { fw: 96,  fl: 120, wh: 24, gw: 21, gh: 8,  gd: 10, cornerR: 8,  floorColor: '#0a0a2e', stripe1: '#0e0e38', stripe2: '#08082a', fogColor: 0x020210, ambientColor: 0x6060ee, wallColor: 0x1a1a44, wallOpacity: 0.9, rampColor: 0x2a2a55, standColor: 0x0a0a20, crowdColor1: 0xff00ff, crowdColor2: 0x00ffff },
  night:    { fw: 96,  fl: 120, wh: 24, gw: 21, gh: 8,  gd: 10, cornerR: 8,  floorColor: '#1a4a1a', stripe1: '#1e561e', stripe2: '#163e16', fogColor: 0x010108, ambientColor: 0x506070, wallColor: 0x3a4a5a, wallOpacity: 0.85, rampColor: 0x3a4a5a, standColor: 0x0f0f1e, crowdColor1: 0xff6600, crowdColor2: 0x0066ff }
};

function applyStadium() {
  var s = STADIUMS[settings.stadium] || STADIUMS.standard;
  FW = s.fw; FL = s.fl; WH = s.wh;
  GW = s.gw; GH = s.gh; GD = s.gd;
  CORNER_R = s.cornerR || 8;
}

// ==========================================================================
// QUICK CHAT SYSTEM
// ==========================================================================
var _quickChatOpen = false;
var _chatBubbleTimer = 0;

function toggleQuickChat() {
  _quickChatOpen = !_quickChatOpen;
  document.getElementById('quick-chat-menu').className = _quickChatOpen ? 'open' : '';
}

function closeQuickChat() {
  _quickChatOpen = false;
  document.getElementById('quick-chat-menu').className = '';
}

function showChatBubble(msg) {
  var el = document.getElementById('chat-bubble');
  el.textContent = msg;
  el.className = 'show';
  _chatBubbleTimer = 2.5;
  closeQuickChat();
  // Play a small chirp
  var ctx = getAudio(); if (!ctx) return;
  var osc = ctx.createOscillator();
  var gain = ctx.createGain();
  osc.connect(gain); gain.connect(ctx.destination);
  osc.type = 'sine';
  osc.frequency.setValueAtTime(800, ctx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(1200, ctx.currentTime + 0.05);
  gain.gain.setValueAtTime(0.1 * VOLUME_SCALE, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.1);
  osc.start(); osc.stop(ctx.currentTime + 0.1);
}

function updateChatBubble(dt) {
  if (_chatBubbleTimer > 0) {
    _chatBubbleTimer -= dt;
    if (_chatBubbleTimer <= 0) {
      document.getElementById('chat-bubble').className = '';
    }
  }
}

// Extra AI cars for 2v2 and 3v3
var aiCar2 = null, aiCar3 = null, aiCar4 = null, aiCar5 = null;
var a2P = new THREE.Vector3(), a2V = new THREE.Vector3(), a2Rot = 0, a2Speed = 0, a2Ground = true, a2Boost = BOOST_MAX;
var a3P = new THREE.Vector3(), a3V = new THREE.Vector3(), a3Rot = Math.PI, a3Speed = 0, a3Ground = true, a3Boost = BOOST_MAX;
var a4P = new THREE.Vector3(), a4V = new THREE.Vector3(), a4Rot = 0, a4Speed = 0, a4Ground = true, a4Boost = BOOST_MAX;
var a5P = new THREE.Vector3(), a5V = new THREE.Vector3(), a5Rot = Math.PI, a5Speed = 0, a5Ground = true, a5Boost = BOOST_MAX;

// Reusable temp vectors (avoid per-frame allocations / GC pressure)
var _v1 = new THREE.Vector3(), _v2 = new THREE.Vector3(), _v3 = new THREE.Vector3();
var _v4 = new THREE.Vector3(), _v5 = new THREE.Vector3(), _v6 = new THREE.Vector3();
var _q1 = new THREE.Quaternion(), _q2 = new THREE.Quaternion();
var _m1 = new THREE.Matrix4();
// Reusable curve info object (returned by getCurveInfo to avoid allocations)
var _curveResult = { normal: new THREE.Vector3(), onCurve: true, center: new THREE.Vector3(), dist: 0, radius: 0 };
// Reusable up vector for replay camera
var _upY = new THREE.Vector3(0, 1, 0);

// Curve zone descriptor table for getCurveInfo â€” replaces 8 near-identical blocks.
// isX: arc in XY plane (true) or YZ plane (false)
// cHorizSign: +1 = positive edge (right/front), -1 = negative edge (left/back)
// yFloor: true = floor-wall curve, false = wall-ceiling curve
// d0Sign: sign for horizontal delta in the normal-direction test
// hasGoal: true = apply goal-opening exclusion check
var _curveZones = [
  { isX:true,  cHorizSign:-1, yFloor:true,  d0Sign:-1              }, // floor-left
  { isX:true,  cHorizSign: 1, yFloor:true,  d0Sign: 1              }, // floor-right
  { isX:false, cHorizSign: 1, yFloor:true,  d0Sign: 1, hasGoal:true}, // floor-front
  { isX:false, cHorizSign:-1, yFloor:true,  d0Sign:-1, hasGoal:true}, // floor-back
  { isX:true,  cHorizSign:-1, yFloor:false, d0Sign:-1              }, // ceil-left
  { isX:true,  cHorizSign: 1, yFloor:false, d0Sign: 1              }, // ceil-right
  { isX:false, cHorizSign: 1, yFloor:false, d0Sign: 1              }, // ceil-front
  { isX:false, cHorizSign:-1, yFloor:false, d0Sign:-1              }  // ceil-back
];

// ==========================================================================
// STATE
// ==========================================================================
var scene, camera, renderer, clock;
var ball, ballGlow, ballIndicator;
var playerCar, aiCar;
var arenaGroup;
var particles = [];
var boostPads = [];
var audioCtx = null;

// Physics state
var bP = new THREE.Vector3();        // ball position
var bV = new THREE.Vector3();        // ball velocity
var pP = new THREE.Vector3();        // player position
var pV = new THREE.Vector3();        // player velocity
var pRot = 0, pSpeed = 0;           // player rotation Y, speed scalar
var pGround = true, pBoost = BOOST_MAX;
var pCanDodge = false, pDodgeTimer = 0;
var pSpin = 0;                       // spin animation timer
var pFlipDirX = 0, pFlipDirZ = 0;    // flip direction for flip cancel (half-flip)
var pPitch = 0;                      // aerial nose pitch angle
var pRoll = 0;                       // aerial body roll angle
var pAngVelPitch = 0, pAngVelYaw = 0, pAngVelRoll = 0; // aerial angular velocities (rad/s)
var pPowerslide = false;             // powerslide active
var pSupersonic = false;             // at supersonic speed
var pSurface = 'floor';             // 'floor','ceiling','wallXn','wallXp','wallZn','wallZp','air'
var pWallGraceTimer = 0;            // grace period before falling off walls at low speed
var pJumpCooldown = 0;              // prevents immediate wall re-attach after jumping
var pJumpHoldTimer = 0;            // RL-style hold-jump for variable height (max 0.2s)
var pTargetQuat = new THREE.Quaternion();
var pVisualQuat = new THREE.Quaternion();
var WALL_MIN_SPEED = 2;             // minimum speed to stick to walls (RL-like sticky driving)
var WALL_DETACH_GRACE = 0.6;        // seconds of grace before falling off
var _pSmoothNormal = new THREE.Vector3(0, 1, 0); // smoothed surface normal for camera/visuals
var _pOnCurve = false;              // true while car is in a curve transition
var _pSnapVisual = false;           // snap visual quaternion on next syncVisuals (no slerp)
var pDemoed = false, pDemoTimer = 0; // demolished state
var isOvertime = false;              // sudden-death overtime active
var _slowmoTimer = 0;                // slow-motion effect on goal
var _slowmoScale = 0.3;              // slow-mo speed multiplier
var _slowmoDuration = 0.8;           // initial slow-mo timer value (used for ease formula)
var overtimeAnnounceT = 0;           // separate timer for overtime_announce state (not shared with goalT)
var _goalBloomTimer = 0;             // dt-based timer for bloom reset after goal
var aP = new THREE.Vector3();        // AI position
var aV = new THREE.Vector3();        // AI velocity
var aRot = Math.PI, aSpeed = 0;
var aGround = true, aBoost = BOOST_MAX;
var aDemoed = false, aDemoTimer = 0;

var score = [0, 0];                  // orange (player), blue (AI)
var gameTime = GAME_DURATION;
var gameState = 'menu';              // menu, countdown, playing, goal, gameover, overtime_announce
var _frameDt = 0.016;                // current frame delta time (for syncVisuals etc.)

// Match stats tracking (like RL scoreboard)
var matchStats = { pGoals: 0, pShots: 0, pSaves: 0, pDemos: 0, aGoals: 0, aShots: 0, aSaves: 0 };

// ==========================================================================
// GAME MODE STATE
// ==========================================================================
var activeGameMode = 'standard';

// Heatseeker state
var heatseekerSpeed = 0;           // current ball speed multiplier from hits
var heatseekerTarget = 0;          // +1 = toward player goal (z+), -1 = toward AI goal (z-)
var HEATSEEKER_BASE_SPEED = 45;
var HEATSEEKER_SPEED_INC = 8;
var HEATSEEKER_MAX_SPEED = 120;
var HEATSEEKER_CURVE = 35;         // how strongly ball curves toward goal

// Snow Day state (puck physics)
var snowdayActive = false;
var puckMesh = null;

// Hoops state
var hoopsActive = false;
var hoopsRingMeshes = [];
var HOOPS_RING_HEIGHT = 10;        // height of hoop center
var HOOPS_RING_RADIUS = 5;         // radius of hoop opening

// Rumble state
var rumbleActive = false;
var playerPowerup = null;          // 'freeze', 'spikes', 'boot', 'haymaker' or null
var aiPowerup = null;
var playerPowerupTimer = 0;        // cooldown timer
var aiPowerupTimer = 0;
var RUMBLE_COOLDOWN = 10;
var RUMBLE_POWERUPS = ['freeze', 'spikes', 'boot', 'haymaker'];
var playerSpikesAttached = false;
var aiSpikesAttached = false;
var ballFrozen = false;
var ballFreezeTimer = 0;
var _spikesTimerP = 0;
var _spikesTimerA = 0;

// Dropshot state
var dropshotActive = false;
var dropshotTiles = [];       // array of {x, z, state, mesh} â€” state: 0=intact, 1=cracked, 2=open
var dropshotBallPhase = 0;    // 0=phase1 (1 tile), 1=phase2 (7 tiles), 2=phase3 (19 tiles)
var dropshotHitCount = 0;     // car hits since last ground contact
var DROPSHOT_HEX_SIZE = 5;    // radius of each hexagonal tile
var dropshotGroup = null;     // THREE.Group for tile meshes
var dropshotFallTile = null;  // tile ball entered when falling through open hole

// XP / Level system (persisted in localStorage)
var playerXP = 0;
var playerLevel = 1;
var XP_PER_LEVEL = 100;
function loadXP() {
  try {
    var saved = JSON.parse(localStorage.getItem('rocketArenaXP'));
    if (saved) { playerXP = saved.xp || 0; playerLevel = saved.level || 1; }
  } catch(e) { console.warn('[RocketArena]', e); }
  XP_PER_LEVEL = Math.floor(100 + (playerLevel - 1) * 20);
  updateLevelDisplay();
}
function saveXP() {
  try { localStorage.setItem('rocketArenaXP', JSON.stringify({ xp: playerXP, level: playerLevel })); } catch(e) { console.warn('[RocketArena]', e); }
}
function addXP(amount) {
  playerXP += amount;
  while (playerXP >= XP_PER_LEVEL) {
    playerXP -= XP_PER_LEVEL;
    playerLevel++;
    XP_PER_LEVEL = Math.floor(100 + (playerLevel - 1) * 20); // XP req increases per level
  }
  saveXP();
  updateLevelDisplay();
}
function updateLevelDisplay() {
  var el = document.getElementById('level-display');
  if (el) el.textContent = 'LVL ' + playerLevel;
}
var countdownVal = 3;
var countdownT = 0;
var goalT = 0;
var goalScorer = '';
var keys = {};
var ballCam = false;

// Cached DOM refs for updateUI (assigned in init() to avoid per-frame getElementById)
var _elBoostFill, _elBoostText, _elBallcam, _elPowerslide, _elBallSpeed, _elSupersonic, _elSpeedLines, _elLastTouch;
var cameraTarget = new THREE.Vector3();
var cameraPos = new THREE.Vector3();
var cameraUp = new THREE.Vector3(0, 1, 0);

// Ball trail system
var ballTrail = [];
var BALL_TRAIL_MAX = 24;

// Screen shake
var _shakeIntensity = 0;
var _shakeTimer = 0;

// Goal flash
var _goalFlashTimer = 0;

// Demo text
var _demoTextTimer = 0;

// Supersonic threshold (% of max boost speed)
var SUPERSONIC_THRESH = 0.95;

// Gamepad state
var gamepad = {
  connected: false, type: 'generic',
  leftStickX: 0, leftStickY: 0,
  rightStickX: 0, rightStickY: 0,
  rightTrigger: 0, leftTrigger: 0,
  buttonA: false, buttonB: false, buttonX: false, buttonY: false,
  bumperL: false, bumperR: false,
  dpadUp: false, dpadDown: false, dpadLeft: false, dpadRight: false,
  _prevButtonA: false, _prevButtonB: false, _prevButtonX: false, _prevButtonY: false,
  _prevBumperL: false, _prevBumperR: false,
  _prevDpadUp: false, _prevDpadDown: false, _prevDpadLeft: false, _prevDpadRight: false
};

function detectControllerType(id) {
  if (!id) return 'generic';
  var s = id.toLowerCase();
  if (s.indexOf('xbox') !== -1 || s.indexOf('xinput') !== -1 || s.indexOf('045e') !== -1) return 'xbox';
  if (s.indexOf('playstation') !== -1 || s.indexOf('dualsense') !== -1 || s.indexOf('dualshock') !== -1 || s.indexOf('054c') !== -1 || s.indexOf('sony') !== -1) return 'playstation';
  if (s.indexOf('pro controller') !== -1 || s.indexOf('joy-con') !== -1 || s.indexOf('057e') !== -1 || s.indexOf('nintendo') !== -1) return 'nintendo';
  return 'generic';
}

function controllerTypeName(type) {
  if (type === 'xbox') return 'Xbox Controller';
  if (type === 'playstation') return 'PlayStation Controller';
  if (type === 'nintendo') return 'Nintendo Controller';
  return 'Controller';
}

var GAMEPAD_BUTTON_NAMES = {
  xbox: { buttonA: 'A', buttonB: 'B', buttonX: 'X', buttonY: 'Y', bumperL: 'LB', bumperR: 'RB', leftTrigger: 'LT', rightTrigger: 'RT' },
  playstation: { buttonA: 'Cross', buttonB: 'Circle', buttonX: 'Square', buttonY: 'Triangle', bumperL: 'L1', bumperR: 'R1', leftTrigger: 'L2', rightTrigger: 'R2' },
  nintendo: { buttonA: 'B', buttonB: 'A', buttonX: 'Y', buttonY: 'X', bumperL: 'L', bumperR: 'R', leftTrigger: 'ZL', rightTrigger: 'ZR' },
  generic: { buttonA: 'Btn 0', buttonB: 'Btn 1', buttonX: 'Btn 2', buttonY: 'Btn 3', bumperL: 'Btn 4', bumperR: 'Btn 5', leftTrigger: 'Btn 6', rightTrigger: 'Btn 7' }
};

var CONTROLLER_PRESETS = {
  xbox: {
    label: 'Xbox One / Series',
    deadzone: 0.10,
    steeringSensitivity: 1.0,
    vibration: true,
    gamepadControls: { jump: 'buttonA', boost: 'buttonB', powerslide: 'buttonX', ballcam: 'buttonY', quickchat: 'bumperR', reset: 'bumperL', airRollLeft: '', airRollRight: '' }
  },
  playstation: {
    label: 'PlayStation DualSense / DS4',
    deadzone: 0.08,
    steeringSensitivity: 1.0,
    vibration: true,
    gamepadControls: { jump: 'buttonA', boost: 'buttonB', powerslide: 'buttonX', ballcam: 'buttonY', quickchat: 'bumperR', reset: 'bumperL', airRollLeft: '', airRollRight: '' }
  },
  nintendo: {
    label: 'Nintendo Pro Controller',
    deadzone: 0.12,
    steeringSensitivity: 1.1,
    vibration: true,
    gamepadControls: { jump: 'buttonA', boost: 'buttonB', powerslide: 'buttonX', ballcam: 'buttonY', quickchat: 'bumperR', reset: 'bumperL', airRollLeft: '', airRollRight: '' }
  }
};

function applyControllerPreset(presetKey) {
  var preset = CONTROLLER_PRESETS[presetKey];
  if (!preset) return;
  settings.deadzone = preset.deadzone;
  settings.steeringSensitivity = preset.steeringSensitivity;
  settings.vibration = preset.vibration;
  Object.keys(preset.gamepadControls).forEach(function(key) {
    settings.gamepadControls[key] = preset.gamepadControls[key];
  });
  settingsToUI();
  saveSettings();
}

// All bindable gamepad buttons
var GAMEPAD_BINDABLE = ['buttonA', 'buttonB', 'buttonX', 'buttonY', 'bumperL', 'bumperR'];

function gamepadButtonName(binding, type) {
  if (!binding) return 'None';
  var t = type || gamepad.type || 'generic';
  var names = GAMEPAD_BUTTON_NAMES[t] || GAMEPAD_BUTTON_NAMES.generic;
  return names[binding] || binding;
}

// Controller vibration/haptic feedback
function vibrateController(duration, weakMagnitude, strongMagnitude) {
  if (!settings.vibration || !gamepad.connected) return;
  try {
    var gps = navigator.getGamepads ? navigator.getGamepads() : [];
    var gp = gps[0] || gps[1] || gps[2] || gps[3];
    if (gp && gp.vibrationActuator) {
      gp.vibrationActuator.playEffect('dual-rumble', {
        startDelay: 0,
        duration: duration,
        weakMagnitude: weakMagnitude,
        strongMagnitude: strongMagnitude
      });
    }
  } catch(e) {}
}

function pollGamepad() {
  var gps = navigator.getGamepads ? navigator.getGamepads() : [];
  var gp = gps[0] || gps[1] || gps[2] || gps[3];
  if (!gp) { gamepad.connected = false; return; }
  gamepad.connected = true;
  if (!gamepad._detectedId || gamepad._detectedId !== gp.id) {
    gamepad._detectedId = gp.id;
    gamepad.type = detectControllerType(gp.id);
  }
  var dz = settings.deadzone || 0.12;
  gamepad.leftStickX = Math.abs(gp.axes[0]) > dz ? gp.axes[0] : 0;
  gamepad.leftStickY = Math.abs(gp.axes[1]) > dz ? gp.axes[1] : 0;
  gamepad.rightStickX = gp.axes[2] !== undefined && Math.abs(gp.axes[2]) > dz ? gp.axes[2] : 0;
  gamepad.rightStickY = gp.axes[3] !== undefined && Math.abs(gp.axes[3]) > dz ? gp.axes[3] : 0;
  gamepad.rightTrigger = gp.buttons[7] ? gp.buttons[7].value : 0;
  gamepad.leftTrigger = gp.buttons[6] ? gp.buttons[6].value : 0;
  // Save prev state for edge-triggering before updating
  gamepad._prevButtonA = gamepad.buttonA;
  gamepad._prevButtonB = gamepad.buttonB;
  gamepad._prevButtonX = gamepad.buttonX;
  gamepad._prevButtonY = gamepad.buttonY;
  gamepad._prevBumperL = gamepad.bumperL;
  gamepad._prevBumperR = gamepad.bumperR;
  gamepad.buttonA = gp.buttons[0] ? gp.buttons[0].pressed : false;
  gamepad.buttonB = gp.buttons[1] ? gp.buttons[1].pressed : false;
  gamepad.buttonX = gp.buttons[2] ? gp.buttons[2].pressed : false;
  gamepad.buttonY = gp.buttons[3] ? gp.buttons[3].pressed : false;
  gamepad.bumperL = gp.buttons[4] ? gp.buttons[4].pressed : false;
  gamepad.bumperR = gp.buttons[5] ? gp.buttons[5].pressed : false;
  gamepad._prevDpadUp = gamepad.dpadUp;
  gamepad._prevDpadDown = gamepad.dpadDown;
  gamepad._prevDpadLeft = gamepad.dpadLeft;
  gamepad._prevDpadRight = gamepad.dpadRight;
  gamepad.dpadUp = gp.buttons[12] ? gp.buttons[12].pressed : false;
  gamepad.dpadDown = gp.buttons[13] ? gp.buttons[13].pressed : false;
  gamepad.dpadLeft = gp.buttons[14] ? gp.buttons[14].pressed : false;
  gamepad.dpadRight = gp.buttons[15] ? gp.buttons[15].pressed : false;
}

// Post-processing
var composer = null;
var bloomPass = null;

function initBloom() {
  // Dynamically import ESM modules for bloom post-processing
  Promise.all([
    import('https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js'),
    import('https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/RenderPass.js'),
    import('https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js')
  ]).then(function(modules) {
    var EffectComposer = modules[0].EffectComposer;
    var RenderPass = modules[1].RenderPass;
    var UnrealBloomPass = modules[2].UnrealBloomPass;

    composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      0.4, 0.6, 0.85
    );
    composer.addPass(bloomPass);
  }).catch(function(e) {
    // Bloom not available â€” game works fine without it
    composer = null;
    bloomPass = null;
  });
}

// Last touch tracking
var lastTouchTeam = ''; // 'orange' or 'blue'
var lastTouchTimer = 0;

// === REPLAY SYSTEM ===
// Ring buffer recording: stores game state each frame for ~4 seconds
var REPLAY_BUFFER_SECS = 4;
var REPLAY_MAX_FRAMES = 250; // ~4 sec at 60fps
var replayBuffer = [];       // array of frame snapshots
var replayActive = false;    // true during replay playback
var replayFrameIdx = 0;      // current playback frame
var replaySpeed = 0.5;       // playback speed (0.5 = half speed)
var replayAccum = 0;         // fractional frame accumulator
var replayData = null;       // snapshot of buffer at goal time
var replayCamMode = 0;       // 0=follow ball, 1=behind scorer, 2=orbit goal
var replayCamAngle = 0;
var replayGoalScorer = '';   // who scored for camera targeting

function recordReplayFrame() {
  if (gameState !== 'playing') return;
  var frame = {
    bx: bP.x, by: bP.y, bz: bP.z,
    bvx: bV.x, bvy: bV.y, bvz: bV.z,
    px: pP.x, py: pP.y, pz: pP.z, pr: pRot, psp: pSpeed, psurf: pSurface,
    pqw: pVisualQuat.w, pqx: pVisualQuat.x, pqy: pVisualQuat.y, pqz: pVisualQuat.z,
    ax: aP.x, ay: aP.y, az: aP.z, ar: aRot,
    a2x: a2P ? a2P.x : 0, a2y: a2P ? a2P.y : 0, a2z: a2P ? a2P.z : 0, a2r: a2Rot,
    a3x: a3P ? a3P.x : 0, a3y: a3P ? a3P.y : 0, a3z: a3P ? a3P.z : 0, a3r: a3Rot,
    a4x: a4P ? a4P.x : 0, a4y: a4P ? a4P.y : 0, a4z: a4P ? a4P.z : 0, a4r: a4Rot,
    a5x: a5P ? a5P.x : 0, a5y: a5P ? a5P.y : 0, a5z: a5P ? a5P.z : 0, a5r: a5Rot
  };
  replayBuffer.push(frame);
  if (replayBuffer.length > REPLAY_MAX_FRAMES) replayBuffer.shift();
}

function startReplay(scorer) {
  if (replayBuffer.length < 10) return; // not enough data
  replayData = replayBuffer.slice(); // copy the buffer
  replayBuffer = []; // clear for next recording
  replayActive = true;
  replayFrameIdx = 0;
  replayAccum = 0;
  replayGoalScorer = scorer;
  // Pick camera mode: 0=follow ball (most common in RL)
  replayCamMode = 0;
  replayCamAngle = Math.random() * Math.PI * 2;
  document.getElementById('replay-badge').className = 'show';
}

function updateReplay(dt) {
  if (!replayActive || !replayData || replayData.length === 0) return false;

  // Advance through frames at replay speed
  replayAccum += dt * 60 * replaySpeed; // 60fps base rate * speed
  var framesToAdvance = Math.floor(replayAccum);
  replayAccum -= framesToAdvance;
  replayFrameIdx += framesToAdvance;

  if (replayFrameIdx >= replayData.length - 1) {
    // Replay finished
    endReplay();
    return false;
  }

  // Interpolate between current and next frame
  var f0 = replayData[replayFrameIdx];
  var f1 = replayData[Math.min(replayFrameIdx + 1, replayData.length - 1)];
  var t = replayAccum;

  // Position ball
  bP.set(
    f0.bx + (f1.bx - f0.bx) * t,
    f0.by + (f1.by - f0.by) * t,
    f0.bz + (f1.bz - f0.bz) * t
  );
  // Interpolate ball velocity for accurate speed display
  bV.set(
    f0.bvx + (f1.bvx - f0.bvx) * t,
    f0.bvy + (f1.bvy - f0.bvy) * t,
    f0.bvz + (f1.bvz - f0.bvz) * t
  );
  ball.position.copy(bP);

  // Position player car
  playerCar.position.set(
    f0.px + (f1.px - f0.px) * t,
    f0.py + (f1.py - f0.py) * t,
    f0.pz + (f1.pz - f0.pz) * t
  );
  // Interpolate player quaternion
  var q0 = new THREE.Quaternion(f0.pqx, f0.pqy, f0.pqz, f0.pqw);
  var q1 = new THREE.Quaternion(f1.pqx, f1.pqy, f1.pqz, f1.pqw);
  q0.slerp(q1, t);
  playerCar.setRotationFromQuaternion(q0);

  // Position AI car
  aiCar.position.set(
    f0.ax + (f1.ax - f0.ax) * t,
    f0.ay + (f1.ay - f0.ay) * t,
    f0.az + (f1.az - f0.az) * t
  );
  var aiRotInterp = f0.ar + shortAngleDiff(f0.ar, f1.ar) * t;
  aiCar.rotation.y = aiRotInterp;

  // 2v2 extra cars
  if (aiCar2 && aiCar2.visible) {
    aiCar2.position.set(
      f0.a2x + (f1.a2x - f0.a2x) * t,
      f0.a2y + (f1.a2y - f0.a2y) * t,
      f0.a2z + (f1.a2z - f0.a2z) * t
    );
    aiCar2.rotation.y = f0.a2r + shortAngleDiff(f0.a2r, f1.a2r) * t;
  }
  if (aiCar3 && aiCar3.visible) {
    aiCar3.position.set(
      f0.a3x + (f1.a3x - f0.a3x) * t,
      f0.a3y + (f1.a3y - f0.a3y) * t,
      f0.a3z + (f1.a3z - f0.a3z) * t
    );
    aiCar3.rotation.y = f0.a3r + shortAngleDiff(f0.a3r, f1.a3r) * t;
  }
  if (aiCar4 && aiCar4.visible) {
    aiCar4.position.set(
      f0.a4x + (f1.a4x - f0.a4x) * t,
      f0.a4y + (f1.a4y - f0.a4y) * t,
      f0.a4z + (f1.a4z - f0.a4z) * t
    );
    aiCar4.rotation.y = f0.a4r + shortAngleDiff(f0.a4r, f1.a4r) * t;
  }
  if (aiCar5 && aiCar5.visible) {
    aiCar5.position.set(
      f0.a5x + (f1.a5x - f0.a5x) * t,
      f0.a5y + (f1.a5y - f0.a5y) * t,
      f0.a5z + (f1.a5z - f0.a5z) * t
    );
    aiCar5.rotation.y = f0.a5r + shortAngleDiff(f0.a5r, f1.a5r) * t;
  }

  // Replay camera â€” follow ball with cinematic angle
  updateReplayCamera(dt);

  return true; // replay is active, skip normal updates
}

function shortAngleDiff(from, to) {
  var d = to - from;
  while (d > Math.PI) d -= Math.PI * 2;
  while (d < -Math.PI) d += Math.PI * 2;
  return d;
}

function updateReplayCamera(dt) {
  replayCamAngle += dt * 0.3;
  var progress = replayData.length > 1 ? replayFrameIdx / (replayData.length - 1) : 0; // 0 to 1

  // RL-style: camera follows ball from behind/above, with slow orbit
  var goalZ = replayGoalScorer === 'player' ? -FL / 2 : FL / 2;
  var ballPos = ball.position;

  // Switch camera mode at different points in the replay
  if (progress < 0.6) {
    // Follow ball from behind with slight offset
    var behindDir = goalZ > 0 ? -1 : 1;
    var camDist = 22;
    var camH = 10;
    var sideOffset = Math.sin(replayCamAngle) * 8;
    var idealPos = _v2.set(
      ballPos.x + sideOffset,
      ballPos.y + camH,
      ballPos.z + behindDir * camDist
    );
    var idealTarget = _v3.set(ballPos.x, ballPos.y + 1, ballPos.z);
    cameraPos.lerp(idealPos, 2.5 * dt);
    cameraTarget.lerp(idealTarget, 3 * dt);
  } else {
    // Final part: dramatic orbit around goal
    var orbR = 25;
    var orbH = 10 + Math.sin(replayCamAngle * 2) * 3;
    var idealPos = _v2.set(
      Math.cos(replayCamAngle * 2) * orbR,
      orbH,
      goalZ + Math.sin(replayCamAngle * 2) * orbR * 0.4
    );
    var idealTarget = _v3.set(0, GH / 2, goalZ);
    cameraPos.lerp(idealPos, 2 * dt);
    cameraTarget.lerp(idealTarget, 2.5 * dt);
  }

  cameraUp.lerp(_upY.set(0, 1, 0), 5 * dt).normalize();
  camera.position.copy(cameraPos);
  camera.up.copy(cameraUp);
  camera.lookAt(cameraTarget);
}

function endReplay() {
  replayActive = false;
  replayData = null;
  document.getElementById('replay-badge').className = '';
}

// Goal scorer display
var _goalScorerTimer = 0;

// Engine sound
var engineOsc = null;
var engineGain = null;
var engineStarted = false;

// Boost pickup sound
function playBoostPickupSound(big) {
  var ctx = getAudio(); if (!ctx) return;
  var osc = ctx.createOscillator();
  var gain = ctx.createGain();
  osc.connect(gain); gain.connect(ctx.destination);
  osc.type = 'sine';
  if (big) {
    osc.frequency.setValueAtTime(400, ctx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(1200, ctx.currentTime + 0.15);
    gain.gain.setValueAtTime(0.12 * VOLUME_SCALE, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.2);
    osc.start(); osc.stop(ctx.currentTime + 0.2);
    // Second sparkle tone
    var osc2 = ctx.createOscillator();
    var gain2 = ctx.createGain();
    osc2.connect(gain2); gain2.connect(ctx.destination);
    osc2.type = 'sine';
    osc2.frequency.setValueAtTime(800, ctx.currentTime + 0.05);
    osc2.frequency.exponentialRampToValueAtTime(1600, ctx.currentTime + 0.15);
    gain2.gain.setValueAtTime(0.08 * VOLUME_SCALE, ctx.currentTime + 0.05);
    gain2.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.2);
    osc2.start(ctx.currentTime + 0.05); osc2.stop(ctx.currentTime + 0.2);
  } else {
    osc.frequency.setValueAtTime(600, ctx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(900, ctx.currentTime + 0.08);
    gain.gain.setValueAtTime(0.06 * VOLUME_SCALE, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.1);
    osc.start(); osc.stop(ctx.currentTime + 0.1);
  }
}

// Wall hit sound
function playWallHitSound() {
  var ctx = getAudio(); if (!ctx) return;
  var osc = ctx.createOscillator();
  var gain = ctx.createGain();
  var bufSize = ctx.sampleRate * 0.2;
  var buf = ctx.createBuffer(1, bufSize, ctx.sampleRate);
  var data = buf.getChannelData(0);
  for (var i = 0; i < bufSize; i++) data[i] = (Math.random() * 2 - 1) * 0.3;
  var noise = ctx.createBufferSource();
  noise.buffer = buf;
  noise.connect(gain); gain.connect(ctx.destination);
  gain.gain.setValueAtTime(0.08 * VOLUME_SCALE, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15);
  noise.start(); noise.stop(ctx.currentTime + 0.2);
}

// Engine sound system
function startEngineSound() {
  if (engineStarted) return;
  var ctx = getAudio(); if (!ctx) return;
  engineStarted = true;
  engineOsc = ctx.createOscillator();
  engineGain = ctx.createGain();
  engineOsc.type = 'sawtooth';
  engineOsc.frequency.value = 50;
  engineGain.gain.value = 0;
  engineOsc.connect(engineGain);
  engineGain.connect(ctx.destination);
  engineOsc.start();
}

function updateEngineSound() {
  if (!engineOsc || !engineGain || !audioCtx) return;
  var absSpeed = Math.abs(pSpeed);
  var maxSpd = CAR_BOOST_MAX * CAR_SPEED_MULT;
  var speedFrac = Math.min(absSpeed / maxSpd, 1);
  // Frequency: 50Hz idle to 200Hz at max speed
  engineOsc.frequency.value = 50 + speedFrac * 150;
  // Boost sound pitch scales with car speed (80Hz rumble â†’ 200Hz roar at full boost)
  if (_boostSoundNode) {
    _boostSoundNode.osc.frequency.value = 80 + speedFrac * 120;
  }
  // Volume: quiet idle, louder at speed, capped low
  var targetVol = (0.01 + speedFrac * 0.04) * VOLUME_SCALE;
  if (gameState !== 'playing') targetVol = 0;
  engineGain.gain.value += (targetVol - engineGain.gain.value) * 0.1;
}

function playPowerslideScreech() {
  var ctx = getAudio(); if (!ctx) return;
  var bufSize = ctx.sampleRate * 0.08;
  var buf = ctx.createBuffer(1, bufSize, ctx.sampleRate);
  var data = buf.getChannelData(0);
  for (var i = 0; i < bufSize; i++) data[i] = (Math.random() * 2 - 1);
  var noise = ctx.createBufferSource();
  var filter = ctx.createBiquadFilter();
  var gain = ctx.createGain();
  filter.type = 'bandpass'; filter.frequency.value = 900; filter.Q.value = 2;
  noise.buffer = buf;
  noise.connect(filter); filter.connect(gain); gain.connect(ctx.destination);
  gain.gain.setValueAtTime(0.05 * VOLUME_SCALE, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.08);
  noise.start(); noise.stop(ctx.currentTime + 0.08);
}

function playLandingSound(impactSpeed) {
  var ctx = getAudio(); if (!ctx || impactSpeed < 5) return;
  var bufSize = ctx.sampleRate * 0.15;
  var buf = ctx.createBuffer(1, bufSize, ctx.sampleRate);
  var data = buf.getChannelData(0);
  for (var i = 0; i < bufSize; i++) data[i] = (Math.random() * 2 - 1) * 0.5;
  var noise = ctx.createBufferSource();
  var gain = ctx.createGain();
  noise.buffer = buf;
  noise.connect(gain); gain.connect(ctx.destination);
  var vol = Math.min(impactSpeed / 30, 1) * 0.12 * VOLUME_SCALE;
  gain.gain.setValueAtTime(vol, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.12);
  noise.start(); noise.stop(ctx.currentTime + 0.15);
}

// Crowd ambience
var crowdNoise = null;
var crowdGain = null;
var crowdStarted = false;

function startCrowdNoise() {
  if (crowdStarted) return;
  var ctx = getAudio(); if (!ctx) return;
  crowdStarted = true;
  var bufSize = ctx.sampleRate * 2;
  var buf = ctx.createBuffer(1, bufSize, ctx.sampleRate);
  var data = buf.getChannelData(0);
  // Low-pass filtered noise to simulate crowd murmur
  var prev = 0;
  for (var i = 0; i < bufSize; i++) {
    var white = Math.random() * 2 - 1;
    prev = prev * 0.98 + white * 0.02;
    data[i] = prev * 3;
  }
  crowdNoise = ctx.createBufferSource();
  crowdGain = ctx.createGain();
  crowdNoise.buffer = buf;
  crowdNoise.loop = true;
  crowdGain.gain.value = 0.02 * VOLUME_SCALE;
  crowdNoise.connect(crowdGain);
  crowdGain.connect(ctx.destination);
  crowdNoise.start();
}

function updateCrowdNoise() {
  if (!crowdGain) return;
  var targetVol = 0.02 * VOLUME_SCALE;
  // Louder after goals
  if (gameState === 'goal') targetVol = 0.06 * VOLUME_SCALE;
  if (gameState !== 'playing' && gameState !== 'goal' && gameState !== 'countdown') targetVol = 0.005 * VOLUME_SCALE;
  crowdGain.gain.value += (targetVol - crowdGain.gain.value) * 0.05;
}

// Shockwave ring for goal explosions
function spawnGoalShockwave(zPos, color) {
  var ringGeo = new THREE.RingGeometry(0.5, 2, 32);
  var ringMat = new THREE.MeshBasicMaterial({
    color: color, transparent: true, opacity: 0.8, side: THREE.DoubleSide, depthWrite: false
  });
  var ring = new THREE.Mesh(ringGeo, ringMat);
  ring.position.set(0, GH / 2, zPos);
  ring.rotation.y = zPos > 0 ? 0 : Math.PI;
  scene.add(ring);
  particles.push({
    mesh: ring, vx: 0, vy: 0, vz: 0,
    life: 1.2, maxLife: 1.2, isShockwave: true
  });
}

// AI state machine
var AI_STATE = 'chase'; // chase, rotate, defend, kickoff, boost_collect, clear, shadow, demo
var AI_STATE_TIMER = 0;
var AI_DODGE_COOLDOWN = 0;
var AI_TARGET = new THREE.Vector3();

// AI dodge pending timers â€” replace setTimeout calls so slow-mo scaling works correctly
var _aKickoffDodgeT = 0;   // kickoff flip pending (s)
var _aClearFlipT = 0;      // clear-flip pending (s)
var _aSpeedDodgeT = 0;     // speed-dodge pending (s)
var _aSpeedDodgeX = 0;     // captured X impulse for speed dodge
var _aSpeedDodgeZ = 0;     // captured Z impulse for speed dodge
var _aDoubleJumpT = 0;     // double-jump aerial pending (s)
var _aFlickT = 0;          // quick-flick pending (s)

// ==========================================================================
// INITIALIZATION
// ==========================================================================
function init() {
  _initSurfaceAxes(); // Pre-allocate surface axes cache

  // Cache UI DOM refs once (avoids 480 getElementById calls/second in updateUI)
  _elBoostFill    = document.getElementById('boost-fill');
  _elBoostText    = document.getElementById('boost-text');
  _elBallcam      = document.getElementById('ballcam-indicator');
  _elPowerslide   = document.getElementById('powerslide-indicator');
  _elBallSpeed    = document.getElementById('ball-speed');
  _elSupersonic   = document.getElementById('supersonic');
  _elSpeedLines   = document.getElementById('speed-lines');
  _elLastTouch    = document.getElementById('last-touch');

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x06080e);
  scene.fog = new THREE.FogExp2(0x06080e, 0.003);

  camera = new THREE.PerspectiveCamera(110, window.innerWidth / window.innerHeight, 0.5, 500);
  camera.position.set(0, 35, 70);

  renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 2.0;
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  document.body.appendChild(renderer.domElement);

  clock = new THREE.Clock();

  // Post-processing: bloom (loaded async via ESM import)
  initBloom();

  // Skybox â€” procedural starfield
  createSkybox();

  // Lights â€” bright RL stadium floodlighting
  scene.add(new THREE.AmbientLight(0x606880, 0.9));

  var hemi = new THREE.HemisphereLight(0xe0eeff, 0x776655, 1.4);
  scene.add(hemi);

  // Main overhead light with shadows (stadium floodlight feel)
  var sun = new THREE.DirectionalLight(0xfff8ee, 3.0);
  sun.position.set(10, 80, 5);
  sun.castShadow = true;
  sun.shadow.mapSize.set(1024, 1024);
  sun.shadow.camera.left = -100; sun.shadow.camera.right = 100;
  sun.shadow.camera.top = 100; sun.shadow.camera.bottom = -100;
  sun.shadow.camera.far = 200;
  sun.shadow.bias = -0.0005;
  sun.shadow.normalBias = 0.02;
  scene.add(sun);

  // Fill light from opposite side (balanced stadium fill)
  var fill = new THREE.DirectionalLight(0xe0eaff, 1.3);
  fill.position.set(-30, 60, -20);
  scene.add(fill);

  // Warm kicker light from above (adds depth to car paint)
  var kicker = new THREE.DirectionalLight(0xffeedd, 0.6);
  kicker.position.set(0, 50, -40);
  scene.add(kicker);

  // Extra ground bounce light (RL stadiums have bright green bounce from field)
  var bounce = new THREE.DirectionalLight(0xaaddaa, 0.3);
  bounce.position.set(0, -10, 0);
  scene.add(bounce);

  // Stadium floodlight towers (4 corners only â€” optimized for perf)
  var poleMat = new THREE.MeshStandardMaterial({ color: 0x888899, metalness: 0.8, roughness: 0.3 });
  var floodPositions = [
    [-FW * 0.6, WH + 20, -FL * 0.45],
    [FW * 0.6, WH + 20, -FL * 0.45],
    [-FW * 0.6, WH + 20, FL * 0.45],
    [FW * 0.6, WH + 20, FL * 0.45]
  ];
  floodPositions.forEach(function(fp) {
    var spot = new THREE.SpotLight(0xfff8e8, 2.5, 250, Math.PI * 0.45, 0.6, 1.2);
    spot.position.set(fp[0], fp[1], fp[2]);
    spot.target.position.set(0, 0, fp[2] * 0.3);
    scene.add(spot);
    scene.add(spot.target);

    // Tower pole + housing (2 meshes per tower, no volumetric cones)
    var pole = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, WH + 18, 6), poleMat);
    pole.position.set(fp[0], (WH + 18) / 2, fp[2]);
    scene.add(pole);
    var housing = new THREE.Mesh(new THREE.BoxGeometry(2.5, 1.2, 2.5), poleMat);
    housing.position.set(fp[0], fp[1], fp[2]);
    scene.add(housing);
  });

  // Goal area lights (1 per goal, not 2) â€” strong team-colored glow
  var orangeLight = new THREE.PointLight(0xff6600, 6, 70);
  orangeLight.position.set(0, 8, FL / 2 + 4);
  scene.add(orangeLight);
  var blueLight = new THREE.PointLight(0x0088ff, 6, 70);
  blueLight.position.set(0, 8, -FL / 2 - 4);
  scene.add(blueLight);

  createArena();
  createBall();
  playerCar = createCar(0xff6600, 0xff8800);
  scene.add(playerCar);
  aiCar = createCar(0x0066ff, 0x0088ff);
  scene.add(aiCar);
  createBoostPads();

  resetPositions();
  setupInput();

  // Load and apply settings
  loadSettings();
  loadXP();
  loadGarage();
  settingsToUI();
  recalcActiveValues();
  applySettings();
  applyGarage();
  updateMenuControls();

  window.addEventListener('resize', onResize);
}

function onResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  if (composer) composer.setSize(window.innerWidth, window.innerHeight);
}

// ==========================================================================
// SKYBOX â€” Procedural starfield with nebula
// ==========================================================================
function createSkybox() {
  var c = document.createElement('canvas');
  c.width = 2048; c.height = 2048;
  var ctx = c.getContext('2d');
  var W = 2048, H = 2048;

  // RL DFH Stadium-style dusk sky with warm sunset colors
  var skyGrad = ctx.createLinearGradient(0, 0, 0, H);
  skyGrad.addColorStop(0, '#050510');
  skyGrad.addColorStop(0.15, '#0c0c24');
  skyGrad.addColorStop(0.3, '#1a1440');
  skyGrad.addColorStop(0.45, '#2d1845');
  skyGrad.addColorStop(0.55, '#4a2040');
  skyGrad.addColorStop(0.65, '#6e3535');
  skyGrad.addColorStop(0.75, '#9c5530');
  skyGrad.addColorStop(0.85, '#c08040');
  skyGrad.addColorStop(0.92, '#d4a060');
  skyGrad.addColorStop(1, '#886644');
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0, 0, W, H);

  // Stars in upper portion
  ctx.fillStyle = '#fff';
  for (var s = 0; s < 200; s++) {
    var sx = Math.random() * W, sy = Math.random() * H * 0.5;
    var sr = Math.random() * 1.5 + 0.3;
    ctx.globalAlpha = Math.random() * 0.6 + 0.2;
    ctx.beginPath(); ctx.arc(sx, sy, sr, 0, Math.PI * 2); ctx.fill();
  }
  ctx.globalAlpha = 1;

  // City building silhouettes along the horizon line
  ctx.fillStyle = '#0a0a14';
  var horizonY = H * 0.78;
  for (var b = 0; b < 60; b++) {
    var bx = (b / 60) * W - 10;
    var bw = 20 + Math.random() * 40;
    var bh = 30 + Math.random() * 120;
    ctx.fillRect(bx, horizonY - bh, bw, bh + 100);
    // Window lights
    ctx.fillStyle = 'rgba(255,220,140,0.15)';
    for (var wy = 0; wy < bh - 10; wy += 12) {
      for (var wx = 4; wx < bw - 4; wx += 8) {
        if (Math.random() > 0.4) ctx.fillRect(bx + wx, horizonY - bh + wy + 4, 3, 5);
      }
    }
    ctx.fillStyle = '#0a0a14';
  }

  // Arena bowl glow â€” warm floodlight wash reflecting upward
  var bowlGlow = ctx.createRadialGradient(W / 2, H * 0.85, 0, W / 2, H * 0.85, H * 0.5);
  bowlGlow.addColorStop(0, 'rgba(255,200,120,0.18)');
  bowlGlow.addColorStop(0.3, 'rgba(255,180,100,0.08)');
  bowlGlow.addColorStop(0.6, 'rgba(200,150,80,0.03)');
  bowlGlow.addColorStop(1, 'rgba(100,80,40,0)');
  ctx.fillStyle = bowlGlow;
  ctx.fillRect(0, 0, W, H);

  // Floodlight glows â€” bright concentrated spots
  var lightPositions = [
    [300, 250], [W - 300, 250], [300, H - 250], [W - 300, H - 250],
    [W / 2, 150], [W / 2, H - 150], [120, H / 2], [W - 120, H / 2]
  ];
  lightPositions.forEach(function(lp) {
    var lg = ctx.createRadialGradient(lp[0], lp[1], 0, lp[0], lp[1], 280);
    lg.addColorStop(0, 'rgba(255,248,230,0.5)');
    lg.addColorStop(0.1, 'rgba(255,240,210,0.3)');
    lg.addColorStop(0.3, 'rgba(255,230,180,0.1)');
    lg.addColorStop(0.6, 'rgba(255,220,160,0.03)');
    lg.addColorStop(1, 'rgba(255,220,160,0)');
    ctx.fillStyle = lg;
    ctx.fillRect(0, 0, W, H);
  });

  // Roof structure â€” faint dark beams
  ctx.strokeStyle = 'rgba(40,45,60,0.06)';
  ctx.lineWidth = 3;
  for (var r = 0; r < 12; r++) {
    var angle = (r / 12) * Math.PI * 2;
    ctx.beginPath();
    ctx.moveTo(W / 2, H / 2);
    ctx.lineTo(W / 2 + Math.cos(angle) * W, H / 2 + Math.sin(angle) * H);
    ctx.stroke();
  }

  // LED strip ring
  ctx.strokeStyle = 'rgba(255,240,200,0.06)';
  ctx.lineWidth = 10;
  ctx.beginPath();
  ctx.arc(W / 2, H / 2, 850, 0, Math.PI * 2);
  ctx.stroke();

  // Team color washes
  var orangeWash = ctx.createRadialGradient(W / 2, H - 100, 0, W / 2, H - 100, 500);
  orangeWash.addColorStop(0, 'rgba(255,100,0,0.08)');
  orangeWash.addColorStop(1, 'rgba(255,100,0,0)');
  ctx.fillStyle = orangeWash;
  ctx.fillRect(0, 0, W, H);

  var blueWash = ctx.createRadialGradient(W / 2, 100, 0, W / 2, 100, 500);
  blueWash.addColorStop(0, 'rgba(0,80,255,0.08)');
  blueWash.addColorStop(1, 'rgba(0,80,255,0)');
  ctx.fillStyle = blueWash;
  ctx.fillRect(0, 0, W, H);

  var tex = new THREE.CanvasTexture(c);
  tex.mapping = THREE.EquirectangularReflectionMapping;
  scene.background = tex;
  scene.environment = tex;
}

// ==========================================================================
// ARENA
// ==========================================================================
// Build a quarter-pipe ramp: arc in the plane of (a0Axis, a1Axis), extruded along extAxis.
// c0/c1 = arc center coords; extMin/extMax = extrusion range; angStart/angEnd = arc angles.
// Replaces the former buildRampXY (a0=0,a1=1,ext=2) and buildRampYZ (a0=1,a1=2,ext=0).
function buildRamp(c0, c1, a0Axis, a1Axis, extAxis, extMin, extMax, radius, angStart, angEnd, segs, mat) {
  var geo = new THREE.BufferGeometry();
  var pos = [], nrm = [], uv = [], idx = [];
  var v0 = [0, 0, 0], v1 = [0, 0, 0], n = [0, 0, 0];
  for (var i = 0; i <= segs; i++) {
    var t = i / segs;
    var a = angStart + t * (angEnd - angStart);
    var ca = Math.cos(a), sa = Math.sin(a);
    v0[a0Axis] = c0 + ca * radius; v0[a1Axis] = c1 + sa * radius; v0[extAxis] = extMin;
    v1[a0Axis] = c0 + ca * radius; v1[a1Axis] = c1 + sa * radius; v1[extAxis] = extMax;
    n[a0Axis] = -ca; n[a1Axis] = -sa; n[extAxis] = 0;
    pos.push(v0[0], v0[1], v0[2]); nrm.push(n[0], n[1], n[2]); uv.push(t, 0);
    pos.push(v1[0], v1[1], v1[2]); nrm.push(n[0], n[1], n[2]); uv.push(t, 1);
  }
  for (var i = 0; i < segs; i++) {
    idx.push(i*2, (i+1)*2, i*2+1, i*2+1, (i+1)*2, (i+1)*2+1);
  }
  geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
  geo.setAttribute('normal', new THREE.Float32BufferAttribute(nrm, 3));
  geo.setAttribute('uv', new THREE.Float32BufferAttribute(uv, 2));
  geo.setIndex(idx);
  return new THREE.Mesh(geo, mat);
}

function createArena() {
  arenaGroup = new THREE.Group();
  scene.add(arenaGroup);

  var st = STADIUMS[settings.stadium] || STADIUMS.standard;
  var CR = CURVE_R; // shorthand
  var cornerR = CORNER_R; // vertical corner radius (where side wall meets end wall)
  var curveSegs = 20; // smooth curves

  // --- FIELD FLOOR ---
  var fieldTex = createFieldTexture();
  var floorMat = new THREE.MeshStandardMaterial({
    map: fieldTex, roughness: 0.5, metalness: 0.05, envMapIntensity: 0.4
  });
  // Full-size floor (extends under ramps so no gaps)
  var floor = new THREE.Mesh(new THREE.PlaneGeometry(FW, FL), floorMat);
  floor.rotation.x = -Math.PI / 2;
  floor.position.y = -0.01;
  floor.receiveShadow = true;
  arenaGroup.add(floor);

  // --- WALL MATERIAL --- RL uses solid dark grey/blue walls, not transparent glass
  var wallMat = new THREE.MeshStandardMaterial({
    color: st.wallColor, roughness: 0.4, metalness: 0.6,
    side: THREE.DoubleSide, envMapIntensity: 0.3
  });
  var frameMat = new THREE.MeshStandardMaterial({ color: 0x444455, metalness: 0.9, roughness: 0.15 });

  // --- RAMP MATERIAL --- solid, matches wall color (not transparent/dark green)
  var rampMat = new THREE.MeshStandardMaterial({
    color: st.rampColor || st.wallColor, roughness: 0.35, metalness: 0.5,
    side: THREE.DoubleSide, envMapIntensity: 0.2
  });

  // --- WALLS ---
  var wallH = WH - CR * 2; // flat wall between ramps
  // Side walls
  addWall(-FW / 2, CR + wallH / 2, 0, 0.5, wallH, FL - cornerR * 2, wallMat);
  addWall(FW / 2, CR + wallH / 2, 0, 0.5, wallH, FL - cornerR * 2, wallMat);

  // (RL-style: no visible trim rails on wall edges)

  // End walls with goal cutouts
  var endWallH = WH - CR * 2;
  var sideW = FW / 2 - GW / 2;
  [-1, 1].forEach(function(endDir) {
    var zPos = endDir * FL / 2;
    // Left of goal
    addWall(-FW / 2 + sideW / 2, CR + endWallH / 2, zPos, sideW, endWallH, 0.5, wallMat);
    // Right of goal
    addWall(FW / 2 - sideW / 2, CR + endWallH / 2, zPos, sideW, endWallH, 0.5, wallMat);
    // Above goal
    addWall(0, GH + (WH - CR - GH) / 2, zPos, GW, WH - CR - GH, 0.5, wallMat);
  });

  // --- CURVED RAMPS (floor-to-wall) --- quarter-pipe transitions matching getCurveInfo physics
  var zRampMin = -FL/2 + cornerR, zRampMax = FL/2 - cornerR;
  // Left side floor ramp: arc center (-FW/2+CR, CR), arc from Ï€ to 3Ï€/2
  arenaGroup.add(buildRamp(-FW/2 + CR, CR, 0, 1, 2, zRampMin, zRampMax, CR, Math.PI, Math.PI * 1.5, curveSegs, rampMat));
  // Right side floor ramp: arc center (FW/2-CR, CR), arc from -Ï€/2 to 0
  arenaGroup.add(buildRamp(FW/2 - CR, CR, 0, 1, 2, zRampMin, zRampMax, CR, -Math.PI/2, 0, curveSegs, rampMat));
  // End floor ramps (left and right of goal openings)
  var endXMin = -FW/2 + cornerR, endXMax = FW/2 - cornerR;
  if (-GW/2 - endXMin > 0.5) {
    // Front end ramps (z = FL/2): arc in YZ plane, angles Ï€/2 to Ï€
    arenaGroup.add(buildRamp(CR, FL/2 - CR, 1, 2, 0, endXMin, -GW/2, CR, Math.PI/2, Math.PI, curveSegs, rampMat));
    arenaGroup.add(buildRamp(CR, FL/2 - CR, 1, 2, 0, GW/2, endXMax, CR, Math.PI/2, Math.PI, curveSegs, rampMat));
    // Back end ramps (z = -FL/2): arc in YZ plane, angles Ï€ to 3Ï€/2
    arenaGroup.add(buildRamp(CR, -FL/2 + CR, 1, 2, 0, endXMin, -GW/2, CR, Math.PI, Math.PI * 1.5, curveSegs, rampMat));
    arenaGroup.add(buildRamp(CR, -FL/2 + CR, 1, 2, 0, GW/2, endXMax, CR, Math.PI, Math.PI * 1.5, curveSegs, rampMat));
  }

  // --- CURVED RAMPS (wall-to-ceiling) ---
  // Left ceiling ramp: arc center (-FW/2+CR, WH-CR), arc from Ï€/2 to Ï€
  arenaGroup.add(buildRamp(-FW/2 + CR, WH - CR, 0, 1, 2, zRampMin, zRampMax, CR, Math.PI/2, Math.PI, curveSegs, rampMat));
  // Right ceiling ramp: arc center (FW/2-CR, WH-CR), arc from 0 to Ï€/2
  arenaGroup.add(buildRamp(FW/2 - CR, WH - CR, 0, 1, 2, zRampMin, zRampMax, CR, 0, Math.PI/2, curveSegs, rampMat));
  // Front ceiling ramp (full width)
  arenaGroup.add(buildRamp(WH - CR, FL/2 - CR, 1, 2, 0, endXMin, endXMax, CR, 0, Math.PI/2, curveSegs, rampMat));
  // Back ceiling ramp (full width)
  arenaGroup.add(buildRamp(WH - CR, -FL/2 + CR, 1, 2, 0, endXMin, endXMax, CR, -Math.PI/2, 0, curveSegs, rampMat));

  // --- ROUNDED CORNERS --- (RL-style smooth curved walls where side meets end)
  var cornerPositions = [
    { x: -FW/2 + cornerR, z: -FL/2 + cornerR, rotY: 0 },
    { x: FW/2 - cornerR, z: -FL/2 + cornerR, rotY: Math.PI / 2 },
    { x: FW/2 - cornerR, z: FL/2 - cornerR, rotY: Math.PI },
    { x: -FW/2 + cornerR, z: FL/2 - cornerR, rotY: -Math.PI / 2 }
  ];
  cornerPositions.forEach(function(cp) {
    var cornerShape = new THREE.Shape();
    cornerShape.moveTo(0, 0);
    cornerShape.absarc(0, 0, cornerR, Math.PI, Math.PI * 1.5, false);
    cornerShape.lineTo(0, 0);
    var extrudeSettings = { steps: 1, depth: WH, bevelEnabled: false };
    var cornerGeo = new THREE.ExtrudeGeometry(cornerShape, extrudeSettings);
    var corner = new THREE.Mesh(cornerGeo, wallMat);
    corner.position.set(cp.x, 0, cp.z);
    corner.rotation.set(-Math.PI / 2, 0, cp.rotY);
    arenaGroup.add(corner);
  });

  // --- CEILING ---
  var ceilMat = new THREE.MeshStandardMaterial({
    color: st.ceilColor || 0x141618, roughness: 0.6, metalness: 0.3, side: THREE.DoubleSide
  });
  var ceil = new THREE.Mesh(new THREE.PlaneGeometry(FW - CR * 2, FL - CR * 2), ceilMat);
  ceil.rotation.x = Math.PI / 2;
  ceil.position.y = WH;
  arenaGroup.add(ceil);

  // --- GOALS ---
  createGoal(FL / 2, 0xff6600);
  createGoal(-FL / 2, 0x0066ff);

  // --- STADIUM STANDS ---
  createStands(st);

  // --- EDGE GLOW LINES --- (RL-style coloured strips on the floor edges)
  addEdgeLine(-FW/2, 0.05, -FL/2 + cornerR, -FW/2, 0.05, FL/2 - cornerR, 0x5599ff);
  addEdgeLine(FW/2, 0.05, -FL/2 + cornerR, FW/2, 0.05, FL/2 - cornerR, 0x5599ff);
  addEdgeLine(-FW/2 + cornerR, 0.05, FL/2, FW/2 - cornerR, 0.05, FL/2, 0xff7700);
  addEdgeLine(-FW/2 + cornerR, 0.05, -FL/2, FW/2 - cornerR, 0.05, -FL/2, 0x2266ff);

  // --- LED AD BOARDS --- (glowing strips above ramp line)
  var ledBoardMat = new THREE.MeshBasicMaterial({ color: 0x334466, transparent: true, opacity: 0.7 });
  [-1, 1].forEach(function(side) {
    var board = new THREE.Mesh(new THREE.PlaneGeometry(FL - cornerR * 2, 2.0), ledBoardMat);
    board.rotation.y = side > 0 ? -Math.PI / 2 : Math.PI / 2;
    board.position.set(side * (FW / 2 - 0.05), CR + 1.5, 0);
    arenaGroup.add(board);
  });
  // End LED boards (team-coloured)
  var orangeBoardMat = new THREE.MeshBasicMaterial({ color: 0x884400, transparent: true, opacity: 0.6 });
  var blueBoardMat = new THREE.MeshBasicMaterial({ color: 0x003388, transparent: true, opacity: 0.6 });
  var endBoardW = (FW / 2 - GW / 2 - cornerR);
  if (endBoardW > 2) {
    [-1, 1].forEach(function(sideX) {
      var oB = new THREE.Mesh(new THREE.PlaneGeometry(endBoardW, 2.0), orangeBoardMat);
      oB.position.set(sideX * (GW / 2 + endBoardW / 2), CR + 1.5, FL / 2 - 0.05);
      oB.rotation.y = Math.PI; arenaGroup.add(oB);
      var bB = new THREE.Mesh(new THREE.PlaneGeometry(endBoardW, 2.0), blueBoardMat);
      bB.position.set(sideX * (GW / 2 + endBoardW / 2), CR + 1.5, -FL / 2 + 0.05);
      arenaGroup.add(bB);
    });
  }

  // --- WALL GLOW STRIPS --- (RL has subtle coloured lighting at wall base)
  var wallGlowMat = new THREE.MeshBasicMaterial({ color: 0x6688bb, transparent: true, opacity: 0.08 });
  [-1, 1].forEach(function(side) {
    var glow = new THREE.Mesh(new THREE.PlaneGeometry(2.5, FL - cornerR * 2), wallGlowMat);
    glow.rotation.x = -Math.PI / 2;
    glow.position.set(side * (FW / 2 - 1.2), 0.02, 0);
    arenaGroup.add(glow);
  });
}

function createStands(st) {
  var standMat = new THREE.MeshStandardMaterial({ color: st.standColor || 0x1a1a2e, roughness: 0.8, metalness: 0.2 });
  var standH = 15, standD = 20, standY = WH / 2;

  // Side stands with crowd texture (single textured plane, no individual meshes)
  [-1, 1].forEach(function(side) {
    var stand = new THREE.Mesh(new THREE.BoxGeometry(standD, standH, FL + 20), standMat);
    stand.position.set(side * (FW / 2 + standD / 2 + 1), standY + standH / 2 - 5, 0);
    arenaGroup.add(stand);

    // Crowd panel â€” single textured plane instead of 200+ dots
    var crowdTex = createCrowdTexture(st);
    var crowdMat = new THREE.MeshBasicMaterial({ map: crowdTex, transparent: true, opacity: 0.85 });
    var crowdPlane = new THREE.Mesh(new THREE.PlaneGeometry(standH * 0.8, FL - 12), crowdMat);
    crowdPlane.rotation.y = side > 0 ? -Math.PI / 2 : Math.PI / 2;
    crowdPlane.position.set(side * (FW / 2 + 3), standY + 2, 0);
    arenaGroup.add(crowdPlane);
  });

  // End stands
  [-1, 1].forEach(function(endDir) {
    var endStand = new THREE.Mesh(new THREE.BoxGeometry(FW - 10, standH * 0.8, standD * 0.7), standMat);
    endStand.position.set(0, standY + standH / 2 - 8, endDir * (FL / 2 + GD + standD * 0.35 + 2));
    arenaGroup.add(endStand);

    var endCrowdTex = createCrowdTexture(st);
    var endCrowdPlane = new THREE.Mesh(
      new THREE.PlaneGeometry(FW - 16, standH * 0.5),
      new THREE.MeshBasicMaterial({ map: endCrowdTex, transparent: true, opacity: 0.85 })
    );
    endCrowdPlane.rotation.y = endDir > 0 ? Math.PI : 0;
    endCrowdPlane.position.set(0, standY, endDir * (FL / 2 + GD + 5));
    arenaGroup.add(endCrowdPlane);
  });
}

function createCrowdTexture(st) {
  var c = document.createElement('canvas');
  c.width = 512; c.height = 256;
  var ctx = c.getContext('2d');

  // Dark background with slight gradient (seats)
  var seatGrad = ctx.createLinearGradient(0, 0, 0, 256);
  seatGrad.addColorStop(0, '#0c0c1e');
  seatGrad.addColorStop(0.5, '#0e0e22');
  seatGrad.addColorStop(1, '#08081a');
  ctx.fillStyle = seatGrad;
  ctx.fillRect(0, 0, 512, 256);

  // Seat row lines
  ctx.strokeStyle = 'rgba(40,40,60,0.3)';
  ctx.lineWidth = 1;
  for (var row = 0; row < 256; row += 18) {
    ctx.beginPath();
    ctx.moveTo(0, row);
    ctx.lineTo(512, row);
    ctx.stroke();
  }

  var colors1 = st.crowdColor1 ? '#' + st.crowdColor1.toString(16).padStart(6, '0') : '#ff6600';
  var colors2 = st.crowdColor2 ? '#' + st.crowdColor2.toString(16).padStart(6, '0') : '#0066ff';
  var misc = ['#ee9999','#99ee99','#9999ee','#eeee99','#ee99ee','#dddddd','#cc8855','#55aacc'];

  // Crowd people â€” varied sizes in rows
  for (var i = 0; i < 600; i++) {
    var x = Math.random() * 512;
    var y = Math.random() * 256;
    // Pick team-biased colors (more of the home team colors)
    var roll = Math.random();
    if (roll < 0.35) ctx.fillStyle = colors1;
    else if (roll < 0.65) ctx.fillStyle = colors2;
    else ctx.fillStyle = misc[Math.floor(Math.random() * misc.length)];

    // Head (circle) + body (small rect)
    var size = 1.5 + Math.random() * 1.5;
    ctx.beginPath();
    ctx.arc(x, y - size * 0.3, size, 0, Math.PI * 2);
    ctx.fill();
    // Tiny body below
    ctx.fillRect(x - size * 0.5, y + size * 0.3, size, size * 1.2);
  }

  // Occasional bright signs/banners
  for (var s = 0; s < 8; s++) {
    ctx.fillStyle = Math.random() > 0.5 ? 'rgba(255,255,255,0.15)' : 'rgba(255,200,0,0.12)';
    ctx.fillRect(Math.random() * 480, Math.random() * 230, 15 + Math.random() * 20, 4 + Math.random() * 4);
  }

  return new THREE.CanvasTexture(c);
}

function addWall(x, y, z, w, h, d, mat) {
  var mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
  mesh.position.set(x, y, z);
  mesh.receiveShadow = true;
  arenaGroup.add(mesh);
}

function createGoal(zPos, color) {
  var dir = zPos > 0 ? 1 : -1;
  var frameMat = new THREE.MeshPhysicalMaterial({
    color: color, metalness: 0.85, roughness: 0.15,
    emissive: color, emissiveIntensity: 0.4,
    clearcoat: 0.8, clearcoatRoughness: 0.1
  });

  // Goal posts (thicker, more prominent)
  var postGeo = new THREE.CylinderGeometry(0.45, 0.45, GH, 12);
  var leftPost = new THREE.Mesh(postGeo, frameMat);
  leftPost.position.set(-GW / 2, GH / 2, zPos);
  leftPost.castShadow = true;
  arenaGroup.add(leftPost);
  var rightPost = new THREE.Mesh(postGeo, frameMat);
  rightPost.position.set(GW / 2, GH / 2, zPos);
  rightPost.castShadow = true;
  arenaGroup.add(rightPost);

  // Crossbar
  var barGeo = new THREE.CylinderGeometry(0.45, 0.45, GW + 0.9, 12);
  var crossbar = new THREE.Mesh(barGeo, frameMat);
  crossbar.rotation.z = Math.PI / 2;
  crossbar.position.set(0, GH, zPos);
  crossbar.castShadow = true;
  arenaGroup.add(crossbar);

  // Back posts (goal depth frame)
  var backPostGeo = new THREE.CylinderGeometry(0.25, 0.25, GH, 8);
  var bpL = new THREE.Mesh(backPostGeo, frameMat);
  bpL.position.set(-GW / 2, GH / 2, zPos + dir * GD);
  arenaGroup.add(bpL);
  var bpR = new THREE.Mesh(backPostGeo, frameMat);
  bpR.position.set(GW / 2, GH / 2, zPos + dir * GD);
  arenaGroup.add(bpR);

  // Top back bar
  var topBackBar = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.25, GW, 8), frameMat);
  topBackBar.rotation.z = Math.PI / 2;
  topBackBar.position.set(0, GH, zPos + dir * GD);
  arenaGroup.add(topBackBar);

  // Depth bars connecting front to back
  var depthBarGeo = new THREE.CylinderGeometry(0.2, 0.2, GD, 8);
  [-1, 1].forEach(function(side) {
    var depthTop = new THREE.Mesh(depthBarGeo, frameMat);
    depthTop.rotation.x = Math.PI / 2;
    depthTop.position.set(side * GW / 2, GH, zPos + dir * GD / 2);
    arenaGroup.add(depthTop);
    var depthBot = new THREE.Mesh(depthBarGeo, frameMat);
    depthBot.rotation.x = Math.PI / 2;
    depthBot.position.set(side * GW / 2, 0.2, zPos + dir * GD / 2);
    arenaGroup.add(depthBot);
  });

  // Goal net â€” RL-style with canvas texture for net pattern
  var netTex = createNetTexture(color);
  var netMat = new THREE.MeshBasicMaterial({
    map: netTex, transparent: true, opacity: 0.35, side: THREE.DoubleSide,
    depthWrite: false
  });

  // Back net
  var backNet = new THREE.Mesh(new THREE.PlaneGeometry(GW, GH, 1, 1), netMat);
  backNet.position.set(0, GH / 2, zPos + dir * GD);
  arenaGroup.add(backNet);

  // Side nets
  var sideNetL = new THREE.Mesh(new THREE.PlaneGeometry(GD, GH, 1, 1), netMat);
  sideNetL.rotation.y = Math.PI / 2;
  sideNetL.position.set(-GW / 2, GH / 2, zPos + dir * GD / 2);
  arenaGroup.add(sideNetL);
  var sideNetR = new THREE.Mesh(new THREE.PlaneGeometry(GD, GH, 1, 1), netMat);
  sideNetR.rotation.y = Math.PI / 2;
  sideNetR.position.set(GW / 2, GH / 2, zPos + dir * GD / 2);
  arenaGroup.add(sideNetR);

  // Top net
  var topNet = new THREE.Mesh(new THREE.PlaneGeometry(GW, GD, 1, 1), netMat);
  topNet.rotation.x = Math.PI / 2;
  topNet.position.set(0, GH, zPos + dir * GD / 2);
  arenaGroup.add(topNet);

  // Goal floor highlight â€” bright team-colored glow (RL-style)
  var goalFloorMat = new THREE.MeshBasicMaterial({
    color: color, transparent: true, opacity: 0.15, side: THREE.DoubleSide
  });
  var goalFloor = new THREE.Mesh(new THREE.PlaneGeometry(GW, GD), goalFloorMat);
  goalFloor.rotation.x = -Math.PI / 2;
  goalFloor.position.set(0, 0.03, zPos + dir * GD / 2);
  arenaGroup.add(goalFloor);

  // Goal back wall glow â€” solid team color panel behind net
  var goalBackMat = new THREE.MeshBasicMaterial({
    color: color, transparent: true, opacity: 0.08, side: THREE.DoubleSide
  });
  var goalBack = new THREE.Mesh(new THREE.PlaneGeometry(GW, GH), goalBackMat);
  goalBack.position.set(0, GH / 2, zPos + dir * (GD - 0.2));
  arenaGroup.add(goalBack);

  // Goal line on the field (thick colored line at the mouth)
  var goalLineMat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.7 });
  var goalLine = new THREE.Mesh(new THREE.PlaneGeometry(GW + 2, 0.5), goalLineMat);
  goalLine.rotation.x = -Math.PI / 2;
  goalLine.position.set(0, 0.04, zPos);
  arenaGroup.add(goalLine);

  // Goal mouth glow strip â€” bright line on ground at goal entrance
  var mouthGlowMat = new THREE.MeshBasicMaterial({
    color: color, transparent: true, opacity: 0.25
  });
  var mouthGlow = new THREE.Mesh(new THREE.PlaneGeometry(GW, 2), mouthGlowMat);
  mouthGlow.rotation.x = -Math.PI / 2;
  mouthGlow.position.set(0, 0.02, zPos + dir * 1);
  arenaGroup.add(mouthGlow);
}

function createNetTexture(teamColor) {
  var c = document.createElement('canvas');
  c.width = 256; c.height = 256;
  var ctx = c.getContext('2d');

  // Transparent background
  ctx.clearRect(0, 0, 256, 256);

  // Net grid pattern â€” diamond/hex pattern like RL
  var r = (teamColor >> 16) & 0xff;
  var g = (teamColor >> 8) & 0xff;
  var b = teamColor & 0xff;
  ctx.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',0.7)';
  ctx.lineWidth = 1.5;

  // Diamond pattern
  var spacing = 16;
  for (var y = 0; y < 256 + spacing; y += spacing) {
    for (var x = 0; x < 256 + spacing; x += spacing) {
      var offsetX = (Math.floor(y / spacing) % 2) * (spacing / 2);
      ctx.beginPath();
      ctx.moveTo(x + offsetX, y - spacing / 2);
      ctx.lineTo(x + offsetX + spacing / 2, y);
      ctx.lineTo(x + offsetX, y + spacing / 2);
      ctx.lineTo(x + offsetX - spacing / 2, y);
      ctx.closePath();
      ctx.stroke();
    }
  }

  // Subtle white highlight
  ctx.strokeStyle = 'rgba(255,255,255,0.15)';
  ctx.lineWidth = 0.5;
  for (var y2 = 0; y2 < 256 + spacing; y2 += spacing) {
    for (var x2 = 0; x2 < 256 + spacing; x2 += spacing) {
      var ox2 = (Math.floor(y2 / spacing) % 2) * (spacing / 2);
      ctx.beginPath();
      ctx.moveTo(x2 + ox2, y2 - spacing / 2);
      ctx.lineTo(x2 + ox2 + spacing / 2, y2);
      ctx.lineTo(x2 + ox2, y2 + spacing / 2);
      ctx.lineTo(x2 + ox2 - spacing / 2, y2);
      ctx.closePath();
      ctx.stroke();
    }
  }

  var tex = new THREE.CanvasTexture(c);
  tex.wrapS = THREE.RepeatWrapping;
  tex.wrapT = THREE.RepeatWrapping;
  tex.repeat.set(3, 2);
  return tex;
}

function addEdgeLine(x1, y1, z1, x2, y2, z2, color) {
  var geo = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(x1, y1 + 0.05, z1),
    new THREE.Vector3(x2, y2 + 0.05, z2)
  ]);
  var mat = new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: 0.5 });
  arenaGroup.add(new THREE.Line(geo, mat));
}

function createFieldTexture() {
  var c = document.createElement('canvas');
  c.width = 2048; c.height = 3072;
  var ctx = c.getContext('2d');
  var W = c.width, H = c.height;

  // --- SPLIT FLOOR HALVES (RL blue/orange team colors) ---
  // Top half = blue team (AI/negative Z side)
  ctx.fillStyle = '#0a1428';
  ctx.fillRect(0, 0, W, H / 2);
  // Bottom half = orange team (player/positive Z side)
  ctx.fillStyle = '#1e0d00';
  ctx.fillRect(0, H / 2, W, H / 2);

  // --- MOW STRIPES (subtle per-half color variation) ---
  var stripeH = 128;
  for (var i = 0; i < H / 2; i += stripeH) {
    ctx.fillStyle = (i / stripeH) % 2 === 0 ? 'rgba(20,60,100,0.18)' : 'rgba(10,30,60,0.18)';
    ctx.fillRect(0, i, W, stripeH);
  }
  for (var j = 0; j < H / 2; j += stripeH) {
    ctx.fillStyle = (j / stripeH) % 2 === 0 ? 'rgba(100,50,10,0.18)' : 'rgba(60,25,5,0.18)';
    ctx.fillRect(0, H / 2 + j, W, stripeH);
  }

  // --- WHITE FIELD MARKINGS ---
  ctx.strokeStyle = 'rgba(255,255,255,0.92)';
  ctx.lineWidth = 7;

  var mx = 40, my = 40;
  var fw = W - mx * 2, fh = H - my * 2;

  // Border
  ctx.strokeRect(mx, my, fw, fh);

  // Center line
  ctx.beginPath();
  ctx.moveTo(mx, H / 2);
  ctx.lineTo(W - mx, H / 2);
  ctx.stroke();

  // Center circle
  ctx.lineWidth = 7;
  ctx.beginPath();
  ctx.arc(W / 2, H / 2, 280, 0, Math.PI * 2);
  ctx.stroke();

  // Center dot
  ctx.fillStyle = 'rgba(255,255,255,0.92)';
  ctx.beginPath();
  ctx.arc(W / 2, H / 2, 14, 0, Math.PI * 2);
  ctx.fill();

  // Goal boxes
  var gw = (GW / FW) * fw;
  var gdSmall = 160;
  ctx.strokeStyle = 'rgba(255,255,255,0.92)';
  ctx.lineWidth = 6;
  ctx.strokeRect(W / 2 - gw / 2, my, gw, gdSmall);
  ctx.strokeRect(W / 2 - gw / 2, H - my - gdSmall, gw, gdSmall);

  // Corner arcs
  ctx.strokeStyle = 'rgba(255,255,255,0.75)';
  ctx.lineWidth = 6;
  [[mx, my, 0], [W - mx, my, Math.PI / 2], [W - mx, H - my, Math.PI], [mx, H - my, -Math.PI / 2]].forEach(function(corner) {
    ctx.beginPath();
    ctx.arc(corner[0], corner[1], 70, corner[2], corner[2] + Math.PI / 2);
    ctx.stroke();
  });

  // Kickoff marks (4 diagonal positions)
  var kickoffDist = 340;
  ctx.lineWidth = 5;
  [[-1,-1],[1,-1],[-1,1],[1,1]].forEach(function(k) {
    var kx = W / 2 + k[0] * kickoffDist * 0.55;
    var ky = H / 2 + k[1] * kickoffDist;
    ctx.strokeStyle = 'rgba(255,255,255,0.75)';
    ctx.beginPath();
    ctx.arc(kx, ky, 14, 0, Math.PI * 2);
    ctx.stroke();
    ctx.fillStyle = 'rgba(255,255,255,0.55)';
    ctx.beginPath();
    ctx.arc(kx, ky, 6, 0, Math.PI * 2);
    ctx.fill();
  });

  // --- BOOST PAD INDICATORS ---
  // Large boost pads (6 total â€” 3 per half, symmetric)
  var largePads = [
    [W * 0.25, H * 0.18], [W * 0.75, H * 0.18],
    [W * 0.08, H * 0.5],  [W * 0.92, H * 0.5],
    [W * 0.25, H * 0.82], [W * 0.75, H * 0.82]
  ];
  largePads.forEach(function(p) {
    // Outer gold ring
    ctx.strokeStyle = 'rgba(255,210,0,0.85)';
    ctx.lineWidth = 8;
    ctx.beginPath();
    ctx.arc(p[0], p[1], 44, 0, Math.PI * 2);
    ctx.stroke();
    // Inner fill
    ctx.fillStyle = 'rgba(255,190,0,0.22)';
    ctx.beginPath();
    ctx.arc(p[0], p[1], 36, 0, Math.PI * 2);
    ctx.fill();
  });

  // Small boost pads (4 total â€” near center)
  var smallPads = [
    [W * 0.38, H * 0.35], [W * 0.62, H * 0.35],
    [W * 0.38, H * 0.65], [W * 0.62, H * 0.65]
  ];
  smallPads.forEach(function(p) {
    ctx.strokeStyle = 'rgba(220,170,0,0.55)';
    ctx.lineWidth = 5;
    ctx.beginPath();
    ctx.arc(p[0], p[1], 26, 0, Math.PI * 2);
    ctx.stroke();
    ctx.fillStyle = 'rgba(200,150,0,0.12)';
    ctx.beginPath();
    ctx.arc(p[0], p[1], 20, 0, Math.PI * 2);
    ctx.fill();
  });

  var tex = new THREE.CanvasTexture(c);
  tex.anisotropy = 8;
  return tex;
}

// ==========================================================================
// BALL
// ==========================================================================
function createBall() {
  // RL ball â€” bright white with subtle golden emissive, high reflectivity
  var geo = new THREE.SphereGeometry(BR, 32, 32);
  var mat = new THREE.MeshPhysicalMaterial({
    color: 0xf0f0f4, roughness: 0.04, metalness: 0.1,
    emissive: 0xffcc66, emissiveIntensity: 0.08,
    envMapIntensity: 2.2,
    clearcoat: 0.9, clearcoatRoughness: 0.02,
    reflectivity: 1.0
  });
  ball = new THREE.Mesh(geo, mat);
  ball.castShadow = true;
  scene.add(ball);

  // Ball ground indicator (RL-style shadow circle showing where ball will land)
  var indicatorGeo = new THREE.RingGeometry(BR * 0.6, BR * 1.1, 32);
  var indicatorMat = new THREE.MeshBasicMaterial({
    color: 0xffffff, transparent: true, opacity: 0.2, side: THREE.DoubleSide,
    depthWrite: false
  });
  ballIndicator = new THREE.Mesh(indicatorGeo, indicatorMat);
  ballIndicator.rotation.x = -Math.PI / 2;
  ballIndicator.position.y = 0.08;
  scene.add(ballIndicator);

  // Hexagon/pentagon panel seam pattern (RL ball has visible panel seams)
  var wireGeo = new THREE.IcosahedronGeometry(BR * 1.004, 1);
  var wireMat = new THREE.MeshBasicMaterial({
    color: 0x222222, wireframe: true, transparent: true, opacity: 0.15
  });
  var wireOverlay = new THREE.Mesh(wireGeo, wireMat);
  ball.add(wireOverlay);

  // Additional finer detail wireframe
  var wireGeo2 = new THREE.IcosahedronGeometry(BR * 1.002, 2);
  var wireMat2 = new THREE.MeshBasicMaterial({
    color: 0x444444, wireframe: true, transparent: true, opacity: 0.06
  });
  ball.add(new THREE.Mesh(wireGeo2, wireMat2));

  // Dynamic point light on ball â€” brighter, RL ball glows
  ballGlow = new THREE.PointLight(0xffdd88, 2.0, 30);
  ball.add(ballGlow);

  // Inner energy glow (RL ball has a golden inner energy)
  var glowGeo = new THREE.SphereGeometry(BR * 1.15, 24, 24);
  var glowMat = new THREE.MeshBasicMaterial({
    color: 0xffcc44, transparent: true, opacity: 0.12, side: THREE.BackSide
  });
  var glowSphere = new THREE.Mesh(glowGeo, glowMat);
  ball.add(glowSphere);

  // Outer haze â€” RL ball has a visible glow aura
  var hazeMat = new THREE.MeshBasicMaterial({
    color: 0xffee88, transparent: true, opacity: 0.05, side: THREE.BackSide,
    depthWrite: false
  });
  var haze = new THREE.Mesh(new THREE.SphereGeometry(BR * 1.5, 16, 16), hazeMat);
  ball.add(haze);
}

// ==========================================================================
// CARS
// ==========================================================================
function createCar(mainColor, accentColor, bodyType) {
  var group = new THREE.Group();
  bodyType = bodyType || 'octane';

  // Shared materials
  var bodyMat = new THREE.MeshPhysicalMaterial({
    color: mainColor, metalness: 0.7, roughness: 0.08,
    envMapIntensity: 2.5, clearcoat: 1.0, clearcoatRoughness: 0.04,
    reflectivity: 1.0
  });
  var cabMat = new THREE.MeshPhysicalMaterial({
    color: 0x080818, metalness: 0.3, roughness: 0.02,
    envMapIntensity: 3.0, clearcoat: 1.0, clearcoatRoughness: 0.02,
    transmission: 0.3, thickness: 0.5
  });
  var bumpMat = new THREE.MeshPhysicalMaterial({
    color: accentColor, metalness: 0.6, roughness: 0.25,
    clearcoat: 0.8, clearcoatRoughness: 0.15
  });
  var skirtMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.9, roughness: 0.2 });
  var spoilerMat = new THREE.MeshPhysicalMaterial({
    color: accentColor, metalness: 0.7, roughness: 0.2,
    clearcoat: 0.9, clearcoatRoughness: 0.1
  });

  // Body shape parameters per type
  var bp = {
    octane:    { bh: 0.55, bl: 0.95, cabH: 0.38, cabW: 0.82, cabZ: -0.04, hoodH: 0.25, hoodZ: 0.32, hoodSlope: -0.2, noseH: 0.2, spoilerH: 1.2, spoilerW: 1.15, flareW: 0.3 },
    dominus:   { bh: 0.38, bl: 1.05, cabH: 0.26, cabW: 0.9,  cabZ: -0.08, hoodH: 0.16, hoodZ: 0.35, hoodSlope: -0.1, noseH: 0.12, spoilerH: 0.85, spoilerW: 1.2, flareW: 0.2 },
    breakout:  { bh: 0.42, bl: 1.0,  cabH: 0.30, cabW: 0.78, cabZ: -0.1,  hoodH: 0.3,  hoodZ: 0.28, hoodSlope: -0.35, noseH: 0.14, spoilerH: 1.0, spoilerW: 1.1, flareW: 0.25 },
    merc:      { bh: 0.7,  bl: 0.85, cabH: 0.55, cabW: 0.88, cabZ: 0.0,   hoodH: 0.2,  hoodZ: 0.28, hoodSlope: -0.05, noseH: 0.25, spoilerH: 1.5, spoilerW: 0.9, flareW: 0.35 },
    hotshot:   { bh: 0.45, bl: 1.0,  cabH: 0.28, cabW: 0.75, cabZ: -0.12, hoodH: 0.22, hoodZ: 0.34, hoodSlope: -0.25, noseH: 0.16, spoilerH: 1.1, spoilerW: 1.3, flareW: 0.28 },
    batmobile: { bh: 0.30, bl: 1.1,  cabH: 0.18, cabW: 0.7,  cabZ: -0.05, hoodH: 0.12, hoodZ: 0.38, hoodSlope: -0.08, noseH: 0.1, spoilerH: 0.7, spoilerW: 1.35, flareW: 0.22 }
  };
  var b = bp[bodyType] || bp.octane;

  // Main body
  var body = new THREE.Mesh(new THREE.BoxGeometry(CW, CH * b.bh, CL * b.bl), bodyMat);
  body.position.y = CH * 0.28;
  body.castShadow = true;
  body._isBody = true;
  group.add(body);

  // Hood
  var hood = new THREE.Mesh(new THREE.BoxGeometry(CW * 0.96, CH * b.hoodH, CL * 0.3), bodyMat);
  hood.position.set(0, CH * 0.48, CL * b.hoodZ);
  hood.rotation.x = b.hoodSlope;
  hood.castShadow = true;
  hood._isBody = true;
  group.add(hood);

  // Nose
  var noseMat = new THREE.MeshPhysicalMaterial({
    color: mainColor, metalness: 0.8, roughness: 0.15,
    clearcoat: 1.0, clearcoatRoughness: 0.1
  });
  var nose = new THREE.Mesh(new THREE.BoxGeometry(CW * 0.9, CH * b.noseH, CL * 0.15), noseMat);
  nose.position.set(0, CH * 0.12, CL * 0.48);
  nose._isBody = true;
  group.add(nose);

  // Cabin
  var cab = new THREE.Mesh(new THREE.BoxGeometry(CW * b.cabW, CH * b.cabH, CL * 0.33), cabMat);
  cab.position.set(0, CH * 0.72, CL * b.cabZ);
  cab.castShadow = true;
  group.add(cab);

  // Front bumper
  var bump = new THREE.Mesh(new THREE.BoxGeometry(CW * 1.06, CH * 0.28, CL * 0.1), bumpMat);
  bump.position.set(0, CH * 0.14, CL * 0.48);
  bump._isAccent = true;
  group.add(bump);

  // Side skirts
  [-1, 1].forEach(function(side) {
    var skirt = new THREE.Mesh(new THREE.BoxGeometry(0.18, CH * 0.22, CL * 0.82), skirtMat);
    skirt.position.set(side * CW * 0.53, CH * 0.11, 0);
    group.add(skirt);
  });

  // Fender flares
  [-1, 1].forEach(function(side) {
    [1, -1].forEach(function(fwd) {
      var flare = new THREE.Mesh(new THREE.BoxGeometry(b.flareW, CH * 0.35, CL * 0.22), bodyMat);
      flare.position.set(side * CW * 0.55, CH * 0.28, fwd * CL * 0.3);
      flare._isBody = true;
      group.add(flare);
    });
  });

  // Rear spoiler
  var spoilerWing = new THREE.Mesh(new THREE.BoxGeometry(CW * b.spoilerW, 0.1, 0.6), spoilerMat);
  spoilerWing.position.set(0, CH * b.spoilerH, -CL * 0.36);
  spoilerWing.castShadow = true;
  spoilerWing._isAccent = true;
  group.add(spoilerWing);
  [-1, 1].forEach(function(side) {
    var support = new THREE.Mesh(new THREE.BoxGeometry(0.14, CH * 0.45, 0.14), skirtMat);
    support.position.set(side * CW * 0.42, CH * (b.spoilerH - 0.22), -CL * 0.36);
    group.add(support);
  });

  // Batmobile: add side fins
  if (bodyType === 'batmobile') {
    [-1, 1].forEach(function(side) {
      var fin = new THREE.Mesh(new THREE.BoxGeometry(0.08, CH * 0.4, CL * 0.35), skirtMat);
      fin.position.set(side * CW * 0.58, CH * 0.5, -CL * 0.15);
      group.add(fin);
    });
  }

  // Merc: wider cab with roof rack look
  if (bodyType === 'merc') {
    var rack = new THREE.Mesh(new THREE.BoxGeometry(CW * 0.7, 0.06, CL * 0.25), skirtMat);
    rack.position.set(0, CH * 1.02, 0);
    group.add(rack);
  }

  // Hotshot: hood scoop
  if (bodyType === 'hotshot') {
    var scoop = new THREE.Mesh(new THREE.BoxGeometry(CW * 0.25, CH * 0.15, CL * 0.15), bumpMat);
    scoop.position.set(0, CH * 0.62, CL * 0.2);
    scoop._isAccent = true;
    group.add(scoop);
  }

  // Headlights
  var headlightMat = new THREE.MeshStandardMaterial({
    color: 0xffffff, emissive: 0xffffee, emissiveIntensity: 1.0
  });
  var headlightLens = new THREE.MeshPhysicalMaterial({
    color: 0xffffff, transmission: 0.8, thickness: 0.2,
    roughness: 0.0, clearcoat: 1.0
  });
  [-1, 1].forEach(function(side) {
    var hl = new THREE.Mesh(new THREE.SphereGeometry(0.22, 10, 10), headlightMat);
    hl.position.set(side * CW * 0.4, CH * 0.32, CL * 0.5);
    group.add(hl);
    var lens = new THREE.Mesh(new THREE.SphereGeometry(0.28, 10, 10), headlightLens);
    lens.position.copy(hl.position);
    group.add(lens);
  });

  // Taillights
  var tailMat = new THREE.MeshStandardMaterial({
    color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.8
  });
  [-1, 1].forEach(function(side) {
    var tl = new THREE.Mesh(new THREE.BoxGeometry(CW * 0.22, 0.18, 0.1), tailMat);
    tl.position.set(side * CW * 0.35, CH * 0.32, -CL * 0.5);
    group.add(tl);
  });

  // Wheels â€” high detail with alloy rims (grouped for spin animation)
  var wheelGeo = new THREE.CylinderGeometry(0.55, 0.55, 0.45, 16);
  var wheelMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.7, metalness: 0.3 });
  var rimMat = new THREE.MeshPhysicalMaterial({
    color: 0xdddddd, metalness: 0.95, roughness: 0.05,
    clearcoat: 1.0, clearcoatRoughness: 0.05
  });
  var rimSpokeGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.47, 5);
  group.userData.wheels = [];
  [[-1, 1], [1, 1], [-1, -1], [1, -1]].forEach(function(p) {
    var wheelGroup = new THREE.Group();
    wheelGroup.position.set(p[0] * (CW / 2 + 0.18), 0.08, p[1] * CL * 0.33);

    var w = new THREE.Mesh(wheelGeo, wheelMat);
    w.rotation.z = Math.PI / 2;
    w.castShadow = true;
    wheelGroup.add(w);
    var rim = new THREE.Mesh(rimSpokeGeo, rimMat);
    rim.rotation.z = Math.PI / 2;
    wheelGroup.add(rim);
    // Rim center cap
    var cap = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.48, 8), rimMat);
    cap.rotation.z = Math.PI / 2;
    wheelGroup.add(cap);

    group.add(wheelGroup);
    group.userData.wheels.push(wheelGroup);
  });

  // Boost nozzle â€” dual exhaust with orange glow
  var nozMat = new THREE.MeshPhysicalMaterial({
    color: 0x333333, metalness: 0.95, roughness: 0.1,
    clearcoat: 1.0, clearcoatRoughness: 0.05
  });
  var nozGlowMat = new THREE.MeshStandardMaterial({
    color: 0xff4400, emissive: 0xff4400, emissiveIntensity: 0.3,
    transparent: true, opacity: 0.6
  });
  [-1, 1].forEach(function(side) {
    var noz = new THREE.Mesh(new THREE.CylinderGeometry(0.18, 0.32, 0.4, 10), nozMat);
    noz.rotation.x = Math.PI / 2;
    noz.position.set(side * 0.55, CH * 0.22, -CL / 2 - 0.1);
    group.add(noz);
    // Inner glow
    var nozGlow = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.25, 0.15, 8), nozGlowMat);
    nozGlow.rotation.x = Math.PI / 2;
    nozGlow.position.set(side * 0.55, CH * 0.22, -CL / 2 - 0.2);
    group.add(nozGlow);
  });

  return group;
}

// ==========================================================================
// BOOST PADS
// ==========================================================================
function createBoostPads() {
  // RL-accurate boost pad layout: 6 large (100%) + 28 small (12%)
  var positions = [
    // 6 Large pads â€” 4 corners + 2 midfield sides (RL standard)
    { x: -FW * 0.42, z: -FL * 0.38, big: true },
    { x: FW * 0.42, z: -FL * 0.38, big: true },
    { x: -FW * 0.42, z: FL * 0.38, big: true },
    { x: FW * 0.42, z: FL * 0.38, big: true },
    { x: -FW * 0.42, z: 0, big: true },
    { x: FW * 0.42, z: 0, big: true },
    // 28 Small pads â€” arranged in RL diamond/grid pattern
    // Row near blue goal
    { x: -FW * 0.08, z: -FL * 0.42, big: false },
    { x: FW * 0.08, z: -FL * 0.42, big: false },
    { x: 0, z: -FL * 0.42, big: false },
    // Row 2
    { x: -FW * 0.28, z: -FL * 0.32, big: false },
    { x: FW * 0.28, z: -FL * 0.32, big: false },
    { x: 0, z: -FL * 0.32, big: false },
    // Row 3
    { x: -FW * 0.15, z: -FL * 0.22, big: false },
    { x: FW * 0.15, z: -FL * 0.22, big: false },
    { x: -FW * 0.35, z: -FL * 0.2, big: false },
    { x: FW * 0.35, z: -FL * 0.2, big: false },
    // Row 4 (approaching midfield)
    { x: -FW * 0.08, z: -FL * 0.1, big: false },
    { x: FW * 0.08, z: -FL * 0.1, big: false },
    { x: -FW * 0.28, z: -FL * 0.08, big: false },
    { x: FW * 0.28, z: -FL * 0.08, big: false },
    // Center row
    { x: -FW * 0.15, z: 0, big: false },
    { x: FW * 0.15, z: 0, big: false },
    // Mirrored rows for orange half
    { x: -FW * 0.08, z: FL * 0.1, big: false },
    { x: FW * 0.08, z: FL * 0.1, big: false },
    { x: -FW * 0.28, z: FL * 0.08, big: false },
    { x: FW * 0.28, z: FL * 0.08, big: false },
    { x: -FW * 0.15, z: FL * 0.22, big: false },
    { x: FW * 0.15, z: FL * 0.22, big: false },
    { x: -FW * 0.35, z: FL * 0.2, big: false },
    { x: FW * 0.35, z: FL * 0.2, big: false },
    { x: -FW * 0.28, z: FL * 0.32, big: false },
    { x: FW * 0.28, z: FL * 0.32, big: false },
    { x: 0, z: FL * 0.32, big: false },
    { x: -FW * 0.08, z: FL * 0.42, big: false },
    { x: FW * 0.08, z: FL * 0.42, big: false },
    { x: 0, z: FL * 0.42, big: false },
  ];

  positions.forEach(function(p) {
    var padGroup = new THREE.Group();
    padGroup.position.set(p.x, 0, p.z);

    if (p.big) {
      // Large pad â€” RL-style floating glowing orb
      var orbGeo = new THREE.SphereGeometry(1.2, 16, 16);
      var orbMat = new THREE.MeshPhysicalMaterial({
        color: 0xffcc00, emissive: 0xffaa00, emissiveIntensity: 0.8,
        transparent: true, opacity: 0.85, metalness: 0.3, roughness: 0.1
      });
      var orb = new THREE.Mesh(orbGeo, orbMat);
      orb.position.y = 2.0; // floating above ground
      padGroup.add(orb);

      // Orb outer glow
      var orbGlow = new THREE.Mesh(
        new THREE.SphereGeometry(1.8, 12, 12),
        new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.12, side: THREE.BackSide, depthWrite: false })
      );
      orbGlow.position.y = 2.0;
      padGroup.add(orbGlow);

      // Ground circle marker
      var groundCircle = new THREE.Mesh(
        new THREE.CylinderGeometry(2.2, 2.2, 0.08, 24),
        new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0xffaa00, emissiveIntensity: 0.5, transparent: true, opacity: 0.6 })
      );
      groundCircle.position.y = 0.05;
      padGroup.add(groundCircle);

      // (no point light â€” saves GPU perf)

    } else {
      // Small pad â€” flat glowing disc on ground (RL penny pad style)
      var discGeo = new THREE.CylinderGeometry(0.7, 0.7, 0.12, 12);
      var discMat = new THREE.MeshStandardMaterial({
        color: 0xffaa00, emissive: 0xff8800, emissiveIntensity: 0.5,
        transparent: true, opacity: 0.75
      });
      var disc = new THREE.Mesh(discGeo, discMat);
      disc.position.y = 0.08;
      padGroup.add(disc);

      // Small glow above disc
      var smallGlow = new THREE.Mesh(
        new THREE.SphereGeometry(0.25, 8, 8),
        new THREE.MeshBasicMaterial({ color: 0xffcc44, transparent: true, opacity: 0.4 })
      );
      smallGlow.position.y = 0.4;
      padGroup.add(smallGlow);
    }

    scene.add(padGroup);
    boostPads.push({
      mesh: padGroup, x: p.x, z: p.z, big: p.big,
      r: p.big ? 2.2 : 0.7,
      active: true, respawnT: 0, cooldown: p.big ? 10 : 4
    });
  });
}

// ==========================================================================
// PARTICLES
// ==========================================================================
// Particle pool â€” reuse meshes to avoid GC pressure from geometry/material creation
var _particlePool = [];
var _sharedParticleGeo = null; // lazy-init after THREE loads
function _getParticleMesh() {
  if (!_sharedParticleGeo) _sharedParticleGeo = new THREE.SphereGeometry(1, 6, 6);
  if (_particlePool.length > 0) {
    var m = _particlePool.pop();
    m.visible = true;
    return m;
  }
  var mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 1 });
  var mesh = new THREE.Mesh(_sharedParticleGeo, mat);
  return mesh;
}
function _returnParticleMesh(mesh) {
  mesh.visible = false;
  _particlePool.push(mesh);
}

function spawnParticle(x, y, z, vx, vy, vz, color, life, size) {
  var mesh = _getParticleMesh();
  mesh.material.color.set(color);
  mesh.material.opacity = 1;
  mesh.scale.setScalar(size);
  mesh.position.set(x, y, z);
  scene.add(mesh);
  particles.push({
    mesh: mesh, vx: vx, vy: vy, vz: vz,
    life: life, maxLife: life, baseSize: size
  });
}

function spawnBoostTrail(carGroup, rot, isBlueTeam) {
  var backX = carGroup.position.x - Math.sin(rot) * CL * 0.5;
  var backZ = carGroup.position.z - Math.cos(rot) * CL * 0.5;
  var backY = carGroup.position.y + CH * 0.25;
  // RL-style team-colored boost â€” orange team gets fire, blue gets blue flame
  for (var b = 0; b < 3; b++) {
    var flameColor;
    if (isBlueTeam) {
      flameColor = Math.random() > 0.6 ? 0x0044ff : (Math.random() > 0.4 ? 0x2288ff : 0x55bbff);
      if (Math.random() > 0.85) flameColor = 0xccddff;
    } else {
      flameColor = Math.random() > 0.6 ? 0xff2200 : (Math.random() > 0.4 ? 0xff6600 : 0xffaa00);
      if (Math.random() > 0.85) flameColor = 0xffee88;
    }
    spawnParticle(
      backX + (Math.random() - 0.5) * 0.8,
      backY + (Math.random() - 0.5) * 0.5,
      backZ + (Math.random() - 0.5) * 0.8,
      (Math.random() - 0.5) * 5 - Math.sin(rot) * 9,
      Math.random() * 6 + 2,
      (Math.random() - 0.5) * 5 - Math.cos(rot) * 9,
      flameColor,
      0.3 + Math.random() * 0.4,
      0.15 + Math.random() * 0.3
    );
  }
}

function spawnGoalExplosion(zPos, color) {
  var dir = zPos > 0 ? -1 : 1;
  // Shockwave ring
  spawnGoalShockwave(zPos, color);
  // Second smaller shockwave with slight delay effect
  setTimeout(function() { spawnGoalShockwave(zPos, 0xffffff); }, 100);
  // Main explosion burst (more particles, more dramatic)
  for (var i = 0; i < 120; i++) {
    var angle = Math.random() * Math.PI * 2;
    var upV = Math.random() * 28 + 8;
    var outV = Math.random() * 22 + 5;
    var pColor = i % 4 === 0 ? 0xffffff : (i % 3 === 0 ? 0xffdd00 : color);
    spawnParticle(
      (Math.random() - 0.5) * GW,
      Math.random() * GH,
      zPos + dir * Math.random() * 3,
      Math.cos(angle) * outV + (Math.random() - 0.5) * 10,
      upV,
      dir * (Math.random() * 20 + 8) + Math.sin(angle) * outV * 0.3,
      pColor,
      1.5 + Math.random() * 2.0,
      0.25 + Math.random() * 0.7
    );
  }
  // Confetti-like sparkles
  for (var j = 0; j < 40; j++) {
    var confettiColors = [0xff4444, 0x44ff44, 0x4444ff, 0xffff44, 0xff44ff, 0x44ffff, 0xffffff];
    spawnParticle(
      (Math.random() - 0.5) * GW * 1.5,
      Math.random() * GH * 1.5 + 3,
      zPos + dir * Math.random() * 5,
      (Math.random() - 0.5) * 15,
      Math.random() * 15 + 10,
      dir * Math.random() * 10,
      confettiColors[Math.floor(Math.random() * confettiColors.length)],
      2.5 + Math.random() * 2,
      0.15 + Math.random() * 0.25
    );
  }
}

function updateParticles(dt) {
  for (var i = particles.length - 1; i >= 0; i--) {
    var p = particles[i];
    p.life -= dt;
    if (p.life <= 0) {
      scene.remove(p.mesh);
      if (p.isShockwave) {
        p.mesh.geometry.dispose();
        p.mesh.material.dispose();
      } else {
        _returnParticleMesh(p.mesh);
      }
      particles.splice(i, 1);
      continue;
    }
    if (p.isShockwave) {
      var frac = 1 - p.life / p.maxLife;
      var ringScale = 1 + frac * 35;
      p.mesh.scale.setScalar(ringScale);
      p.mesh.material.opacity = (p.life / p.maxLife) * 0.7;
    } else {
      p.vy += GRAV_ACTIVE * 0.3 * dt;
      p.mesh.position.x += p.vx * dt;
      p.mesh.position.y += p.vy * dt;
      p.mesh.position.z += p.vz * dt;
      if (p.mesh.position.y < 0) { p.mesh.position.y = 0; p.vy *= -0.3; }
      p.mesh.material.opacity = p.life / p.maxLife;
      var s = (p.life / p.maxLife) * (p.baseSize || 0.5);
      p.mesh.scale.setScalar(Math.max(s, 0.01));
    }
  }
}

// ==========================================================================
// BALL TRAIL â€” glowing trail behind fast-moving ball
// ==========================================================================
// Ball trail pool â€” reuse meshes
var _trailPool = [];
var _sharedTrailGeo = null;
function _getTrailMesh() {
  if (!_sharedTrailGeo) _sharedTrailGeo = new THREE.SphereGeometry(1, 6, 6);
  if (_trailPool.length > 0) {
    var m = _trailPool.pop();
    m.visible = true;
    return m;
  }
  var mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.35 });
  return new THREE.Mesh(_sharedTrailGeo, mat);
}

function updateBallTrail(dt) {
  var bSpd = bV.length();
  if (bSpd > 12 && gameState === 'playing') {
    if (ballTrail.length < BALL_TRAIL_MAX) {
      var trailMesh = _getTrailMesh();
      var trailColor = bSpd > 50 ? 0xff4400 : (bSpd > 30 ? 0xffaa00 : 0xffcc66);
      trailMesh.material.color.set(trailColor);
      trailMesh.material.opacity = 0.35;
      trailMesh.scale.setScalar(BR_ACTIVE * 0.7);
      trailMesh.position.copy(bP);
      scene.add(trailMesh);
      ballTrail.push({ mesh: trailMesh, life: 0.3 + bSpd * 0.003, maxLife: 0.3 + bSpd * 0.003 });
    }
  }
  for (var i = ballTrail.length - 1; i >= 0; i--) {
    var t = ballTrail[i];
    t.life -= dt;
    if (t.life <= 0) {
      scene.remove(t.mesh);
      t.mesh.visible = false;
      _trailPool.push(t.mesh);
      ballTrail.splice(i, 1);
    } else {
      var frac = t.life / t.maxLife;
      t.mesh.material.opacity = frac * 0.35;
      t.mesh.scale.setScalar((frac * 0.8 + 0.2) * BR_ACTIVE * 0.7);
    }
  }
}

// ==========================================================================
// DEMOLITION SYSTEM
// ==========================================================================
function triggerDemo(isPlayer) {
  if (isPlayer) {
    pDemoed = true; pDemoTimer = 3.0;
    playerCar.visible = false;
    spawnDemoExplosion(pP.x, pP.y, pP.z, 0xff6600);
    // Release spikes so ball isn't dragged by an invisible/frozen car
    if (playerSpikesAttached) { playerSpikesAttached = false; _spikesTimerP = 0; }
  } else {
    aDemoed = true; aDemoTimer = 3.0;
    aiCar.visible = false;
    spawnDemoExplosion(aP.x, aP.y, aP.z, 0x0066ff);
    matchStats.pDemos++; // player demoed the AI
    if (aiSpikesAttached) { aiSpikesAttached = false; _spikesTimerA = 0; }
  }
  playDemoSound();
  vibrateController(400, 1.0, 1.0); // strong pulse for demolition
  showDemoText(isPlayer ? 'DEMOLISHED!' : 'DEMO!');
}

function spawnDemoExplosion(x, y, z, color) {
  // RL-style massive demo explosion
  for (var i = 0; i < 80; i++) {
    var angle = Math.random() * Math.PI * 2;
    var upV = Math.random() * 30 + 10;
    var outV = Math.random() * 25 + 8;
    var demoColor = i % 5 === 0 ? 0xffffff : (i % 4 === 0 ? 0xffee44 : (i % 3 === 0 ? 0xffaa00 : (i % 2 === 0 ? color : 0xff4400)));
    spawnParticle(
      x + (Math.random() - 0.5) * 3, y + Math.random() * 2.5, z + (Math.random() - 0.5) * 3,
      Math.cos(angle) * outV, upV, Math.sin(angle) * outV,
      demoColor,
      1.2 + Math.random() * 1.8, 0.25 + Math.random() * 0.6
    );
  }
  // Car debris chunks
  for (var d = 0; d < 8; d++) {
    var debrisAngle = Math.random() * Math.PI * 2;
    spawnParticle(
      x, y + 1, z,
      Math.cos(debrisAngle) * 15, Math.random() * 20 + 12, Math.sin(debrisAngle) * 15,
      0x444444, 2.0 + Math.random(), 0.5 + Math.random() * 0.5
    );
  }
  triggerScreenShake(1.0);
}

// Helper: zero all aerial physics state (pitch/roll angles + angular velocities).
// Called on landing, kickoff, manual reset, and demo respawn.
function resetAerialState() {
  pPitch = 0; pRoll = 0;
  pAngVelPitch = 0; pAngVelYaw = 0; pAngVelRoll = 0;
}

function updateDemos(dt) {
  if (pDemoed) {
    pDemoTimer -= dt;
    if (pDemoTimer <= 0) {
      pDemoed = false;
      playerCar.visible = true;
      pP.set(0, CH / 2, FL * 0.33);
      pV.set(0, 0, 0);
      pSpeed = 0; pRot = Math.PI;
      pBoost = BOOST_MAX;
      pSurface = 'floor'; pGround = true;
      resetAerialState();
    }
  }
  if (aDemoed) {
    aDemoTimer -= dt;
    if (aDemoTimer <= 0) {
      aDemoed = false;
      aiCar.visible = true;
      aP.set(0, CH / 2, -FL * 0.33);
      aV.set(0, 0, 0);
      aSpeed = 0; aRot = faceTowardBall(aP.x, aP.z); aGround = true;
      aBoost = BOOST_MAX;
    }
  }
}

function showDemoText(text) {
  var el = document.getElementById('demo-text');
  el.textContent = text;
  el.className = 'show';
  _demoTextTimer = 1.5;
}

function updateDemoText(dt) {
  if (_demoTextTimer > 0) {
    _demoTextTimer -= dt;
    if (_demoTextTimer <= 0) {
      document.getElementById('demo-text').className = '';
    }
  }
}

function playDemoSound() {
  var ctx = getAudio(); if (!ctx) return;
  // Low boom + high crackle
  var osc1 = ctx.createOscillator();
  var osc2 = ctx.createOscillator();
  var gain1 = ctx.createGain();
  var gain2 = ctx.createGain();
  osc1.connect(gain1); gain1.connect(ctx.destination);
  osc2.connect(gain2); gain2.connect(ctx.destination);
  osc1.type = 'sawtooth'; osc1.frequency.setValueAtTime(80, ctx.currentTime);
  osc1.frequency.exponentialRampToValueAtTime(30, ctx.currentTime + 0.4);
  gain1.gain.setValueAtTime(0.3 * VOLUME_SCALE, ctx.currentTime);
  gain1.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.4);
  osc2.type = 'square'; osc2.frequency.setValueAtTime(2000, ctx.currentTime);
  osc2.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.15);
  gain2.gain.setValueAtTime(0.15 * VOLUME_SCALE, ctx.currentTime);
  gain2.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15);
  osc1.start(); osc1.stop(ctx.currentTime + 0.4);
  osc2.start(); osc2.stop(ctx.currentTime + 0.15);
}

// ==========================================================================
// SCREEN SHAKE
// ==========================================================================
function triggerScreenShake(intensity) {
  _shakeIntensity = intensity;
  _shakeTimer = 0.15;
  document.body.classList.add('shake');
}

function updateScreenShake(dt) {
  if (_shakeTimer > 0) {
    _shakeTimer -= dt;
    if (_shakeTimer <= 0) {
      document.body.classList.remove('shake');
      _shakeIntensity = 0;
    }
  }
}

// ==========================================================================
// GOAL FLASH
// ==========================================================================
function triggerGoalFlash(team) {
  var el = document.getElementById('goal-flash');
  el.className = team;
  _goalFlashTimer = 1.5;
}

function updateGoalFlash(dt) {
  if (_goalFlashTimer > 0) {
    _goalFlashTimer -= dt;
    if (_goalFlashTimer <= 0) {
      var gfEl = document.getElementById('goal-flash');
      gfEl.className = '';
      gfEl.style.opacity = '';
    } else if (_goalFlashTimer < 0.5) {
      document.getElementById('goal-flash').style.opacity = _goalFlashTimer / 0.5;
    }
  }
}

// ==========================================================================
// SUPERSONIC SPEED CHECK
// ==========================================================================
function updateSupersonic() {
  var maxSpd = CAR_BOOST_MAX * CAR_SPEED_MULT;
  pSupersonic = Math.abs(pSpeed) > maxSpd * SUPERSONIC_THRESH;
}

function spawnSupersonicTrail(carGroup, rot) {
  // RL supersonic â€” golden-white streaks + shockwave lines
  var backX = carGroup.position.x - Math.sin(rot) * CL * 0.55;
  var backZ = carGroup.position.z - Math.cos(rot) * CL * 0.55;
  var backY = carGroup.position.y + CH * 0.5;
  for (var s = 0; s < 3; s++) {
    var trailColor = Math.random() > 0.4 ? 0xffeedd : (Math.random() > 0.5 ? 0xffcc44 : 0xffffff);
    spawnParticle(
      backX + (Math.random() - 0.5) * 1.5,
      backY + (Math.random() - 0.5) * 0.8,
      backZ + (Math.random() - 0.5) * 1.5,
      (Math.random() - 0.5) * 4 - Math.sin(rot) * 14,
      Math.random() * 3,
      (Math.random() - 0.5) * 4 - Math.cos(rot) * 14,
      trailColor,
      0.2 + Math.random() * 0.3,
      0.1 + Math.random() * 0.2
    );
  }
}

// ==========================================================================
// TUTORIAL SYSTEM
// ==========================================================================
var tutorialActive = false;
var tutorialStep = 0;
var tutorialStepComplete = false;
var tutorialProgress = {};

function tutKey(action) {
  return '<kbd>' + keyDisplayName(settings.controls[action]) + '</kbd>';
}

var TUTORIAL_STEPS = [
  {
    title: 'DRIVING',
    text: function() { return 'Use ' + tutKey('forward') + ' to drive forward and ' + tutKey('backward') + ' to reverse'; },
    check: function() { return Math.abs(pSpeed) > 10; }
  },
  {
    title: 'STEERING',
    text: function() { return 'Use ' + tutKey('left') + ' and ' + tutKey('right') + ' to steer left and right'; },
    check: function() { return tutorialProgress.turned; }
  },
  {
    title: 'BOOSTING',
    text: function() { return 'Hold ' + tutKey('boost') + ' while driving to boost! Collect boost pads to refill.'; },
    check: function() { return pBoost < BOOST_MAX - 15; }
  },
  {
    title: 'JUMPING',
    text: function() { return 'Press ' + tutKey('jump') + ' to jump!'; },
    check: function() { return !pGround; }
  },
  {
    title: 'DODGE / FLIP',
    text: function() { return 'Jump, then press ' + tutKey('jump') + ' again + a direction to dodge flip.<br>Forward flips give a speed burst!'; },
    check: function() { return pSpin > 0; }
  },
  {
    title: 'BALL CAM',
    text: function() { return 'Press ' + tutKey('ballcam') + ' to toggle Ball Cam â€” keeps the camera locked on the ball.'; },
    check: function() { return tutorialProgress.ballCamToggled; }
  },
  {
    title: 'AERIALS',
    text: function() { return 'Jump, then hold ' + tutKey('forward') + ' to pitch nose up + ' + tutKey('boost') + ' to boost into the air!<br>This is how you fly in Rocket League.'; },
    check: function() { return pSurface === 'air' && pP.y > 5 && pBoost < BOOST_MAX - 10; }
  },
  {
    title: 'POWERSLIDE',
    text: function() { return 'Hold ' + tutKey('powerslide') + ' while turning to powerslide drift. In the air, ' + tutKey('powerslide') + ' + steer = air roll.'; },
    check: function() { return tutorialProgress.powerslid; }
  },
  {
    title: 'SCORE A GOAL',
    text: function() { return 'Now put it all together â€” hit the ball into the <span style="color:#00aaff">BLUE</span> goal!'; },
    check: function() { return score[0] > 0; }
  }
];

var _tutorialSavedAI = 0; // saved AI difficulty during tutorial
var _tutorialSavedBoost = 1; // saved boost mode during tutorial
var _tutorialAdvanceTimer = 0; // dt-based step advance delay (replaces setTimeout)
function startTutorial() {
  recalcActiveValues();
  applySettings();
  // Reset game mode flags â€” tutorial always runs in standard mode
  activeGameMode = 'standard';
  hoopsActive = false; rumbleActive = false; dropshotActive = false;
  cleanupGameModeMeshes();
  _tutorialSavedAI = settings.ai; // save player's chosen AI difficulty
  settings.ai = 0; // easy AI for tutorial
  _tutorialSavedBoost = settings.boost; // save player's boost mode
  settings.boost = 1; // force Normal boost so tutorial step works
  var _savedTeams = settings.teams;
  settings.teams = '1v1'; // force 1v1 for tutorial
  recalcActiveValues();
  score = [0, 0];
  gameTime = 99999;
  GAME_DURATION = 99999;
  WIN_SCORE = 99999;
  pBoost = BOOST_MAX;
  aBoost = BOOST_MAX;

  setup2v2();
  resetPositions();
  settings.teams = _savedTeams; // restore teams setting AFTER reset (so extra cars aren't positioned)
  // Move AI far back so player can practice
  aP.set(0, CH / 2, -FL * 0.45);
  aV.set(0, 0, 0);
  aRot = 0; aSpeed = 0;

  tutorialActive = true;
  tutorialStep = 0;
  tutorialStepComplete = false;
  tutorialProgress = {};
  _tutorialAdvanceTimer = 0;
  ballCam = false; // ensure ball cam starts off so ball-cam step is meaningful
  gameState = 'playing';
  document.getElementById('menu').style.display = 'none';
  document.getElementById('settings').style.display = 'none';
  document.getElementById('game-over').style.display = 'none';
  document.getElementById('hud').style.display = 'flex';
  document.getElementById('boost-container').style.display = 'block';
  document.getElementById('ball-speed').style.display = 'block';
  document.getElementById('tutorial-hud').style.display = 'block';
  document.getElementById('tutorial-skip').style.display = 'block';
  pDemoed = false; pDemoTimer = 0; playerCar.visible = true;
  aDemoed = false; aDemoTimer = 0; aiCar.visible = true;
  pSupersonic = false;
  lastTouchTeam = ''; lastTouchTimer = 0;
  closeQuickChat();
  // Reset boost pads
  boostPads.forEach(function(pad) { pad.active = true; pad.mesh.visible = true; pad.respawnT = 0; });
  updateScoreboard();
  updateTutorialUI();
}

function updateTutorialUI() {
  var step = TUTORIAL_STEPS[tutorialStep];
  if (!step) return;
  document.getElementById('tutorial-step-title').textContent = 'STEP ' + (tutorialStep + 1) + ' / ' + TUTORIAL_STEPS.length;
  document.getElementById('tutorial-text').innerHTML = typeof step.text === 'function' ? step.text() : step.text;

  // Progress dots
  var dotsHTML = '';
  for (var i = 0; i < TUTORIAL_STEPS.length; i++) {
    var cls = 'dot';
    if (i < tutorialStep) cls += ' done';
    else if (i === tutorialStep) cls += ' current';
    dotsHTML += '<div class="' + cls + '"></div>';
  }
  document.getElementById('tutorial-dots').innerHTML = dotsHTML;
  document.getElementById('tutorial-check').className = '';
}

function updateTutorial(dt) {
  if (!tutorialActive) return;

  // Track special progress
  if (isControl('left') || isControl('right')) tutorialProgress.turned = true;
  if (isControl('powerslide') && Math.abs(pSpeed) > 5) tutorialProgress.powerslid = true;
  if (isControl('ballcam')) tutorialProgress.ballCamToggled = true; // keyboard ball cam tracking

  var step = TUTORIAL_STEPS[tutorialStep];
  if (!step) {
    endTutorial();
    return;
  }

  // dt-based step advance delay â€” safe against tab throttling and endTutorial() race
  if (tutorialStepComplete) {
    _tutorialAdvanceTimer -= dt;
    if (_tutorialAdvanceTimer <= 0) {
      tutorialStep++;
      tutorialStepComplete = false;
      _tutorialAdvanceTimer = 0;
      if (tutorialStep >= TUTORIAL_STEPS.length) {
        endTutorial();
      } else {
        updateTutorialUI();
      }
    }
    return;
  }

  if (step.check()) {
    tutorialStepComplete = true;
    _tutorialAdvanceTimer = 1.2; // 1.2 seconds, same as former setTimeout delay
    document.getElementById('tutorial-check').className = 'show';
  }
}

function endTutorial() {
  if (!tutorialActive) return; // guard against double-call
  tutorialActive = false;
  _tutorialAdvanceTimer = 0;
  settings.ai = _tutorialSavedAI; // restore player's AI difficulty
  settings.boost = _tutorialSavedBoost; // restore player's boost mode
  recalcActiveValues();
  document.getElementById('tutorial-hud').style.display = 'none';
  document.getElementById('tutorial-skip').style.display = 'none';
  gameState = 'gameover';
  document.getElementById('game-over').style.display = 'flex';
  document.getElementById('go-title').textContent = 'TUTORIAL COMPLETE!';
  document.getElementById('go-title').style.color = '#ffcc00';
  document.getElementById('go-score').textContent = 'You learned the basics. Now go play!';
  document.getElementById('match-stats').style.display = 'none';
  document.getElementById('xp-bar-container').style.display = 'none';
  document.getElementById('mvp-badge').style.display = 'none';
}

// ==========================================================================
// AUDIO
// ==========================================================================
function getAudio() {
  if (!audioCtx) {
    try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e) {}
  }
  if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
  return audioCtx;
}

function makeOscGain(ctx) {
  var osc = ctx.createOscillator();
  var gain = ctx.createGain();
  osc.connect(gain); gain.connect(ctx.destination);
  return { osc: osc, gain: gain };
}

function playHitSound(strength) {
  var ctx = getAudio(); if (!ctx) return;
  var n = makeOscGain(ctx);
  n.osc.frequency.value = 400 + strength * 15;
  n.osc.type = 'triangle';
  n.gain.gain.setValueAtTime(Math.min(strength / 50, 0.3) * VOLUME_SCALE, ctx.currentTime);
  n.gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15);
  n.osc.start(); n.osc.stop(ctx.currentTime + 0.15);
  // Bass thump for hard hits
  if (strength > 20) {
    var bass = ctx.createOscillator();
    var bassGain = ctx.createGain();
    bass.connect(bassGain); bassGain.connect(ctx.destination);
    bass.type = 'sine';
    bass.frequency.setValueAtTime(60, ctx.currentTime);
    bass.frequency.exponentialRampToValueAtTime(30, ctx.currentTime + 0.2);
    bassGain.gain.setValueAtTime(0.18 * VOLUME_SCALE, ctx.currentTime);
    bassGain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.25);
    bass.start(); bass.stop(ctx.currentTime + 0.25);
  }
}

function playBounceSound(speed) {
  var ctx = getAudio(); if (!ctx) return;
  if (speed < 3) return; // skip quiet bounces
  var osc = ctx.createOscillator();
  var gain = ctx.createGain();
  osc.connect(gain); gain.connect(ctx.destination);
  osc.type = 'sine';
  osc.frequency.setValueAtTime(120 + speed * 8, ctx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(60, ctx.currentTime + 0.1);
  var vol = Math.min(speed / 40, 0.15) * VOLUME_SCALE;
  gain.gain.setValueAtTime(vol, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.12);
  osc.start(); osc.stop(ctx.currentTime + 0.12);
}

var _boostSoundNode = null;
function playBoostSound() {
  var ctx = getAudio(); if (!ctx || _boostSoundNode) return;
  var osc = ctx.createOscillator();
  var gain = ctx.createGain();
  osc.connect(gain); gain.connect(ctx.destination);
  osc.type = 'sawtooth';
  osc.frequency.value = 80;
  gain.gain.setValueAtTime(0.08 * VOLUME_SCALE, ctx.currentTime);
  osc.start();
  _boostSoundNode = { osc: osc, gain: gain };
}
function stopBoostSound() {
  if (!_boostSoundNode) return;
  var ctx = getAudio(); if (!ctx) return;
  _boostSoundNode.gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.1);
  _boostSoundNode.osc.stop(ctx.currentTime + 0.1);
  _boostSoundNode = null;
}

function playGoalHorn() {
  var ctx = getAudio(); if (!ctx) return;
  [220, 277, 330].forEach(function(freq, i) {
    var n = makeOscGain(ctx);
    n.osc.frequency.value = freq;
    n.osc.type = 'sawtooth';
    n.gain.gain.setValueAtTime(0.15 * VOLUME_SCALE, ctx.currentTime);
    n.gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 1.5);
    n.osc.start(ctx.currentTime + i * 0.05);
    n.osc.stop(ctx.currentTime + 1.5);
  });
}

function playJumpSound() {
  var ctx = getAudio(); if (!ctx) return;
  var n = makeOscGain(ctx);
  n.osc.type = 'sine';
  n.osc.frequency.setValueAtTime(200, ctx.currentTime);
  n.osc.frequency.exponentialRampToValueAtTime(600, ctx.currentTime + 0.12);
  n.gain.gain.setValueAtTime(0.12 * VOLUME_SCALE, ctx.currentTime);
  n.gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15);
  n.osc.start(); n.osc.stop(ctx.currentTime + 0.15);
}

function playDodgeSound() {
  var ctx = getAudio(); if (!ctx) return;
  var n = makeOscGain(ctx);
  n.osc.type = 'sawtooth';
  n.osc.frequency.setValueAtTime(300, ctx.currentTime);
  n.osc.frequency.exponentialRampToValueAtTime(800, ctx.currentTime + 0.08);
  n.osc.frequency.exponentialRampToValueAtTime(200, ctx.currentTime + 0.2);
  n.gain.gain.setValueAtTime(0.15 * VOLUME_SCALE, ctx.currentTime);
  n.gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.2);
  n.osc.start(); n.osc.stop(ctx.currentTime + 0.2);
}

function playCountdownBeep(high) {
  var ctx = getAudio(); if (!ctx) return;
  var n = makeOscGain(ctx);
  n.osc.frequency.value = high ? 880 : 440;
  n.osc.type = 'sine';
  n.gain.gain.setValueAtTime(0.2 * VOLUME_SCALE, ctx.currentTime);
  n.gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.3);
  n.osc.start(); n.osc.stop(ctx.currentTime + 0.3);
}

// ==========================================================================
// RESET & GAME FLOW
// ==========================================================================
function faceTowardBall(px, pz) {
  // Compute Y rotation so car faces ball at (0, 0, 0)
  return Math.atan2(0 - px, 0 - pz);
}

function resetPositions() {
  bP.set(0, BR_ACTIVE, 0);
  bV.set(0, 0, 0);

  // Heatseeker: serve ball toward the team that scored (scored-on team gets possession)
  // If player scored, ball heads toward player goal (+Z) so blue (scored-on) can redirect
  // If AI scored, ball heads toward AI goal (-Z) so orange (scored-on) can redirect
  if (activeGameMode === 'heatseeker') {
    heatseekerSpeed = HEATSEEKER_BASE_SPEED;
    heatseekerTarget = 0; // no homing until someone touches ball
    // Gentle serve â€” slower, with arc and lateral spread so ball doesn't roll straight into net
    var serveSpd = HEATSEEKER_BASE_SPEED * 0.35;
    var lateralSpread = (Math.random() - 0.5) * 12;
    if (goalScorer === 'player') {
      // Player scored â€” blue was scored on â€” serve toward blue (-Z)
      bV.set(lateralSpread, 4, -serveSpd);
    } else if (goalScorer === 'ai') {
      // AI scored â€” orange was scored on â€” serve toward orange (+Z)
      bV.set(lateralSpread, 4, serveSpd);
    } else {
      // First kickoff: random direction
      var serveDir = Math.random() < 0.5 ? 1 : -1;
      bV.set(lateralSpread, 4, serveDir * serveSpd);
    }
  }

  // RL-style kickoff positions â€” randomized each reset
  // 1v1: one of 5 positions per side (center-back, diagonal-left/right, near-diagonal-left/right)
  var pKickoffs, aKickoffs;

  if (activeGameMode === 'heatseeker') {
    // Heatseeker: scored-on team near own goal, scorer at midfield
    if (goalScorer === 'player') {
      // Blue scored on â€” blue near goal, orange midfield
      pKickoffs = [{ x: 0, z: FL * 0.15 }, { x: -12, z: FL * 0.12 }, { x: 12, z: FL * 0.12 }];
      aKickoffs = [{ x: 0, z: -FL * 0.4 }, { x: -10, z: -FL * 0.38 }, { x: 10, z: -FL * 0.38 }];
    } else if (goalScorer === 'ai') {
      // Orange scored on â€” orange near goal, blue midfield
      pKickoffs = [{ x: 0, z: FL * 0.4 }, { x: -10, z: FL * 0.38 }, { x: 10, z: FL * 0.38 }];
      aKickoffs = [{ x: 0, z: -FL * 0.15 }, { x: -12, z: -FL * 0.12 }, { x: 12, z: -FL * 0.12 }];
    } else {
      // First kickoff â€” both near own goals
      pKickoffs = [{ x: 0, z: FL * 0.3 }, { x: -14, z: FL * 0.25 }, { x: 14, z: FL * 0.25 }];
      aKickoffs = [{ x: 0, z: -FL * 0.3 }, { x: 14, z: -FL * 0.25 }, { x: -14, z: -FL * 0.25 }];
    }
  } else {
    pKickoffs = [
      { x: 0, z: FL * 0.33 },              // center-back
      { x: -16, z: FL * 0.2 },             // diagonal-left
      { x: 16, z: FL * 0.2 },              // diagonal-right
      { x: -FW * 0.22, z: FL * 0.11 },     // near-diagonal-left (closer to ball)
      { x: FW * 0.22, z: FL * 0.11 }       // near-diagonal-right (closer to ball)
    ];
    aKickoffs = [
      { x: 0, z: -FL * 0.33 },             // center-back
      { x: 16, z: -FL * 0.2 },             // diagonal-right (mirrored)
      { x: -16, z: -FL * 0.2 },            // diagonal-left (mirrored)
      { x: FW * 0.22, z: -FL * 0.11 },     // near-diagonal-right (mirrored)
      { x: -FW * 0.22, z: -FL * 0.11 }     // near-diagonal-left (mirrored)
    ];
  }

  var kickoffSlot = Math.floor(Math.random() * pKickoffs.length);
  var pk = pKickoffs[kickoffSlot];
  var ak = aKickoffs[kickoffSlot];

  pP.set(pk.x, CH / 2, pk.z);
  pV.set(0, 0, 0);
  pRot = faceTowardBall(pk.x, pk.z);
  pSpeed = 0; pGround = true; pBoost = BOOST_MAX;
  pCanDodge = false; pDodgeTimer = 0; pSpin = 0; pPowerslide = false;
  resetAerialState();
  pSurface = 'floor'; pWallGraceTimer = 0; pJumpCooldown = 0; pJumpHoldTimer = 0;
  _pSmoothNormal.set(0, 1, 0); _pOnCurve = false; _pSnapVisual = true;
  cameraUp.set(0, 1, 0);

  aP.set(ak.x, CH / 2, ak.z);
  aV.set(0, 0, 0);
  aRot = faceTowardBall(ak.x, ak.z);
  aSpeed = 0; aGround = true; aBoost = BOOST_MAX;

  // 2v2/3v3 kickoff â€” teammates offset to back-corner positions
  if (settings.teams === '2v2' || settings.teams === '3v3') {
    var tSlot = Math.random() < 0.5 ? 0 : 1;
    var orangeBack = [
      { x: -20, z: FL * 0.38 },
      { x: 20, z: FL * 0.38 }
    ];
    var blueBack = [
      { x: 20, z: -FL * 0.38 },
      { x: -20, z: -FL * 0.38 }
    ];
    var ob = orangeBack[tSlot];
    var bb = blueBack[tSlot];
    a2P.set(ob.x, CH / 2, ob.z);
    a2V.set(0, 0, 0); a2Rot = faceTowardBall(ob.x, ob.z); a2Speed = 0; a2Ground = true; a2Boost = BOOST_MAX;
    a3P.set(bb.x, CH / 2, bb.z);
    a3V.set(0, 0, 0); a3Rot = faceTowardBall(bb.x, bb.z); a3Speed = 0; a3Ground = true; a3Boost = BOOST_MAX;
  }
  if (settings.teams === '3v3') {
    // Third car on each team â€” goalie position
    a4P.set(0, CH / 2, FL * 0.42);
    a4V.set(0, 0, 0); a4Rot = faceTowardBall(0, FL * 0.42); a4Speed = 0; a4Ground = true; a4Boost = BOOST_MAX;
    a5P.set(0, CH / 2, -FL * 0.42);
    a5V.set(0, 0, 0); a5Rot = faceTowardBall(0, -FL * 0.42); a5Speed = 0; a5Ground = true; a5Boost = BOOST_MAX;
  }
  // Clear active rumble powerup effects so spikes/freeze don't carry over into kickoff
  if (rumbleActive) {
    playerSpikesAttached = false;
    aiSpikesAttached = false;
    ballFrozen = false;
    ballFreezeTimer = 0;
    _spikesTimerP = 0;
    _spikesTimerA = 0;
  }

  syncVisuals();
}

var _currentStadium = 'standard';

function startGame() {
  keys = {}; // clear any held keys from previous session to prevent ghost inputs
  _menuFocusIdx = -1;
  var mfOld = document.querySelector('.menu-focus');
  if (mfOld) mfOld.classList.remove('menu-focus');
  tutorialActive = false;
  document.getElementById('tutorial-hud').style.display = 'none';
  recalcActiveValues();
  applySettings();

  // Rebuild arena if stadium changed
  if (settings.stadium !== _currentStadium) {
    applyStadium();
    rebuildArena();
    _currentStadium = settings.stadium;
  }

  score = [0, 0];
  matchStats = { pGoals: 0, pShots: 0, pSaves: 0, pDemos: 0, aGoals: 0, aShots: 0, aSaves: 0 };
  gameTime = settings.duration > 0 ? settings.duration : 0;
  GAME_DURATION = settings.duration > 0 ? settings.duration : 99999;
  WIN_SCORE = settings.winScore > 0 ? settings.winScore : 99999;
  pBoost = BOOST_MAX;
  aBoost = BOOST_MAX;

  // 2v2: create extra cars if needed
  setup2v2();

  // Initialize game mode BEFORE resetPositions so heatseeker kickoff positions work
  initGameMode();

  resetPositions();
  gameState = 'countdown';
  countdownVal = 3;
  countdownT = 0;
  document.getElementById('menu').style.display = 'none';
  document.getElementById('settings').style.display = 'none';
  document.getElementById('game-over').style.display = 'none';
  document.getElementById('hud').style.display = 'flex';
  document.getElementById('boost-container').style.display = 'block';
  document.getElementById('ball-speed').style.display = 'block';
  pDemoed = false; pDemoTimer = 0; playerCar.visible = true;
  aDemoed = false; aDemoTimer = 0; aiCar.visible = true;
  pSupersonic = false;
  isOvertime = false;
  replayActive = false; replayData = null; replayBuffer = [];
  document.getElementById('replay-badge').className = '';
  document.getElementById('goal-scorer').className = '';
  lastTouchTeam = ''; lastTouchTimer = 0;
  closeQuickChat();
  updateScoreboard();
  showOverlay(String(countdownVal));
  playCountdownBeep(false);
  // Reset boost pads
  boostPads.forEach(function(pad) { pad.active = true; pad.mesh.visible = true; pad.respawnT = 0; });
}

function rebuildArena() {
  // Remove old arena and boost pads
  if (arenaGroup) {
    scene.remove(arenaGroup);
    arenaGroup.traverse(function(obj) {
      if (obj.geometry) obj.geometry.dispose();
      if (obj.material) {
        if (obj.material.map) obj.material.map.dispose();
        obj.material.dispose();
      }
    });
  }
  boostPads.forEach(function(pad) {
    scene.remove(pad.mesh);
    pad.mesh.traverse(function(obj) {
      if (obj.geometry) obj.geometry.dispose();
      if (obj.material) obj.material.dispose();
    });
  });
  boostPads = [];

  // Apply stadium theme
  var s = STADIUMS[settings.stadium] || STADIUMS.standard;
  scene.fog = new THREE.FogExp2(s.fogColor, 0.003);
  createSkybox(); // Regenerate skybox for environment reflections

  createArena();
  createBoostPads();
}

function setup2v2() {
  var need2 = settings.teams === '2v2' || settings.teams === '3v3';
  var need3 = settings.teams === '3v3';
  if (need2) {
    if (!aiCar2) {
      aiCar2 = createCar(0xff8800, 0xffaa00); // orange teammate
      scene.add(aiCar2);
    }
    if (!aiCar3) {
      aiCar3 = createCar(0x0044cc, 0x0066ee); // blue teammate
      scene.add(aiCar3);
    }
    aiCar2.visible = true;
    aiCar3.visible = true;
  } else {
    if (aiCar2) aiCar2.visible = false;
    if (aiCar3) aiCar3.visible = false;
  }
  if (need3) {
    if (!aiCar4) {
      aiCar4 = createCar(0xffaa44, 0xffcc66); // second orange teammate
      scene.add(aiCar4);
    }
    if (!aiCar5) {
      aiCar5 = createCar(0x2255cc, 0x4488ee); // second blue teammate
      scene.add(aiCar5);
    }
    aiCar4.visible = true;
    aiCar5.visible = true;
  } else {
    if (aiCar4) aiCar4.visible = false;
    if (aiCar5) aiCar5.visible = false;
  }
}

function showOverlay(text, cls) {
  var el = document.getElementById('overlay-text');
  el.textContent = text;
  el.className = 'show' + (cls ? ' ' + cls : '');
}

function hideOverlay() {
  document.getElementById('overlay-text').className = '';
}

function updateScoreboard() {
  document.getElementById('scoreOrange').textContent = score[0];
  document.getElementById('scoreBlue').textContent = score[1];
  if (activeGameMode === 'heatseeker') {
    // Heatseeker: show "First to 7" instead of timer
    document.getElementById('timer').textContent = 'First to ' + WIN_SCORE;
  } else {
    var displayTime = Math.abs(gameTime);
    var m = Math.floor(displayTime / 60);
    var s = Math.floor(displayTime % 60);
    var prefix = isOvertime ? '+' : '';
    document.getElementById('timer').textContent = prefix + m + ':' + (s < 10 ? '0' : '') + s;
  }
}

function onGoal(scorer) {
  if (scorer === 'player') {
    score[0]++;
    matchStats.pGoals++;
    spawnGoalExplosion(-FL / 2, 0xff6600);
    triggerGoalFlash('orange');
    showGoalScorer('ORANGE TEAM', '#ff7b00');
  } else {
    score[1]++;
    matchStats.aGoals++;
    spawnGoalExplosion(FL / 2, 0x0066ff);
    triggerGoalFlash('blue');
    showGoalScorer('BLUE TEAM', '#00aaff');
  }
  playGoalHorn();
  triggerScreenShake(1.0);
  _slowmoTimer = _slowmoDuration; // brief slow-motion on goal (RL-style)
  updateScoreboard();
  goalScorer = scorer;
  goalT = 0;
  gameState = 'goal';
  showOverlay('GOAL!', 'goal');

  // Dropshot: reset tiles after goal
  if (dropshotActive) resetDropshotTiles();

  // Start proper replay
  startReplay(scorer);

  // Increase bloom during goal (reset via dt-based timer in game loop)
  if (bloomPass) {
    bloomPass.strength = 1.0;
    _goalBloomTimer = 1.5;
  }
}

function showGoalScorer(teamName, color) {
  var el = document.getElementById('goal-scorer');
  el.textContent = teamName + ' SCORED';
  el.style.color = color;
  el.className = 'show';
  _goalScorerTimer = 2.5;
}

function updateGoalScorer(dt) {
  if (_goalScorerTimer > 0) {
    _goalScorerTimer -= dt;
    if (_goalScorerTimer <= 0) {
      document.getElementById('goal-scorer').className = '';
    }
  }
}

function endGame() {
  gameState = 'gameover';
  hideOverlay();
  cleanupGameModeMeshes();
  // Clean up replay state
  replayActive = false; replayData = null;
  document.getElementById('replay-badge').className = '';
  document.getElementById('goal-scorer').className = '';
  document.getElementById('goal-scorer').style.color = '';
  var go = document.getElementById('game-over');
  go.style.display = 'flex';
  // Reset any tutorial-modified styles
  document.getElementById('match-stats').style.display = '';
  document.getElementById('xp-bar-container').style.display = '';
  var title = document.getElementById('go-title');
  if (score[0] > score[1]) {
    title.textContent = 'YOU WIN!';
    title.style.color = '#ff7b00';
  } else if (score[1] > score[0]) {
    title.textContent = 'YOU LOSE';
    title.style.color = '#0088ff';
  } else {
    title.textContent = 'DRAW';
    title.style.color = '#ccc';
  }
  document.getElementById('go-score').textContent = score[0] + ' - ' + score[1];

  // Match stats
  document.getElementById('stat-p-goals').textContent = matchStats.pGoals;
  document.getElementById('stat-p-shots').textContent = matchStats.pShots;
  document.getElementById('stat-p-saves').textContent = matchStats.pSaves;
  document.getElementById('stat-p-demos').textContent = matchStats.pDemos;
  document.getElementById('stat-a-goals').textContent = matchStats.aGoals;
  document.getElementById('stat-a-shots').textContent = matchStats.aShots;
  document.getElementById('stat-a-saves').textContent = matchStats.aSaves;

  // MVP award (like RL)
  var pScore = matchStats.pGoals * 100 + matchStats.pShots * 20 + matchStats.pSaves * 50 + matchStats.pDemos * 20;
  var aScore = matchStats.aGoals * 100 + matchStats.aShots * 20 + matchStats.aSaves * 50;
  var mvpEl = document.getElementById('mvp-badge');
  if (pScore >= aScore) {
    mvpEl.textContent = 'MVP';
    mvpEl.style.display = 'block';
  } else {
    mvpEl.textContent = '';
    mvpEl.style.display = 'none';
  }

  // XP award
  var xpGained = 20; // base XP for completing a match
  xpGained += matchStats.pGoals * 15;
  xpGained += matchStats.pShots * 3;
  xpGained += matchStats.pSaves * 10;
  xpGained += matchStats.pDemos * 5;
  if (score[0] > score[1]) xpGained += 30; // win bonus
  addXP(xpGained);

  // Update XP bar display
  var xpPct = Math.round((playerXP / XP_PER_LEVEL) * 100);
  document.getElementById('xp-label').textContent = 'LEVEL ' + playerLevel + ' \u2014 ' + playerXP + ' / ' + XP_PER_LEVEL + ' XP (+' + xpGained + ')';
  // Animate bar after a short delay
  setTimeout(function() {
    document.getElementById('xp-bar-fill').style.width = xpPct + '%';
  }, 300);
}

// ==========================================================================
// CURVED SURFACE PHYSICS
// ==========================================================================
// Get the curved surface normal at a given position.
// Returns { normal: Vector3, onCurve: bool, surface: string } or null if in open space.
// Curve zones exist where floor meets walls and walls meet ceiling (radius = CURVE_R).
function getCurveInfo(px, py, pz, radius) {
  var CR = CURVE_R;
  var r = radius || 0;
  var hw = FW / 2; var hl = FL / 2;
  var margin = 1.5; // extra detection margin so cars don't slip under curves

  for (var zi = 0; zi < 8; zi++) {
    var z = _curveZones[zi];
    var cy = z.yFloor ? CR : (WH - CR);
    var cHoriz = z.isX
      ? (z.cHorizSign > 0 ? hw - CR : -hw + CR)
      : (z.cHorizSign > 0 ? hl - CR : -hl + CR);
    var p = z.isX ? px : pz;

    // Zone proximity check
    var pClose = z.cHorizSign > 0 ? (p + r > cHoriz - margin) : (p - r < cHoriz + margin);
    var yClose = z.yFloor ? (py - r < cy + margin) : (py + r > cy - margin);
    if (!pClose || !yClose) continue;

    // Goal-opening exclusion (only for floor-front and floor-back)
    if (z.hasGoal && Math.abs(px) <= GW / 2 && py <= GH) continue;

    // Delta and distance
    var d0 = p - cHoriz, dy = py - cy;
    var dist = Math.sqrt(d0 * d0 + dy * dy);
    if (dist <= 0.01) continue;

    // Normal direction test: ensure car is on the concave side of the curve.
    // Equivalent to original per-zone checks (e.g. "dx < 0 || dy < 0" for floor-left).
    // Formula: !(A || B) skips zone; A = (d0 * d0Sign > 0), B = (dy * dySign > 0).
    // d0Sign encodes the expected horizontal direction; dySign = -1 (floor) or +1 (ceiling).
    var dySign = z.yFloor ? -1 : 1;
    if (!(d0 * z.d0Sign > 0 || dy * dySign > 0)) continue;

    if (z.isX) {
      _curveResult.normal.set(d0 / dist, dy / dist, 0);
      _curveResult.center.set(cHoriz, cy, pz);
    } else {
      _curveResult.normal.set(0, dy / dist, d0 / dist);
      _curveResult.center.set(px, cy, cHoriz);
    }
    _curveResult.dist = dist;
    _curveResult.radius = CR;
    return _curveResult;
  }

  return null;
}

// Deflect velocity off a curved surface normal (like a bounce but follows the curve)
function deflectOffCurve(vel, normal, bounce) {
  var dot = vel.dot(normal);
  if (dot < 0) { // moving into surface
    vel.addScaledVector(normal, -dot * (1 + bounce));
  }
}

// ==========================================================================
// WALL DRIVING HELPERS
// ==========================================================================
// Returns { tangentX, tangentZ, normal } vectors for each surface
// Pre-allocated surface axes to avoid per-frame garbage collection
var _surfaceAxesCache = {};
function _initSurfaceAxes() {
  _surfaceAxesCache['floor']   = { tx: new THREE.Vector3(1,0,0), tz: new THREE.Vector3(0,0,1), normal: new THREE.Vector3(0,1,0) };
  _surfaceAxesCache['ceiling'] = { tx: new THREE.Vector3(1,0,0), tz: new THREE.Vector3(0,0,-1), normal: new THREE.Vector3(0,-1,0) };
  _surfaceAxesCache['wallXn']  = { tx: new THREE.Vector3(0,1,0), tz: new THREE.Vector3(0,0,1), normal: new THREE.Vector3(1,0,0) };
  _surfaceAxesCache['wallXp']  = { tx: new THREE.Vector3(0,1,0), tz: new THREE.Vector3(0,0,-1), normal: new THREE.Vector3(-1,0,0) };
  _surfaceAxesCache['wallZn']  = { tx: new THREE.Vector3(1,0,0), tz: new THREE.Vector3(0,1,0), normal: new THREE.Vector3(0,0,1) };
  _surfaceAxesCache['wallZp']  = { tx: new THREE.Vector3(-1,0,0), tz: new THREE.Vector3(0,1,0), normal: new THREE.Vector3(0,0,-1) };
}
function getSurfaceAxes(surface) {
  return _surfaceAxesCache[surface] || _surfaceAxesCache['floor'];
}

// Turn sign correction per surface â€” ensures "left" always turns left visually
function surfaceTurnSign(surface) {
  // Floor and ceiling have same handedness (tx Ã— tz = -normal), walls are opposite
  switch (surface) {
    case 'floor': return 1;
    case 'ceiling': return 1;
    case 'wallXn': return -1;
    case 'wallXp': return -1;
    case 'wallZn': return -1;
    case 'wallZp': return -1;
    default: return 1;
  }
}

// Convert heading + speed to world velocity on any surface
var _surfVelResult = null; // pre-allocated after THREE.js loads
function surfaceVelocity(surface, heading, speed) {
  var axes = getSurfaceAxes(surface);
  if (!_surfVelResult) _surfVelResult = new THREE.Vector3();
  _surfVelResult.set(0, 0, 0);
  _surfVelResult.addScaledVector(axes.tx, Math.sin(heading) * speed);
  _surfVelResult.addScaledVector(axes.tz, Math.cos(heading) * speed);
  return _surfVelResult;
}

// Recalculate heading when transitioning to a new surface
function recalcHeadingForSurface(oldSurface, newSurface, heading, vel) {
  // Project current world velocity onto new surface tangent axes
  var axes = getSurfaceAxes(newSurface);
  var projX = vel.dot(axes.tx);
  var projZ = vel.dot(axes.tz);

  // If velocity has meaningful projection on new surface, use it
  if (Math.abs(projX) > 0.5 || Math.abs(projZ) > 0.5) {
    return Math.atan2(projX, projZ);
  }

  // Velocity was mostly perpendicular to new surface (e.g., driving straight into wall from floor)
  // Convert the old surface's forward direction onto the new surface
  var oldAxes = getSurfaceAxes(oldSurface);
  var oldFwd = _v4.set(0, 0, 0);
  oldFwd.addScaledVector(oldAxes.tx, Math.sin(heading));
  oldFwd.addScaledVector(oldAxes.tz, Math.cos(heading));
  // Also include the approach direction (old surface normal component of velocity)
  var approachSpeed = vel.dot(axes.normal); // speed into the wall
  var oldNormal = oldAxes.normal;
  // On the new surface, the old normal direction becomes a tangent direction
  var normalOnNewX = oldNormal.dot(axes.tx);
  var normalOnNewZ = oldNormal.dot(axes.tz);
  // Blend old forward direction with approach-based direction
  var fwdOnNewX = oldFwd.dot(axes.tx) + normalOnNewX * Math.abs(approachSpeed) * 0.1;
  var fwdOnNewZ = oldFwd.dot(axes.tz) + normalOnNewZ * Math.abs(approachSpeed) * 0.1;
  if (Math.abs(fwdOnNewX) > 0.01 || Math.abs(fwdOnNewZ) > 0.01) {
    return Math.atan2(fwdOnNewX, fwdOnNewZ);
  }
  // Fallback: go "upward" on the wall (project world up onto surface)
  return Math.atan2(axes.tx.y, axes.tz.y);
}

// Clamp car position within surface bounds; returns surface name if car should transition
function clampCarOnSurface(pos, vel, surface) {
  var hw = CW / 2 + 0.2;
  var hl = CL / 2 + 0.2;

  if (surface === 'wallXn') {
    // On left wall: car drives in Y-Z plane, X is fixed
    pos.x = -FW / 2 + hw; vel.x = 0;
    if (pos.y < CH / 2) { return 'floor'; }
    if (pos.y > WH - CH / 2) { pos.y = WH - CH / 2; return 'ceiling'; }
    if (pos.z > FL / 2 - hl) { return 'wallZp'; }
    if (pos.z < -FL / 2 + hl) { return 'wallZn'; }
  } else if (surface === 'wallXp') {
    pos.x = FW / 2 - hw; vel.x = 0;
    if (pos.y < CH / 2) { return 'floor'; }
    if (pos.y > WH - CH / 2) { pos.y = WH - CH / 2; return 'ceiling'; }
    if (pos.z > FL / 2 - hl) { return 'wallZp'; }
    if (pos.z < -FL / 2 + hl) { return 'wallZn'; }
  } else if (surface === 'wallZp') {
    // Front wall (+Z): car drives in X-Y plane
    pos.z = FL / 2 - hl; vel.z = 0;
    if (pos.y < CH / 2) { return 'floor'; }
    if (pos.y > WH - CH / 2) { pos.y = WH - CH / 2; return 'ceiling'; }
    if (pos.x < -FW / 2 + hw) { return 'wallXn'; }
    if (pos.x > FW / 2 - hw) { return 'wallXp'; }
    if (!hoopsActive && !dropshotActive && pos.y < GH && Math.abs(pos.x) < GW / 2) { return 'air'; }
  } else if (surface === 'wallZn') {
    pos.z = -FL / 2 + hl; vel.z = 0;
    if (pos.y < CH / 2) { return 'floor'; }
    if (pos.y > WH - CH / 2) { pos.y = WH - CH / 2; return 'ceiling'; }
    if (pos.x < -FW / 2 + hw) { return 'wallXn'; }
    if (pos.x > FW / 2 - hw) { return 'wallXp'; }
    if (!hoopsActive && !dropshotActive && pos.y < GH && Math.abs(pos.x) < GW / 2) { return 'air'; }
  } else if (surface === 'ceiling') {
    // Allow car below ceiling height during arc traversal; only clamp at the flat ceiling face
    if (pos.y >= WH - CH / 2) {
      pos.y = WH - CH / 2;
      if (vel.y > 0) vel.y = 0;
    }
    return null;
  }
  return null; // no transition
}

// Detect which wall the car is touching and at sufficient speed to attach
function detectWallAttach(pos, vel, speed) {
  var hw = CW / 2 + 0.5;
  var hl = CL / 2 + 0.5;
  var absSpeed = Math.abs(speed);
  var CR = CURVE_R;

  // On curved ramps: only skip wall attachment when car is in the lower part of the curve
  // (near floor). Allow wall attachment when car is near the top of the curve (transitioning to wall).
  var curveCheck = getCurveInfo(pos.x, pos.y, pos.z, 0);
  if (curveCheck && curveCheck.onCurve && curveCheck.dist < curveCheck.radius + CH) {
    // Check if car is in the floor-ramp zone (y < CURVE_R) â€” block wall attach there
    // But if y > CURVE_R * 0.7, car is high enough to transition to wall naturally
    if (pos.y < CR * 0.7) return null;
  }

  // Side walls â€” attach when near wall (including ramp zone), very permissive like RL
  if (pos.x <= -FW / 2 + hw + CR && pos.y > CR * 0.3 && absSpeed >= WALL_MIN_SPEED) {
    if (vel.x < -0.3 || (pos.y > CR && pos.x <= -FW / 2 + hw)) return 'wallXn';
  }
  if (pos.x >= FW / 2 - hw - CR && pos.y > CR * 0.3 && absSpeed >= WALL_MIN_SPEED) {
    if (vel.x > 0.3 || (pos.y > CR && pos.x >= FW / 2 - hw)) return 'wallXp';
  }
  // End walls (only where solid â€” above goal or to sides of goal)
  if (pos.z >= FL / 2 - hl - CR && pos.y > CR * 0.3 && absSpeed >= WALL_MIN_SPEED) {
    if (Math.abs(pos.x) >= GW / 2 || pos.y > GH) {
      if (vel.z > 0.3 || (pos.y > CR && pos.z >= FL / 2 - hl)) return 'wallZp';
    }
  }
  if (pos.z <= -FL / 2 + hl + CR && pos.y > CR * 0.3 && absSpeed >= WALL_MIN_SPEED) {
    if (Math.abs(pos.x) >= GW / 2 || pos.y > GH) {
      if (vel.z < -0.3 || (pos.y > CR && pos.z <= -FL / 2 + hl)) return 'wallZn';
    }
  }
  // Ceiling: no attachment â€” car falls off naturally (ceiling hard stop is in clampCar)

  return null;
}

// ==========================================================================
// PHYSICS UPDATE
// ==========================================================================
function updatePlayer(dt) {
  if (gameState !== 'playing') return;
  if (pDemoed) return; // demolished, skip physics

  // Powerslide (ground = floor or any surface)
  var pOnSurface = pSurface !== 'air';
  pPowerslide = isControl('powerslide') && pOnSurface;

  // Acceleration â€” blend analog trigger values for smooth gamepad control
  var accel = 0;
  var analogThrottle = getAnalogThrottle();
  if (gamepad.connected && analogThrottle !== 0) {
    // Analog triggers: proportional acceleration
    if (analogThrottle > 0) accel += CAR_ACCEL * analogThrottle;
    else accel += CAR_BRAKE * analogThrottle; // analogThrottle is negative = brake
  } else {
    if (isControl('forward')) accel += CAR_ACCEL;
    if (isControl('backward')) accel -= CAR_BRAKE;
  }

  // Heatseeker: unlimited boost (RL rule)
  if (activeGameMode === 'heatseeker') pBoost = BOOST_MAX;
  var canBoost = activeGameMode === 'heatseeker' ? true : (settings.boost === 0 ? false : (settings.boost === 2 || pBoost > 0));
  var boosting = isControl('boost') && canBoost && accel >= 0;
  if (boosting) {
    accel += CAR_ACCEL * 0.8;
    if (activeGameMode !== 'heatseeker' && settings.boost === 1) pBoost = Math.max(0, pBoost - BOOST_USE * dt);
    if (activeGameMode !== 'heatseeker' && settings.boost === 3) pBoost = Math.max(0, pBoost - BOOST_USE * 0.5 * dt);
    playBoostSound();
  } else {
    stopBoostSound();
    if (settings.boost === 3) pBoost = Math.min(BOOST_MAX, pBoost + 20 * dt);
  }

  // Non-linear acceleration (RL-style: punchy off the line, tapers at speed)
  var speedRatio = Math.abs(pSpeed) / ((boosting ? CAR_BOOST_MAX : CAR_THROTTLE_MAX) * CAR_SPEED_MULT);
  var accelFalloff = 1.0 - speedRatio * 0.55;
  pSpeed += accel * accelFalloff * dt;

  // Speed limits â€” throttle-only caps at CAR_THROTTLE_MAX, boost allows up to CAR_BOOST_MAX
  var maxSpd = (boosting ? CAR_BOOST_MAX : CAR_THROTTLE_MAX) * CAR_SPEED_MULT;
  // If not boosting but already above throttle max (from previous boost), coast down naturally
  if (!boosting && pSpeed > CAR_THROTTLE_MAX * CAR_SPEED_MULT) {
    maxSpd = Math.max(CAR_THROTTLE_MAX * CAR_SPEED_MULT, pSpeed); // don't hard-cap, let decel handle it
  }
  pSpeed = Math.max(-CAR_MAX * CAR_SPEED_MULT * 0.3, Math.min(pSpeed, maxSpd));

  // Deceleration â€” RL-style additive coasting/braking instead of multiplicative friction
  if (pPowerslide) {
    pSpeed *= Math.pow(0.993, dt * 60); // powerslide: low friction when drifting
  } else if (pOnSurface) {
    if (accel === 0 && Math.abs(pSpeed) > 0) {
      // Coasting deceleration (RL: ~525 uu/sÂ²)
      var coastDecel = 12 * dt; // tuned for game scale
      if (pSpeed > 0) pSpeed = Math.max(0, pSpeed - coastDecel);
      else pSpeed = Math.min(0, pSpeed + coastDecel);
    } else if ((accel > 0 && pSpeed < 0) || (accel < 0 && pSpeed > 0)) {
      // Braking (pressing opposite to travel): stronger decel (RL: ~3500 uu/sÂ²)
      var brakeDecel = 90 * dt;
      if (pSpeed > 0) pSpeed = Math.max(0, pSpeed - brakeDecel);
      else pSpeed = Math.min(0, pSpeed + brakeDecel);
    }
  } else {
    pSpeed *= Math.pow(CAR_AIR_FRIC, dt * 60); // air: minimal drag (frame-rate independent)
  }
  if (Math.abs(pSpeed) < 0.3 && accel === 0) pSpeed = 0;

  // Steering â€” RL-style speed-dependent curvature (tighter turns at low speed, wider at high speed)
  var absSpd = Math.abs(pSpeed);
  var turnRate;
  if (pPowerslide) {
    turnRate = CAR_TURN * 1.6 * Math.min(absSpd / 6, 1);
  } else {
    // RL curvature table scaled to game units: curvature decreases with speed
    // At speed 0: tight turns, at max speed: wide turns
    var spdFrac = absSpd / (CAR_BOOST_MAX * CAR_SPEED_MULT);
    var curvature;
    if (spdFrac < 0.22) curvature = 1.0 - spdFrac * 0.8;  // very tight at low speed
    else if (spdFrac < 0.44) curvature = 0.82 - (spdFrac - 0.22) * 1.5;
    else if (spdFrac < 0.65) curvature = 0.49 - (spdFrac - 0.44) * 1.1;
    else if (spdFrac < 0.76) curvature = 0.26 - (spdFrac - 0.65) * 0.8;
    else curvature = 0.17 - (spdFrac - 0.76) * 0.4;
    curvature = Math.max(curvature, 0.05); // minimum turn ability
    // Need some speed to turn at all
    var minTurnSpd = Math.min(absSpd / 3, 1);
    turnRate = CAR_TURN * curvature * minTurnSpd;
  }
  var turnDir = pSpeed >= 0 ? 1 : -1;
  var surfSign = surfaceTurnSign(pSurface);
  var analogSteer = getAnalogSteer();
  if (analogSteer !== 0) {
    // Analog steering â€” smooth proportional turns, with sensitivity curve
    var sens = settings.steeringSensitivity || 1.0;
    var steer = analogSteer;
    steer = (steer > 0 ? 1 : -1) * Math.pow(Math.abs(steer), sens);
    pRot += turnRate * dt * turnDir * surfSign * steer;
  } else {
    if (isControl('left')) pRot += turnRate * dt * turnDir * surfSign;
    if (isControl('right')) pRot -= turnRate * dt * turnDir * surfSign;
  }

  // Gamepad ball cam toggle (dynamic binding)
  if (gamepad.connected) {
    var bcBtn = settings.gamepadControls.ballcam;
    if (bcBtn) {
      var bcPrev = '_prev' + bcBtn.charAt(0).toUpperCase() + bcBtn.slice(1);
      if (gamepad[bcBtn] && !gamepad[bcPrev]) { ballCam = !ballCam; if (tutorialActive) tutorialProgress.ballCamToggled = true; }
    }
    // Gamepad rumble power-up activation (D-pad Up)
    if (gamepad.dpadUp && !gamepad._prevDpadUp && rumbleActive && playerPowerup && gameState === 'playing') {
      activateRumblePowerup('player');
    }
  }

  // Velocity from speed + rotation â€” surface-aware
  if (pOnSurface && pSurface !== 'floor') {
    // Wall/ceiling driving: velocity in surface-local axes
    var surfV = surfaceVelocity(pSurface, pRot, pSpeed);
    // On ceiling near a curve, project velocity along curve tangent (same fix as floor ramps)
    var _wallCurveInfo = getCurveInfo(pP.x, pP.y, pP.z, 0);
    var _onWallRamp = _wallCurveInfo && _wallCurveInfo.dist < _wallCurveInfo.radius + CH / 2 + 2;
    if (_onWallRamp) {
      var _wn = _wallCurveInfo.normal;
      // Project surface velocity onto curve tangent plane
      var _wdot = surfV.x * _wn.x + surfV.y * _wn.y + surfV.z * _wn.z;
      surfV.x -= _wdot * _wn.x; surfV.y -= _wdot * _wn.y; surfV.z -= _wdot * _wn.z;
    }
    if (pPowerslide) {
      pV.x += (surfV.x - pV.x) * 3.5 * dt;
      pV.y += (surfV.y - pV.y) * 3.5 * dt;
      pV.z += (surfV.z - pV.z) * 3.5 * dt;
    } else {
      pV.copy(surfV);
    }
    // RL-style: magnetic stick to surface â€” WALL_DETACH_GRACE handles ceiling exit like all walls
    // Wall detach: if speed too low, start grace timer
    if (Math.abs(pSpeed) < WALL_MIN_SPEED) {
      pWallGraceTimer += dt;
      var graceTime = WALL_DETACH_GRACE;
      if (pWallGraceTimer >= graceTime) {
        // Detach from surface â€” preserve flip (fell off without jumping)
        pSurface = 'air';
        pGround = false;
        pWallGraceTimer = 0;
        pCanDodge = true;
        pDodgeTimer = 999;
      }
    } else {
      pWallGraceTimer = 0;
    }
  } else {
    // Floor or air: velocity from speed
    // Check if car is on a curved ramp â€” redirect velocity along ramp surface
    var _rampInfo = pGround ? getCurveInfo(pP.x, pP.y, pP.z, 0) : null;
    var _onRamp = _rampInfo && _rampInfo.dist < _rampInfo.radius + CH / 2 + 2;

    if (_onRamp) {
      // Project forward direction onto ramp tangent plane (gives Y velocity to climb)
      var _rn = _rampInfo.normal;
      _v4.set(Math.sin(pRot), 0, Math.cos(pRot));
      var _fdn = _v4.x * _rn.x + _v4.y * _rn.y + _v4.z * _rn.z;
      _v4.x -= _fdn * _rn.x; _v4.y -= _fdn * _rn.y; _v4.z -= _fdn * _rn.z;
      var _flen = _v4.length();
      if (_flen > 0.01) { _v4.divideScalar(_flen); } else { _v4.set(Math.sin(pRot), 0, Math.cos(pRot)); }
      if (pPowerslide) {
        pV.x += (_v4.x * pSpeed - pV.x) * 3.5 * dt;
        pV.y += (_v4.y * pSpeed - pV.y) * 3.5 * dt;
        pV.z += (_v4.z * pSpeed - pV.z) * 3.5 * dt;
      } else {
        pV.x = _v4.x * pSpeed;
        pV.y = _v4.y * pSpeed;
        pV.z = _v4.z * pSpeed;
      }
      // Tangential gravity: surface absorbs perpendicular component, slope gravity remains
      var _gDotN = GRAV_ACTIVE * _rn.y;
      pV.x += (-_gDotN * _rn.x) * dt;
      pV.y += (GRAV_ACTIVE - _gDotN * _rn.y) * dt;
      pV.z += (-_gDotN * _rn.z) * dt;
    } else {
      if (pPowerslide) {
        var targetVx = Math.sin(pRot) * pSpeed;
        var targetVz = Math.cos(pRot) * pSpeed;
        pV.x += (targetVx - pV.x) * 3.5 * dt;
        pV.z += (targetVz - pV.z) * 3.5 * dt;
      } else {
        pV.x = Math.sin(pRot) * pSpeed;
        pV.z = Math.cos(pRot) * pSpeed;
      }
      // Gravity
      pV.y += GRAV_ACTIVE * dt;
    }
  }

  // RL-accurate aerial mechanics: angular velocity model with proper pitch/yaw/roll
  if (!pOnSurface) {
    var psHeld = isControl('powerslide');
    // Pitch: forward = nose up, backward = nose down
    var pitchInput = (isControl('forward') ? 1 : 0) - (isControl('backward') ? 1 : 0);
    // Cache left/right to avoid calling isControl twice
    var lrInput = (isControl('left') ? 1 : 0) - (isControl('right') ? 1 : 0);
    // Yaw: left/right when NOT air-rolling (powerslide remaps left/right to roll)
    var yawInput = psHeld ? 0 : lrInput;
    // Roll: airRollLeft/Right always roll; powerslide+left/right also roll; clamp to Â±1 to prevent stacking
    var rollInput = Math.max(-1, Math.min(1,
      (isControl('airRollLeft') ? 1 : 0) - (isControl('airRollRight') ? 1 : 0)
      + (psHeld ? lrInput : 0)
    ));

    // Single damping value shared by pitch and yaw (RL: damping off at full input)
    var damp = AIR_DAMP * dt;
    // Pitch angular velocity
    if (pitchInput !== 0) {
      pAngVelPitch += AIR_PITCH_ACC * pitchInput * dt;
    } else {
      pAngVelPitch = Math.abs(pAngVelPitch) <= damp ? 0 : pAngVelPitch - Math.sign(pAngVelPitch) * damp;
    }
    // Yaw angular velocity
    if (yawInput !== 0) {
      pAngVelYaw += AIR_YAW_ACC * yawInput * dt;
    } else {
      pAngVelYaw = Math.abs(pAngVelYaw) <= damp ? 0 : pAngVelYaw - Math.sign(pAngVelYaw) * damp;
    }
    // Roll angular velocity â€” always damped even with input (RL behaviour)
    if (rollInput !== 0) {
      pAngVelRoll += AIR_ROLL_ACC * rollInput * dt;
    }
    var rd = AIR_ROLL_DAMP * dt;
    pAngVelRoll = Math.abs(pAngVelRoll) <= rd ? 0 : pAngVelRoll - Math.sign(pAngVelRoll) * rd;

    // Clamp to max angular velocity
    pAngVelPitch = Math.max(-AIR_ANG_MAX, Math.min(AIR_ANG_MAX, pAngVelPitch));
    pAngVelYaw   = Math.max(-AIR_ANG_MAX, Math.min(AIR_ANG_MAX, pAngVelYaw));
    pAngVelRoll  = Math.max(-AIR_ANG_MAX, Math.min(AIR_ANG_MAX, pAngVelRoll));

    // Apply to orientation angles
    pPitch += pAngVelPitch * dt;
    pRot   += pAngVelYaw * dt;   // left = +pRot (matches ground steering convention)
    pRoll  += pAngVelRoll * dt;

    if (boosting) {
      // Boost thrust along nose direction: yaw + pitch, no artificial +Y gravity compensation
      var afd = CAR_ACCEL * 1.5 * dt; // aerial force Ã— dt, computed once
      var cosPitch = Math.cos(pPitch);
      pV.x += Math.sin(pRot) * cosPitch * afd;
      pV.z += Math.cos(pRot) * cosPitch * afd;
      pV.y += Math.sin(pPitch) * afd;
      // Clamp aerial speed
      var aerialSpd = pV.length();
      var maxAerial = CAR_BOOST_MAX * CAR_SPEED_MULT * 1.2;
      if (aerialSpd > maxAerial) pV.multiplyScalar(maxAerial / aerialSpd);
    }
  } else {
    resetAerialState(); // zero angles + angular velocities on landing
  }

  // Jump / Dodge (1.25s flip window like Rocket League)
  var jumpKey = isControl('jump');
  if (jumpKey && !keys['_jumpUsed']) {
    keys['_jumpUsed'] = true;
    if (pOnSurface) {
      // Jump away from surface normal (use curve normal if on ramp)
      var jumpCurve = getCurveInfo(pP.x, pP.y, pP.z, 0);
      var jumpNormal;
      if (jumpCurve && jumpCurve.onCurve && jumpCurve.dist < jumpCurve.radius + CH) {
        jumpNormal = jumpCurve.normal;
      } else {
        jumpNormal = getSurfaceAxes(pSurface).normal;
      }
      pV.addScaledVector(jumpNormal, JUMP_V);
      // Wall jumps: ensure upward lift so floor check doesn't recapture
      // Ceiling excluded: its jump normal is (0,-1,0), so pV.y is already negative (downward)
      if (pSurface !== 'floor' && pSurface !== 'ceiling') {
        pV.y = Math.max(pV.y, JUMP_V * 0.5);
      }
      pGround = false;
      pSurface = 'air';
      pCanDodge = true;
      pDodgeTimer = 1.5; // RL-accurate flip window
      pWallGraceTimer = 0;
      pJumpCooldown = 0.2; // prevent instant wall re-attach
      pJumpHoldTimer = 0.2; // RL hold-jump: extra lift for 0.2s while holding
      playJumpSound();
    } else if (pCanDodge && pDodgeTimer > 0) {
      pCanDodge = false;
      // Dodge direction based on movement input
      var dx = 0, dz = 0;
      if (isControl('forward')) dz += 1;
      if (isControl('backward')) dz -= 1;
      if (isControl('left')) dx += 1;
      if (isControl('right')) dx -= 1;
      if (dx !== 0 || dz !== 0) {
        // Directional flip
        var dodgeX = Math.sin(pRot) * dz + Math.cos(pRot) * dx;
        var dodgeZ = Math.cos(pRot) * dz - Math.sin(pRot) * dx;
        var len = Math.sqrt(dodgeX * dodgeX + dodgeZ * dodgeZ);
        dodgeX /= len; dodgeZ /= len;

        // Forward flip speed burst (RL mechanic: front flips add extra speed)
        var flipBonus = 1.0;
        if (dz > 0 && dx === 0) flipBonus = 1.4; // forward flip is fastest
        else if (dz > 0) flipBonus = 1.2;          // diagonal forward flip

        pV.x += dodgeX * DODGE_V * flipBonus;
        pV.z += dodgeZ * DODGE_V * flipBonus;
        // Cancel vertical momentum for snappier flips
        pV.y = 0;
        // Recalculate speed and heading from new velocity (prevents backflip turning car around)
        var flipSpd = Math.sqrt(pV.x * pV.x + pV.z * pV.z);
        if (flipSpd > 0.5) {
          // Check if velocity is roughly aligned with or against heading
          var headX = Math.sin(pRot), headZ = Math.cos(pRot);
          var alignment = pV.x * headX + pV.z * headZ;
          if (alignment >= 0) {
            pSpeed = flipSpd;
          } else {
            // Backflip: keep facing same way, speed becomes negative
            pSpeed = -flipSpd;
          }
        } else {
          pSpeed = flipSpd;
        }
        pSpin = 0.45;
        pFlipDirX = dx; pFlipDirZ = dz; // store for flip cancel
        playDodgeSound();
      } else {
        // No direction = double jump (straight up)
        pV.y = JUMP_V * 0.8;
        playJumpSound();
      }
    }
  }
  if (!jumpKey) keys['_jumpUsed'] = false;

  if (!pOnSurface) pDodgeTimer -= dt;
  if (pSpin > 0) {
    pSpin -= dt;
    // Flip cancel (half-flip): pulling stick opposite to flip direction cancels the spin
    var cancelDx = 0, cancelDz = 0;
    if (isControl('forward')) cancelDz += 1;
    if (isControl('backward')) cancelDz -= 1;
    if (isControl('left')) cancelDx += 1;
    if (isControl('right')) cancelDx -= 1;
    if ((cancelDx !== 0 || cancelDz !== 0) && (pFlipDirX !== 0 || pFlipDirZ !== 0)) {
      // Check if input is opposite to flip direction
      if (cancelDx * pFlipDirX + cancelDz * pFlipDirZ < -0.5) {
        pSpin = 0;
        pFlipDirX = 0; pFlipDirZ = 0;
      }
    }
  }
  if (pJumpCooldown > 0) pJumpCooldown -= dt;

  // RL-style hold-jump: continuous upward force while holding jump (variable height)
  if (pJumpHoldTimer > 0) {
    if (jumpKey) {
      pV.y += JUMP_V * 5 * dt; // extra lift while holding
      pJumpHoldTimer -= dt;
    } else {
      pJumpHoldTimer = 0; // released early â€” stop extra lift
    }
  }

  // Update position
  pP.x += pV.x * dt;
  pP.y += pV.y * dt;
  pP.z += pV.z * dt;

  // Surface check â€” landing, wall attachment, transitions
  var wasAirborne = !pGround && pSurface === 'air';

  if (pSurface === 'floor' || pSurface === 'air') {
    // Floor ground check
    var onFloor = pP.y <= CH / 2;
    // Also check curved ramp surfaces â€” car is grounded if touching the ramp
    var carCurve = getCurveInfo(pP.x, pP.y, pP.z, 0);
    var onRamp = false;
    if (!onFloor && carCurve && carCurve.onCurve && carCurve.dist < carCurve.radius + CH / 2 + 1.5
        && carCurve.center.y < WH / 2) { // ceiling curves (center.yâ‰ˆ19) never ground the car
      // On curved ramp â€” push to guaranteed clearance distance
      var rampPen = carCurve.radius + CH / 2 - carCurve.dist;
      if (rampPen > -1.0) {
        var targetDist = carCurve.radius + CH / 2 + 0.15;
        var pushAmt = targetDist - carCurve.dist;
        if (pushAmt > 0) pP.addScaledVector(carCurve.normal, pushAmt);
      }
      var rampDot = pV.dot(carCurve.normal);
      if (rampDot < 0) pV.addScaledVector(carCurve.normal, -rampDot * 1.05);
      onRamp = true;
    }
    if (onFloor || onRamp) {
      if (onFloor) pP.y = CH / 2;
      if (wasAirborne && pV.y < -5) {
        vibrateController(80, 0.3, 0.2); // light pulse on landing
        playLandingSound(Math.abs(pV.y));
        for (var li = 0; li < 6; li++) {
          spawnParticle(
            pP.x + (Math.random() - 0.5) * CW,
            0.2,
            pP.z + (Math.random() - 0.5) * CL,
            (Math.random() - 0.5) * 5, Math.random() * 3 + 1, (Math.random() - 0.5) * 5,
            0xaaaaaa, 0.4 + Math.random() * 0.3, 0.2 + Math.random() * 0.3
          );
        }
        if (Math.abs(pV.y) > 10) triggerScreenShake(0.15);
      }
      if (onFloor) pV.y = 0;
      pGround = true;

      // Ramp-to-wall transition: when curve normal becomes more horizontal than vertical,
      // the car has driven past 45Â° on the ramp â€” transition to wall surface.
      // Guard: pP.y >= CURVE_R*0.7 prevents immediate re-attachment after wallâ†’floor
      // transition (hysteresis: wallâ†’floor at pyâ‰ˆ2.5, floorâ†’wall blocked until pyâ‰¥3.5).
      if (onRamp && carCurve && Math.abs(pSpeed) >= WALL_MIN_SPEED && pP.y >= CURVE_R * 0.7) {
        var rn = carCurve.normal;
        var absNX = Math.abs(rn.x), absNY = Math.abs(rn.y), absNZ = Math.abs(rn.z);
        if (absNX > absNY * 1.1 || absNZ > absNY * 1.1) {
          // Normal is more horizontal than vertical â€” transition to wall
          var newWall = null;
          if (absNX >= absNZ) {
            newWall = rn.x < 0 ? 'wallXn' : 'wallXp';
          } else {
            newWall = rn.z < 0 ? 'wallZn' : 'wallZp';
          }
          var oldSurf = pSurface === 'air' ? 'floor' : pSurface;
          pSurface = newWall;
          pRot = recalcHeadingForSurface(oldSurf, newWall, pRot, pV);
          pSpeed = pV.length() * (pSpeed >= 0 ? 1 : -1);
          pWallGraceTimer = 0;
          pCanDodge = true;
          pDodgeTimer = 1.5;
        } else {
          if (pSurface === 'air') {
            pRot = Math.atan2(pV.x, pV.z) || pRot;
            pSpeed = Math.sqrt(pV.x * pV.x + pV.z * pV.z) * (pSpeed >= 0 ? 1 : -1);
          }
          pSurface = 'floor';
        }
      } else {
        if (pSurface === 'air') {
          pRot = Math.atan2(pV.x, pV.z) || pRot;
          pSpeed = Math.sqrt(pV.x * pV.x + pV.z * pV.z) * (pSpeed >= 0 ? 1 : -1);
        }
        pSurface = 'floor';
      }
    }

    // Wall attachment check â€” when car hits wall at speed, attach
    if ((pSurface === 'air' || pSurface === 'floor') && pJumpCooldown <= 0) {
      var attachWall = detectWallAttach(pP, pV, pSpeed);
      if (attachWall) {
        var oldSurface = pSurface;
        pSurface = attachWall;
        pGround = true;
        pRot = recalcHeadingForSurface(oldSurface, attachWall, pRot, pV);
        pSpeed = pV.length() * (pSpeed >= 0 ? 1 : -1);
        pWallGraceTimer = 0;
        pCanDodge = true;
        pDodgeTimer = 1.25;
      }
    }

    // Standard wall collisions for floor/air
    clampCar(pP, pV);
  } else {
    // On a wall or ceiling â€” check curves for smooth wall-to-floor transition
    var wallCurve = getCurveInfo(pP.x, pP.y, pP.z, 0);
    if (wallCurve && wallCurve.onCurve && wallCurve.dist < wallCurve.radius + CH / 2 + 1.5) {
      // Push car onto curve surface to guaranteed clearance â€” only if push stays inside arena
      var wallRampPen = wallCurve.radius + CH / 2 - wallCurve.dist;
      if (wallRampPen > -1.0) {
        var targetDist2 = wallCurve.radius + CH / 2 + 0.15;
        var pushAmt2 = targetDist2 - wallCurve.dist;
        if (pushAmt2 > 0) {
          var wNewX = pP.x + wallCurve.normal.x * pushAmt2;
          var wNewY = pP.y + wallCurve.normal.y * pushAmt2;
          var wNewZ = pP.z + wallCurve.normal.z * pushAmt2;
          if (wNewX > -FW / 2 && wNewX < FW / 2 && wNewY > CH / 2 && wNewY < WH) {
            pP.set(wNewX, wNewY, wNewZ);
          }
        }
      }
      var wallRampDot = pV.dot(wallCurve.normal);
      if (wallRampDot < 0) pV.addScaledVector(wallCurve.normal, -wallRampDot * 1.05);

      // Wallâ†’floor transition: wn.y < -0.5 fires at pyâ‰ˆ2.5 when clamped to wall face.
      // Ceiling arcs: excluded by center.y check; ceiling handled by clampCarOnSurface.
      if (wallCurve.center.y < WH / 2 && wallCurve.normal.y < -0.5) {
        var oldSurf2 = pSurface;
        pSurface = 'floor';
        pGround = true;
        pRot = recalcHeadingForSurface(oldSurf2, 'floor', pRot, pV);
        pSpeed = Math.sqrt(pV.x * pV.x + pV.z * pV.z) * (pSpeed >= 0 ? 1 : -1);
        pWallGraceTimer = 0;
      // Wallâ†’ceiling arc transition: fires mid-arc (wn.y > 0.5) so pV still has horizontal
      // component from arc redirect â€” recalcHeadingForSurface hits fast path instead of fallback,
      // preventing the abrupt 90Â° heading snap that occurred at the flat ceiling boundary.
      // pV.y > 0 guards: ceilingâ†’wall descent gives pV.y < 0 after arc redirect,
      // preventing oscillation when the car descends back through the arc from the ceiling side.
      } else if (pSurface !== 'ceiling' && wallCurve.center.y > WH / 2 && wallCurve.normal.y > 0.5 && pV.y > 0) {
        var oldSurf3 = pSurface;
        pSurface = 'ceiling';
        pGround = true;
        // Geometrically exact wallâ†’ceiling heading:
        // wall "up" (Y component) maps to "away from wall" (wall normal direction) on ceiling;
        // wall lateral (XZ) components pass through unchanged.
        // This is exact for all headings and all 4 walls â€” no dependency on arc-modified pV.
        var _wa3 = getSurfaceAxes(oldSurf3);
        var _sr3 = Math.sin(pRot), _cr3 = Math.cos(pRot);
        var _fy3 = _sr3 * _wa3.tx.y + _cr3 * _wa3.tz.y;
        pRot = Math.atan2(
          _sr3 * _wa3.tx.x + _cr3 * _wa3.tz.x + _wa3.normal.x * _fy3,
          -(_sr3 * _wa3.tx.z + _cr3 * _wa3.tz.z + _wa3.normal.z * _fy3)
        );
        pSpeed = pV.length() * (pSpeed >= 0 ? 1 : -1);
        pWallGraceTimer = 0;
      // Ceilingâ†’wall arc transition: symmetric to wallâ†’ceiling above.
      // Threshold 0.6 (not 0.5): at normal.x=0.6 the car is at Yâ‰ˆ23.36, safely below the
      // ceiling clamp boundary (23.55) â€” preventing clampCarOnSurface from snapping back.
      // pV.y < 0 confirms arc redirect has set descent; direction check picks the correct wall.
      } else if (pSurface === 'ceiling' && wallCurve.center.y > WH / 2 && pV.y < 0
                 && (Math.abs(wallCurve.normal.x) > 0.6 || Math.abs(wallCurve.normal.z) > 0.6)) {
        var ceilTarget = null;
        if      (wallCurve.normal.x >  0.6 && pV.x >  0) ceilTarget = 'wallXp';
        else if (wallCurve.normal.x < -0.6 && pV.x <  0) ceilTarget = 'wallXn';
        else if (wallCurve.normal.z >  0.6 && pV.z >  0) ceilTarget = 'wallZp';
        else if (wallCurve.normal.z < -0.6 && pV.z <  0) ceilTarget = 'wallZn';
        if (ceilTarget) {
          var oldSurf4 = pSurface;
          pSurface = ceilTarget;
          pGround = true;
          pRot = recalcHeadingForSurface(oldSurf4, ceilTarget, pRot, pV);
          pSpeed = pV.length() * (pSpeed >= 0 ? 1 : -1);
          pWallGraceTimer = 0;
        }
      }
    }

    // Standard surface transitions and clamping
    var transition = clampCarOnSurface(pP, pV, pSurface);
    // Ceilingâ†’wall: car drives into the wall-ceiling arc from the ceiling side
    // Primary check: arc zone + velocity direction (graceful arc transition)
    // Backstop check: wall face position (prevents tunneling at low lateral speed)
    if (pSurface === 'ceiling' && !transition && !(wallCurve && wallCurve.center.y > WH / 2)) {
      if      (pP.x <= -FW / 2 + CURVE_R && pV.x <= -WALL_MIN_SPEED) transition = 'wallXn';
      else if (pP.x >= FW / 2 - CURVE_R  && pV.x >=  WALL_MIN_SPEED) transition = 'wallXp';
      else if (pP.z >= FL / 2 - CURVE_R  && pV.z >=  WALL_MIN_SPEED) transition = 'wallZp';
      else if (pP.z <= -FL / 2 + CURVE_R && pV.z <= -WALL_MIN_SPEED) transition = 'wallZn';
      else if (pP.x <= -FW / 2 + CW / 2 + 0.5) transition = 'wallXn';
      else if (pP.x >= FW / 2 - CW / 2 - 0.5)  transition = 'wallXp';
      else if (pP.z >= FL / 2 - CL / 2 - 0.5)  transition = 'wallZp';
      else if (pP.z <= -FL / 2 + CL / 2 + 0.5) transition = 'wallZn';
    }
    if (transition) {
      var oldSurface = pSurface;
      if (transition === 'air') {
        pSurface = 'air';
        pGround = false;
        // Preserve flip when falling off surface without jumping (RL mechanic)
        if (pJumpCooldown <= 0) {
          pCanDodge = true;
          pDodgeTimer = 999; // indefinite flip window
        }
      } else if (transition === 'floor') {
        pSurface = 'floor';
        pGround = true;
        pRot = recalcHeadingForSurface(oldSurface, 'floor', pRot, pV);
        pSpeed = Math.sqrt(pV.x * pV.x + pV.z * pV.z) * (pSpeed >= 0 ? 1 : -1);
      } else {
        // Wall-to-wall or wall-to-ceiling transition
        pSurface = transition;
        pGround = true;
        pRot = recalcHeadingForSurface(oldSurface, transition, pRot, pV);
        pSpeed = pV.length() * (pSpeed >= 0 ? 1 : -1);
      }
      pWallGraceTimer = 0;
    }
  }

  // Reset position if stuck
  if (isControl('reset') && !keys['_rUsed']) {
    keys['_rUsed'] = true;
    pP.set(0, CH / 2, FL * 0.33);
    pV.set(0, 0, 0);
    pSpeed = 0; resetAerialState();
    pRot = Math.PI;
    pSurface = 'floor';
    pGround = true;
    _pSmoothNormal.set(0, 1, 0); _pOnCurve = false; _pSnapVisual = true;
  }
  if (!isControl('reset')) keys['_rUsed'] = false;

  // Boost trail
  if (boosting && Math.random() < 0.6) {
    spawnBoostTrail(playerCar, pRot, false);
  }

  // Powerslide smoke particles
  if (pPowerslide && Math.abs(pSpeed) > 8 && Math.random() < 0.5) {
    var _psNorm = getSurfaceAxes(pSurface === 'air' ? 'floor' : pSurface).normal;
    spawnParticle(
      pP.x + (Math.random() - 0.5) * CW + _psNorm.x * 0.3,
      pP.y + _psNorm.y * 0.3,
      pP.z + (Math.random() - 0.5) * CL + _psNorm.z * 0.3,
      (Math.random() - 0.5) * 4, Math.random() * 3 + 1, (Math.random() - 0.5) * 4,
      0x888888, 0.5 + Math.random() * 0.3, 0.3 + Math.random() * 0.4
    );
    playPowerslideScreech();
  }

  // Supersonic trail
  updateSupersonic();
  if (pSupersonic && Math.random() < 0.7) {
    spawnSupersonicTrail(playerCar, pRot);
  }

  // Smooth surface normal â€” used by camera and visuals to avoid snapping/spinning on curves
  var _visCurve = getCurveInfo(pP.x, pP.y, pP.z, 0);
  if (_visCurve && _visCurve.dist < _visCurve.radius + CH / 2 + 2.0) {
    _pOnCurve = true;
    _pSmoothNormal.lerp(_v5.copy(_visCurve.normal).negate(), Math.min(8 * dt, 1.0)).normalize();
  } else {
    _pOnCurve = false;
    var _surfN = getSurfaceAxes(pSurface === 'air' ? 'floor' : pSurface).normal;
    _pSmoothNormal.lerp(_surfN, Math.min(6 * dt, 1.0)).normalize();
  }
}

// Predict ball position after `t` seconds (with wall bounce simulation)
function predictBall(t) {
  var px = bP.x, py = bP.y, pz = bP.z;
  var vx = bV.x, vy = bV.y, vz = bV.z;
  var steps = Math.ceil(t * 30); // 30 substeps per second
  var subDt = t / steps;
  var hw = FW / 2 - BR_ACTIVE;
  var hl = FL / 2 - BR_ACTIVE;
  for (var i = 0; i < steps; i++) {
    vy += GRAV_ACTIVE * subDt;
    px += vx * subDt; py += vy * subDt; pz += vz * subDt;
    // Bounce off walls
    if (px < -hw) { px = -hw; vx = Math.abs(vx) * 0.6; }
    if (px > hw) { px = hw; vx = -Math.abs(vx) * 0.6; }
    // End walls (respect goal openings)
    if (pz > hl) {
      if (Math.abs(px) > GW / 2 || py > GH) { pz = hl; vz = -Math.abs(vz) * 0.6; }
    }
    if (pz < -hl) {
      if (Math.abs(px) > GW / 2 || py > GH) { pz = -hl; vz = Math.abs(vz) * 0.6; }
    }
    // Floor/ceiling
    if (py < BR_ACTIVE) { py = BR_ACTIVE; vy = Math.abs(vy) * 0.6; }
    if (py > WH - BR_ACTIVE) { py = WH - BR_ACTIVE; vy = -Math.abs(vy) * 0.6; }
  }
  return { x: px, y: py, z: pz };
}

function updateAI(dt) {
  if (gameState !== 'playing') return;
  if (aDemoed) return;

  AI_STATE_TIMER -= dt;
  AI_DODGE_COOLDOWN -= dt;

  // Process pending dodge timers (replaces setTimeout â€” respects slow-mo scaling)
  if (_aKickoffDodgeT > 0) {
    _aKickoffDodgeT -= dt;
    if (_aKickoffDodgeT <= 0 && !aDemoed && !aGround && gameState === 'playing') {
      aV.x += Math.sin(aRot) * DODGE_V * 1.4;
      aV.z += Math.cos(aRot) * DODGE_V * 1.4;
      aV.y = 0;
      aSpeed = Math.sqrt(aV.x * aV.x + aV.z * aV.z);
    }
  }
  if (_aClearFlipT > 0) {
    _aClearFlipT -= dt;
    if (_aClearFlipT <= 0 && !aDemoed && !aGround && gameState === 'playing') {
      aV.x += Math.sin(aRot) * DODGE_V * 1.5;
      aV.z += Math.cos(aRot) * DODGE_V * 1.5;
      aV.y = 0;
      aSpeed = Math.sqrt(aV.x * aV.x + aV.z * aV.z);
    }
  }
  if (_aSpeedDodgeT > 0) {
    _aSpeedDodgeT -= dt;
    if (_aSpeedDodgeT <= 0 && !aDemoed && !aGround && gameState === 'playing') {
      aV.x += _aSpeedDodgeX; aV.z += _aSpeedDodgeZ; aV.y = 0;
      aSpeed = Math.sqrt(aV.x * aV.x + aV.z * aV.z);
    }
  }
  if (_aDoubleJumpT > 0) {
    _aDoubleJumpT -= dt;
    if (_aDoubleJumpT <= 0 && !aDemoed && !aGround && gameState === 'playing') {
      aV.y += JUMP_V * 0.75;
    }
  }
  if (_aFlickT > 0) {
    _aFlickT -= dt;
    if (_aFlickT <= 0 && !aDemoed && !aGround && gameState === 'playing') {
      var fToBX = bP.x - aP.x;
      var fToBZ = bP.z - aP.z;
      var fToBL = Math.sqrt(fToBX * fToBX + fToBZ * fToBZ) || 1;
      aV.x += (fToBX / fToBL) * DODGE_V * 1.2;
      aV.z += (fToBZ / fToBL) * DODGE_V * 1.2;
      aV.y = DODGE_V * 0.3;
      aSpeed = Math.sqrt(aV.x * aV.x + aV.z * aV.z);
    }
  }

  var distToBall = Math.sqrt((bP.x - aP.x) * (bP.x - aP.x) + (bP.z - aP.z) * (bP.z - aP.z));
  var dist3D = Math.sqrt((bP.x - aP.x) * (bP.x - aP.x) + (bP.y - aP.y) * (bP.y - aP.y) + (bP.z - aP.z) * (bP.z - aP.z));
  var ballInAIHalf = bP.z < 0;
  var ballBehindAI = bP.z < aP.z - 5;
  var ballCloseToAIGoal = bP.z < -FL * 0.33;
  var ballHeadingToAIGoal = bV.z < -5;
  var aiLowBoost = aBoost < 20;

  // Ball prediction â€” look ahead based on distance
  var predTime = Math.min(distToBall / Math.max(Math.abs(aSpeed), 15), 2.0) * (0.6 + AI_REACT * 0.3);
  var pred = predictBall(predTime);

  // Corner detection: ball is in a corner or near wall in own half
  var ballInCorner = (Math.abs(bP.x) > FW * 0.3) && (Math.abs(bP.z) > FL * 0.3);
  var ballNearWallOwnHalf = bP.z < -FL * 0.15 && Math.abs(bP.x) > FW * 0.38 && Math.abs(bV.x) < 5 && Math.abs(bV.z) < 5;
  var ballInAICorner = (ballInCorner && bP.z < 0) || ballNearWallOwnHalf;
  var ballInPlayerCorner = ballInCorner && bP.z > 0;

  // State machine transitions â€” re-evaluate more often at higher difficulty
  var stateInterval = Math.max(0.15, 0.5 - AI_REACT * 0.15);
  if (AI_STATE_TIMER <= 0) {
    // Kickoff detection: ball near center with low speed (higher threshold for heatseeker serve)
    var kickoffSpeedThresh = activeGameMode === 'heatseeker' ? 30 : 2;
    if (Math.abs(bP.x) < 3 && Math.abs(bP.z) < 3 && bV.length() < kickoffSpeedThresh) {
      AI_STATE = 'kickoff';
      AI_STATE_TIMER = 1.5;
    } else if ((ballCloseToAIGoal && ballHeadingToAIGoal) || (ballBehindAI && distToBall < 25)) {
      AI_STATE = 'defend';
      AI_STATE_TIMER = stateInterval;
    } else if (ballInAICorner && distToBall < 30) {
      // Ball stuck in AI's corner â€” clear it by aiming toward center/opponent goal
      AI_STATE = 'clear';
      AI_STATE_TIMER = stateInterval;
    } else if (ballCloseToAIGoal) {
      AI_STATE = 'shadow';
      AI_STATE_TIMER = stateInterval;
    } else if (aiLowBoost && distToBall > 20 && !ballCloseToAIGoal && settings.boost !== 0 && settings.boost !== 2) {
      AI_STATE = 'boost_collect';
      AI_STATE_TIMER = 1.2;
    } else if (!ballInAIHalf && bP.z > aP.z + 10 && distToBall > 18) {
      AI_STATE = 'rotate';
      AI_STATE_TIMER = 0.8;
    } else if (AI_REACT >= 1.6 && !ballCloseToAIGoal && !ballInAIHalf
      && Math.abs(aSpeed) > CAR_MAX * 0.8 && distToBall > 25
      && Math.sqrt((pP.x - aP.x) * (pP.x - aP.x) + (pP.z - aP.z) * (pP.z - aP.z)) < 30
      && Math.random() < 0.15) {
      // Unfair AI: go for demo when supersonic and ball is far
      AI_STATE = 'demo';
      AI_STATE_TIMER = 2.0;
    } else {
      AI_STATE = 'chase';
      AI_STATE_TIMER = stateInterval;
    }
  }

  // Determine target based on state
  var targetX = pred.x, targetZ = pred.z;

  if (AI_STATE === 'kickoff') {
    // Drive straight at the ball center
    targetX = bP.x;
    targetZ = bP.z;
  } else if (AI_STATE === 'clear') {
    // Ball in own corner: drive AT the ball from the goal-side to clear it out
    // Target is the ball itself â€” we want a hard hit toward center/opponent side
    if (distToBall < 8) {
      // Close enough â€” just ram the ball
      targetX = pred.x;
      targetZ = pred.z;
    } else {
      // Approach from behind the ball (between ball and own goal)
      // so we hit it toward the opponent's half
      var clearDirX = pred.x - 0; // direction from center to ball
      var clearDirZ = pred.z - (-FL * 0.4);
      var clearLen = Math.sqrt(clearDirX * clearDirX + clearDirZ * clearDirZ) || 1;
      targetX = pred.x + (clearDirX / clearLen) * 3;
      targetZ = pred.z + (clearDirZ / clearLen) * 3;
      // Clamp target inside field
      targetX = Math.max(-FW * 0.45, Math.min(FW * 0.45, targetX));
      targetZ = Math.max(-FL * 0.45, Math.min(FL * 0.45, targetZ));
    }
  } else if (AI_STATE === 'chase') {
    // Position behind ball relative to opponent goal
    var goalTargetX = 0;
    if (AI_REACT >= 1.0) {
      goalTargetX = bP.x > 0 ? GW * 0.3 : -GW * 0.3;
    }
    var toGoalX = goalTargetX - pred.x;
    var toGoalZ = FL / 2 - pred.z;
    var len = Math.sqrt(toGoalX * toGoalX + toGoalZ * toGoalZ) || 1;
    var offset = Math.max(2, 5 - AI_REACT * 1.5);
    targetX = pred.x - (toGoalX / len) * offset;
    targetZ = pred.z - (toGoalZ / len) * offset;
    // Avoid chasing directly into walls â€” if target is near a wall, pull toward center
    if (Math.abs(targetX) > FW * 0.42) targetX *= 0.8;
    if (targetZ > FL * 0.42) targetZ = FL * 0.35;
  } else if (AI_STATE === 'defend') {
    // Rush to intercept ball â€” position between ball and goal
    var defX = pred.x * 0.6;
    var defZ = Math.min(pred.z - 4, -FL * 0.3);
    // If ball is very close to goal, go directly for it
    if (bP.z < -FL * 0.4 && distToBall < 20) {
      defX = pred.x;
      defZ = pred.z;
    }
    targetX = defX;
    targetZ = defZ;
  } else if (AI_STATE === 'shadow') {
    // RL-style shadow: stay between ball and goal, mirror opponent movement
    // Position yourself goal-side of the ball, tracking where the player is heading
    var shadowX = pP.x * 0.5 + bP.x * 0.3;
    var shadowZ = Math.min(bP.z - 10 - AI_REACT * 4, -FL * 0.12);
    // If player is boosting toward our goal, tighten up
    if (pV.z < -10) {
      shadowZ = Math.min(shadowZ, pP.z - 8);
      shadowX = pP.x * 0.6 + bP.x * 0.2;
    }
    targetX = shadowX;
    targetZ = shadowZ;
  } else if (AI_STATE === 'rotate') {
    // Rotate back to goal via the far side, picking up boost if possible
    var sideSign = aP.x > 0 ? -1 : 1;
    targetX = sideSign * FW * 0.3;
    targetZ = -FL * 0.25;
    // Look for boost on the way
    if (aBoost < 50) {
      var bestPad = null, bestDist = 999;
      boostPads.forEach(function(pad) {
        if (!pad.active) return;
        // Prefer pads in our rotation path
        var padDist = Math.sqrt((pad.x - aP.x) * (pad.x - aP.x) + (pad.z - aP.z) * (pad.z - aP.z));
        if (padDist < bestDist && pad.z < aP.z + 10) { bestDist = padDist; bestPad = pad; }
      });
      if (bestPad && bestDist < 15) {
        targetX = bestPad.x;
        targetZ = bestPad.z;
      }
    }
  } else if (AI_STATE === 'demo') {
    // Target the player's predicted position for a demo
    targetX = pP.x + pV.x * 0.5;
    targetZ = pP.z + pV.z * 0.5;
  } else if (AI_STATE === 'boost_collect') {
    var nearestDist = 9999, nearestPad = null;
    boostPads.forEach(function(pad) {
      if (!pad.active || !pad.big) return;
      var d = Math.sqrt((pad.x - aP.x) * (pad.x - aP.x) + (pad.z - aP.z) * (pad.z - aP.z));
      // Prefer pads in our half
      if (pad.z < 0) d *= 0.7;
      if (d < nearestDist) { nearestDist = d; nearestPad = pad; }
    });
    if (nearestPad && nearestDist < 50) {
      targetX = nearestPad.x;
      targetZ = nearestPad.z;
    } else {
      AI_STATE = 'chase';
      AI_STATE_TIMER = stateInterval;
    }
  }

  // Steer toward target
  var desiredRot = Math.atan2(targetX - aP.x, targetZ - aP.z);
  var angleDiff = desiredRot - aRot;
  while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
  while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

  // Powerslide for sharp turns (like real RL bots)
  var aiPowerslide = Math.abs(angleDiff) > 1.0 && Math.abs(aSpeed) > 8 && aGround && AI_REACT >= 0.6;
  var turnMult = aiPowerslide ? 2.0 : 1.0;
  // Speed-dependent turning â€” wider turns at high speed (like RL curvature)
  var aiSpeedRatio = Math.min(Math.abs(aSpeed) / (CAR_MAX * CAR_SPEED_MULT), 1);
  var turnFalloff = aiPowerslide ? 1.0 : Math.max(0.2, 1.0 - aiSpeedRatio * 0.6);
  var turnAmount = CAR_TURN * dt * Math.min(Math.abs(aSpeed) / 6, 1) * AI_REACT * turnMult * turnFalloff;
  if (Math.abs(angleDiff) < turnAmount) aRot = desiredRot;
  else aRot += Math.sign(angleDiff) * turnAmount;

  // Half-turn: if facing totally wrong way, reverse briefly then turn (like RL bots)
  var shouldReverse = Math.abs(angleDiff) > 2.5 && aGround && Math.abs(aSpeed) < 5;
  if (shouldReverse) {
    aSpeed -= CAR_BRAKE * 0.5 * dt; // reverse
    // Turn faster while reversing
    aRot += Math.sign(angleDiff) * CAR_TURN * 1.5 * dt;
  }

  // Accelerate â€” smarter boost decisions
  var closeEnoughToShoot = distToBall < (12 + AI_REACT * 5) && Math.abs(angleDiff) < 0.5;
  var aiBoosting = false;
  if (AI_STATE === 'kickoff') {
    aiBoosting = aBoost > 0;
  } else if (AI_STATE === 'chase') {
    aiBoosting = (distToBall > (15 - AI_REACT * 3) && aBoost > 12 && Math.abs(angleDiff) < 0.6)
      || (closeEnoughToShoot && aBoost > 5);
  } else if (AI_STATE === 'defend') {
    aiBoosting = (ballCloseToAIGoal && aBoost > 8) || (distToBall < 15 && aBoost > 5);
  } else if (AI_STATE === 'rotate') {
    aiBoosting = aBoost > 50 && Math.abs(angleDiff) < 0.4;
  } else if (AI_STATE === 'clear') {
    // Always boost toward ball to clear it hard
    aiBoosting = aBoost > 5 && Math.abs(angleDiff) < 0.8;
  } else if (AI_STATE === 'shadow') {
    aiBoosting = aBoost > 30 && distToBall > 20 && Math.abs(angleDiff) < 0.5;
  } else if (AI_STATE === 'demo') {
    aiBoosting = aBoost > 0 && Math.abs(angleDiff) < 0.4;
  }
  if (settings.boost === 0 && activeGameMode !== 'heatseeker') aiBoosting = false;

  // Brake if facing wrong direction
  var facingWrong = Math.abs(angleDiff) > 2.0 && !shouldReverse;
  if (facingWrong && aGround && !aiPowerslide) {
    aSpeed *= Math.pow(0.95, dt * 60); // decelerate (frame-rate independent)
  } else if (!shouldReverse) {
    // Non-linear acceleration like RL (punchy off the line, tapers at speed)
    var aiAccelRatio = Math.abs(aSpeed) / ((aiBoosting ? CAR_BOOST_MAX : CAR_MAX) * AI_MULT * CAR_SPEED_MULT);
    var aiAccelFalloff = 1.0 - aiAccelRatio * 0.5;
    aSpeed += CAR_ACCEL * AI_REACT * aiAccelFalloff * dt;
  }

  // Heatseeker: unlimited boost for AI too
  if (activeGameMode === 'heatseeker') aBoost = BOOST_MAX;
  if (aiBoosting && !facingWrong) {
    aSpeed += CAR_ACCEL * 0.7 * AI_REACT * dt;
    if (activeGameMode === 'heatseeker' || settings.boost === 2) { /* unlimited */ }
    else if (settings.boost === 3) aBoost = Math.max(0, aBoost - BOOST_USE * 0.5 * dt);
    else aBoost = Math.max(0, aBoost - BOOST_USE * dt);
  } else if (settings.boost === 3) {
    aBoost = Math.min(BOOST_MAX, aBoost + 20 * dt);
  }
  var aiMax = (aiBoosting ? CAR_BOOST_MAX : CAR_MAX) * AI_MULT * CAR_SPEED_MULT;
  aSpeed = Math.min(aSpeed, aiMax);
  aSpeed *= Math.pow(CAR_FRIC, dt * 60);

  // Kickoff flip â€” always front flip during kickoff when close enough
  if (AI_STATE === 'kickoff' && AI_DODGE_COOLDOWN <= 0 && aGround
    && distToBall < 25 && distToBall > 4
    && Math.abs(angleDiff) < 0.4 && aSpeed > CAR_MAX * 0.3) {
    aV.y = JUMP_V;
    aGround = false;
    AI_DODGE_COOLDOWN = 3;
    _aKickoffDodgeT = 0.12;
  }

  // AI close-range clear flip â€” when very close to ball in corner, flip into it
  if (AI_STATE === 'clear' && AI_DODGE_COOLDOWN <= 0 && aGround
    && distToBall < 10 && distToBall > 2
    && Math.abs(angleDiff) < 0.6 && aSpeed > CAR_MAX * 0.2) {
    aV.y = JUMP_V;
    aGround = false;
    AI_DODGE_COOLDOWN = 2.0;
    _aClearFlipT = 0.10;
  }

  // AI flip dodge for speed
  if ((AI_STATE === 'chase' || AI_STATE === 'clear') && AI_DODGE_COOLDOWN <= 0 && aGround
    && distToBall > 10 && distToBall < 45
    && Math.abs(angleDiff) < 0.25 && aSpeed > CAR_MAX * 0.4
    && Math.random() < (0.015 + AI_REACT * 0.02)) {
    aV.y = JUMP_V;
    aGround = false;
    AI_DODGE_COOLDOWN = 2.5;
    _aSpeedDodgeX = Math.sin(aRot) * DODGE_V * 1.3;
    _aSpeedDodgeZ = Math.cos(aRot) * DODGE_V * 1.3;
    _aSpeedDodgeT = 0.11 + Math.random() * 0.04;
  }

  // Velocity â€” project along ramp tangent if on a curve
  var _aiRamp = aGround ? getCurveInfo(aP.x, aP.y, aP.z, 0) : null;
  var _aiOnRamp = _aiRamp && _aiRamp.dist < _aiRamp.radius + CH / 2 + 2 && _aiRamp.center.y < WH / 2;
  if (_aiOnRamp) {
    var _arn = _aiRamp.normal;
    _v4.set(Math.sin(aRot), 0, Math.cos(aRot));
    var _afd = _v4.x * _arn.x + _v4.y * _arn.y + _v4.z * _arn.z;
    _v4.x -= _afd * _arn.x; _v4.y -= _afd * _arn.y; _v4.z -= _afd * _arn.z;
    var _aflen = _v4.length();
    if (_aflen > 0.01) { _v4.divideScalar(_aflen); } else { _v4.set(Math.sin(aRot), 0, Math.cos(aRot)); }
    aV.x = _v4.x * aSpeed; aV.y = _v4.y * aSpeed; aV.z = _v4.z * aSpeed;
    var _agdn = GRAV_ACTIVE * _arn.y;
    aV.x += (-_agdn * _arn.x) * dt;
    aV.y += (GRAV_ACTIVE - _agdn * _arn.y) * dt;
    aV.z += (-_agdn * _arn.z) * dt;
  } else {
    aV.x = Math.sin(aRot) * aSpeed;
    aV.z = Math.cos(aRot) * aSpeed;
    aV.y += GRAV_ACTIVE * dt;
  }

  // RL-style aerials
  var ballHeight = bP.y;
  var jumpChance = 0.015 + AI_REACT * 0.03;
  var aiAerial = false;

  if (aGround) {
    if (ballHeight > 3 && distToBall < 22 && Math.abs(angleDiff) < 0.8 && Math.random() < jumpChance) {
      aV.y = JUMP_V;
      aGround = false;

      if (AI_REACT >= 1.0 && ballHeight > 5 && distToBall < 18) {
        aV.y = JUMP_V * 1.15;
        if (AI_REACT >= 1.4 && ballHeight > 8) {
          _aDoubleJumpT = 0.14 + Math.random() * 0.03;
        }
      }
    }
    // Quick jump flick when very close to ball on ground (else if: prevent double-jump on same frame)
    else if (distToBall < 6 && ballHeight < 4 && ballHeight > 1.5 && Math.abs(angleDiff) < 0.5
      && Math.random() < 0.03 * AI_REACT && AI_DODGE_COOLDOWN <= 0) {
      aV.y = JUMP_V;
      aGround = false;
      AI_DODGE_COOLDOWN = 2.0;
      // Dodge into ball after short delay
      _aFlickT = 0.10;
    }
  } else {
    if (ballHeight > 4 && dist3D < 30 && aBoost > 5 && AI_REACT >= 0.8
      && settings.boost !== 0) {
      aiAerial = true;
      var toBallX = pred.x - aP.x;
      var toBallY = pred.y - aP.y;
      var toBallZ = pred.z - aP.z;
      var toBallLen = Math.sqrt(toBallX * toBallX + toBallY * toBallY + toBallZ * toBallZ) || 1;
      var aerialPower = CAR_ACCEL * (0.9 + AI_REACT * 0.4);

      aV.x += (toBallX / toBallLen) * aerialPower * dt;
      aV.y += (toBallY / toBallLen) * aerialPower * dt + 4 * dt;
      aV.z += (toBallZ / toBallLen) * aerialPower * dt;

      if (settings.boost === 2) { /* unlimited */ }
      else if (settings.boost === 3) aBoost = Math.max(0, aBoost - BOOST_USE * 0.5 * dt);
      else aBoost = Math.max(0, aBoost - BOOST_USE * dt);

      var aSpd = aV.length();
      if (aSpd > CAR_BOOST_MAX * AI_MULT * CAR_SPEED_MULT * 1.2) {
        aV.multiplyScalar(CAR_BOOST_MAX * AI_MULT * CAR_SPEED_MULT * 1.2 / aSpd);
      }
    }
  }

  // Update position
  aP.x += aV.x * dt;
  aP.y += aV.y * dt;
  aP.z += aV.z * dt;

  if (aP.y <= CH / 2) { aP.y = CH / 2; aV.y = 0; aGround = true; }
  clampCar(aP, aV);

  // Boost trail
  if ((aiBoosting || aiAerial) && Math.random() < 0.5) spawnBoostTrail(aiCar, aRot, true);
}

// Extra AI for 2v2 mode (simplified version of updateAI)
function updateExtraAI(dt, pos, vel, rot, speed, onGnd, bst, goalZ, isOrange, carIdx) {
  if (gameState !== 'playing') return;

  // Target: aim to hit ball toward opponent goal
  var targetX = bP.x;
  var targetZ = bP.z + (bP.z < pos.z ? -3 : 3) * (isOrange ? -1 : 1);

  // If ball is behind us, go defensive
  if ((isOrange && bP.z > pos.z + 5) || (!isOrange && bP.z < pos.z - 5)) {
    targetX = bP.x;
    targetZ = bP.z;
  }

  var desiredRot = Math.atan2(targetX - pos.x, targetZ - pos.z);
  var angleDiff = desiredRot - rot;
  while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
  while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

  var turnAmount = CAR_TURN * dt * 0.8;
  if (Math.abs(angleDiff) < turnAmount) rot = desiredRot;
  else rot += Math.sign(angleDiff) * turnAmount;

  // Extra AI boosting when chasing ball and facing right direction
  var _exDistBall = Math.sqrt((bP.x - pos.x) * (bP.x - pos.x) + (bP.z - pos.z) * (bP.z - pos.z));
  var _exBoosting = Math.abs(angleDiff) < 0.5 && _exDistBall < 40 && bst > 10
    && settings.boost !== 0 && activeGameMode !== 'heatseeker';
  if (_exBoosting) {
    speed += CAR_ACCEL * AI_REACT * 1.5 * dt;
    speed = Math.min(speed, CAR_BOOST_MAX * AI_MULT * CAR_SPEED_MULT * 0.9);
    if (settings.boost === 1) bst = Math.max(0, bst - BOOST_USE * dt);
    else if (settings.boost === 3) bst = Math.max(0, bst - BOOST_USE * 0.5 * dt);
  } else {
    speed += CAR_ACCEL * AI_REACT * 0.8 * dt;
    speed = Math.min(speed, CAR_MAX * AI_MULT * CAR_SPEED_MULT * 0.9);
  }
  if (settings.boost === 3) bst = Math.min(BOOST_MAX, bst + 20 * dt);
  speed *= Math.pow(CAR_FRIC, dt * 60);

  var _exRamp = onGnd ? getCurveInfo(pos.x, pos.y, pos.z, 0) : null;
  var _exOnRamp = _exRamp && _exRamp.dist < _exRamp.radius + CH / 2 + 2 && _exRamp.center.y < WH / 2;
  if (_exOnRamp) {
    var _en = _exRamp.normal;
    _v4.set(Math.sin(rot), 0, Math.cos(rot));
    var _ed = _v4.x * _en.x + _v4.y * _en.y + _v4.z * _en.z;
    _v4.x -= _ed * _en.x; _v4.y -= _ed * _en.y; _v4.z -= _ed * _en.z;
    var _el = _v4.length();
    if (_el > 0.01) { _v4.divideScalar(_el); } else { _v4.set(Math.sin(rot), 0, Math.cos(rot)); }
    vel.x = _v4.x * speed; vel.y = _v4.y * speed; vel.z = _v4.z * speed;
    var _egdn = GRAV_ACTIVE * _en.y;
    vel.x += (-_egdn * _en.x) * dt;
    vel.y += (GRAV_ACTIVE - _egdn * _en.y) * dt;
    vel.z += (-_egdn * _en.z) * dt;
  } else {
    vel.x = Math.sin(rot) * speed;
    vel.z = Math.cos(rot) * speed;
    vel.y += GRAV_ACTIVE * dt;
  }

  pos.x += vel.x * dt;
  pos.y += vel.y * dt;
  pos.z += vel.z * dt;

  if (pos.y <= CH / 2) { pos.y = CH / 2; vel.y = 0; }

  // Wall-tunneling safety: reflect velocity if car escapes arena bounds before clampCar
  var _exHW = FW / 2, _exHL = FL / 2;
  if (pos.x < -_exHW) { pos.x = -_exHW; if (vel.x < 0) vel.x = -vel.x; }
  if (pos.x >  _exHW) { pos.x =  _exHW; if (vel.x > 0) vel.x = -vel.x; }
  if (pos.z < -_exHL) { pos.z = -_exHL; if (vel.z < 0) vel.z = -vel.z; }
  if (pos.z >  _exHL) { pos.z =  _exHL; if (vel.z > 0) vel.z = -vel.z; }

  clampCar(pos, vel);

  // Store back (since JS passes objects by ref, pos/vel are updated in place)
  // But rot, speed, and boost are primitives â€” need to store them
  if (carIdx === 4) { a4Rot = rot; a4Speed = speed; a4Ground = pos.y <= CH / 2 + 0.1; a4Boost = bst; }
  else if (carIdx === 5) { a5Rot = rot; a5Speed = speed; a5Ground = pos.y <= CH / 2 + 0.1; a5Boost = bst; }
  else if (isOrange) { a2Rot = rot; a2Speed = speed; a2Ground = pos.y <= CH / 2 + 0.1; a2Boost = bst; }
  else { a3Rot = rot; a3Speed = speed; a3Ground = pos.y <= CH / 2 + 0.1; a3Boost = bst; }
}

// ==========================================================================
// GAME MODE SYSTEM
// ==========================================================================
function initGameMode() {
  activeGameMode = settings.gameMode || 'standard';

  // Reset all mode states
  heatseekerSpeed = HEATSEEKER_BASE_SPEED;
  heatseekerTarget = 0;
  snowdayActive = false;
  hoopsActive = false;
  rumbleActive = false;
  dropshotActive = false;
  playerPowerup = null;
  aiPowerup = null;
  playerPowerupTimer = 0;
  aiPowerupTimer = 0;
  playerSpikesAttached = false;
  aiSpikesAttached = false;
  ballFrozen = false;
  ballFreezeTimer = 0;
  _spikesTimerP = 0;
  _spikesTimerA = 0;

  // Clean up old mode meshes
  cleanupGameModeMeshes();

  // Mode-specific setup
  if (activeGameMode === 'snowday') {
    snowdayActive = true;
    recreateBallAsPuck();
  } else if (activeGameMode === 'hoops') {
    hoopsActive = true;
    createHoopsRings();
  } else if (activeGameMode === 'heatseeker') {
    // RL heatseeker: unlimited boost, first to 7, no timer
    WIN_SCORE = 7;
    gameTime = 99999;
    GAME_DURATION = 99999;
  } else if (activeGameMode === 'rumble') {
    rumbleActive = true;
    playerPowerupTimer = 5; // first power-up after 5s
    aiPowerupTimer = 7;
  } else if (activeGameMode === 'dropshot') {
    dropshotActive = true;
    dropshotHitCount = 0;
    dropshotBallPhase = 0;
    createDropshotTiles();
  }

  // Update HUD for game mode
  updateGameModeHUD();
}

function cleanupGameModeMeshes() {
  // Reset mode flags so they don't persist after cleanup
  hoopsActive = false;
  rumbleActive = false;
  dropshotActive = false;
  // Remove puck
  if (puckMesh) {
    scene.remove(puckMesh);
    if (puckMesh.geometry) puckMesh.geometry.dispose();
    if (puckMesh.material) puckMesh.material.dispose();
    puckMesh = null;
  }
  // Remove hoops rings
  hoopsRingMeshes.forEach(function(m) {
    scene.remove(m);
    if (m.geometry) m.geometry.dispose();
    if (m.material) m.material.dispose();
  });
  hoopsRingMeshes = [];
  // Remove dropshot tiles
  if (dropshotGroup) {
    scene.remove(dropshotGroup);
    dropshotGroup.traverse(function(obj) {
      if (obj.geometry) obj.geometry.dispose();
      if (obj.material) obj.material.dispose();
    });
    dropshotGroup = null;
    dropshotTiles = [];
  }
  // Make sure normal ball is visible
  if (ball) ball.visible = true;
}

function updateGameModeHUD() {
  var el = document.getElementById('gamemode-hud');
  if (!el) return;
  el.style.color = '#ffcc00'; // reset color (dropshot changes it)
  if (activeGameMode === 'rumble') {
    el.style.display = 'block';
    el.textContent = 'RUMBLE: --';
  } else if (activeGameMode === 'heatseeker') {
    el.style.display = 'block';
    el.textContent = 'HEATSEEKER';
  } else if (activeGameMode === 'snowday') {
    el.style.display = 'block';
    el.textContent = 'SNOW DAY';
  } else if (activeGameMode === 'hoops') {
    el.style.display = 'block';
    el.textContent = 'HOOPS';
  } else if (activeGameMode === 'dropshot') {
    el.style.display = 'block';
    el.textContent = 'DROPSHOT';
  } else {
    el.style.display = 'none';
  }
}

// --- HEATSEEKER ---
function updateHeatseeker(dt) {
  if (heatseekerTarget === 0) return; // no one has touched ball yet

  // Target: center of the opponent's goal
  var targetX = 0;
  var targetZ = heatseekerTarget > 0 ? FL / 2 : -FL / 2;
  var dx = targetX - bP.x;
  var dz = targetZ - bP.z;
  var distToGoal = Math.sqrt(dx * dx + dz * dz);

  // Normalize direction toward goal
  if (distToGoal > 0.1) {
    var dirX = dx / distToGoal;
    var dirZ = dz / distToGoal;

    // Blend current velocity direction toward goal direction
    var curSpd = Math.sqrt(bV.x * bV.x + bV.z * bV.z);
    if (curSpd > 0.1) {
      var curDirX = bV.x / curSpd;
      var curDirZ = bV.z / curSpd;
      // Stronger curve factor for tighter homing
      var blend = Math.min(1, HEATSEEKER_CURVE * dt / curSpd);
      var newDirX = curDirX + (dirX - curDirX) * blend;
      var newDirZ = curDirZ + (dirZ - curDirZ) * blend;
      // Re-normalize blended direction
      var newLen = Math.sqrt(newDirX * newDirX + newDirZ * newDirZ);
      if (newLen > 0.01) {
        newDirX /= newLen;
        newDirZ /= newLen;
      }
      var targetSpd = Math.min(heatseekerSpeed, HEATSEEKER_MAX_SPEED);
      bV.x = newDirX * targetSpd;
      bV.z = newDirZ * targetSpd;
    } else {
      // Ball is nearly stopped in XZ â€” launch it toward goal
      var targetSpd = Math.min(heatseekerSpeed, HEATSEEKER_MAX_SPEED);
      bV.x = dirX * targetSpd;
      bV.z = dirZ * targetSpd;
    }
  }

  // Dampen Y velocity â€” heatseeker ball should stay low
  bV.y *= Math.pow(0.9, dt * 60);
}

function onHeatseekerTouch(toucherTeam) {
  // Ball now targets the opposite team's goal
  if (toucherTeam === 'orange') {
    heatseekerTarget = -1; // toward blue (AI) goal at -Z
  } else {
    heatseekerTarget = 1; // toward orange (player) goal at +Z
  }
  heatseekerSpeed = Math.min(heatseekerSpeed + HEATSEEKER_SPEED_INC, HEATSEEKER_MAX_SPEED);
}

// --- SNOW DAY ---
function recreateBallAsPuck() {
  if (ball) ball.visible = false;

  // Create puck (short cylinder)
  var puckGeo = new THREE.CylinderGeometry(BR * 1.1, BR * 1.1, BR * 0.5, 24);
  var puckMat = new THREE.MeshPhysicalMaterial({
    color: 0x222222, roughness: 0.15, metalness: 0.8,
    emissive: 0x111111, emissiveIntensity: 0.1,
    clearcoat: 0.5
  });
  puckMesh = new THREE.Mesh(puckGeo, puckMat);
  puckMesh.castShadow = true;
  scene.add(puckMesh);
}

function updateSnowDay(dt) {
  // Puck follows ball position
  if (puckMesh) {
    puckMesh.position.copy(bP);
    puckMesh.rotation.y += bV.x * dt * 0.1;
    puckMesh.rotation.x += bV.z * dt * 0.1;
  }
  // Extra ground friction â€” puck stays low
  if (bP.y <= BR_ACTIVE + 0.5) {
    bV.x *= Math.pow(0.994, dt * 60);
    bV.z *= Math.pow(0.994, dt * 60);
  }
  // Reduced bounce â€” puck bounces lower than ball but still bounces
  if (bP.y <= BR_ACTIVE + 0.1 && bV.y > 0 && bV.y < 2) {
    bV.y *= 0.3; // kill only very small bounces to settle puck
  } else if (bP.y <= BR_ACTIVE + 0.1 && bV.y > 0) {
    bV.y *= 0.7; // dampen larger bounces (puck bounces lower than ball)
  }
}

// --- HOOPS ---
function createHoopsRings() {
  // Orange hoop (player's end, +Z)
  var ringGeo = new THREE.TorusGeometry(HOOPS_RING_RADIUS, 0.3, 8, 32);
  var orangeRingMat = new THREE.MeshStandardMaterial({ color: 0xff6600, emissive: 0xff3300, emissiveIntensity: 0.5, metalness: 0.8, roughness: 0.2 });
  var orangeRing = new THREE.Mesh(ringGeo, orangeRingMat);
  orangeRing.position.set(0, HOOPS_RING_HEIGHT, FL / 2 - 3);
  orangeRing.rotation.x = Math.PI / 2;
  scene.add(orangeRing);
  hoopsRingMeshes.push(orangeRing);

  // Blue hoop (AI's end, -Z)
  var blueRingMat = new THREE.MeshStandardMaterial({ color: 0x0066ff, emissive: 0x0033ff, emissiveIntensity: 0.5, metalness: 0.8, roughness: 0.2 });
  var blueRing = new THREE.Mesh(ringGeo, blueRingMat);
  blueRing.position.set(0, HOOPS_RING_HEIGHT, -FL / 2 + 3);
  blueRing.rotation.x = Math.PI / 2;
  scene.add(blueRing);
  hoopsRingMeshes.push(blueRing);

  // Net visual (simple cone below each ring)
  var netGeo = new THREE.ConeGeometry(HOOPS_RING_RADIUS * 0.8, 4, 16, 1, true);
  var netMat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.3 });
  var orangeNet = new THREE.Mesh(netGeo, netMat);
  orangeNet.position.set(0, HOOPS_RING_HEIGHT - 2, FL / 2 - 3);
  scene.add(orangeNet);
  hoopsRingMeshes.push(orangeNet);

  var blueNet = new THREE.Mesh(netGeo.clone(), netMat.clone());
  blueNet.position.set(0, HOOPS_RING_HEIGHT - 2, -FL / 2 + 3);
  scene.add(blueNet);
  hoopsRingMeshes.push(blueNet);
}

function checkHoopsGoal() {
  // Ball must pass through ring from above (downward velocity)
  if (bV.y > -4) return null; // must be falling with decent speed

  // Check orange ring (player's goal at +Z)
  var dzP = Math.abs(bP.z - (FL / 2 - 3));
  var dyP = Math.abs(bP.y - HOOPS_RING_HEIGHT);
  var dxP = Math.abs(bP.x);
  if (dzP < 2 && dyP < 2 && dxP < HOOPS_RING_RADIUS) {
    return 'ai'; // blue team scores
  }

  // Check blue ring (AI's goal at -Z)
  var dzA = Math.abs(bP.z - (-FL / 2 + 3));
  var dyA = Math.abs(bP.y - HOOPS_RING_HEIGHT);
  var dxA = Math.abs(bP.x);
  if (dzA < 2 && dyA < 2 && dxA < HOOPS_RING_RADIUS) {
    return 'player'; // orange team scores
  }

  return null;
}

// --- RUMBLE ---
function updateRumble(dt) {
  // Cooldown timers
  if (!playerPowerup && playerPowerupTimer > 0) {
    playerPowerupTimer -= dt;
    if (playerPowerupTimer <= 0) {
      playerPowerup = RUMBLE_POWERUPS[Math.floor(Math.random() * RUMBLE_POWERUPS.length)];
      updateRumbleHUD();
    }
  }
  if (!aiPowerup && aiPowerupTimer > 0) {
    aiPowerupTimer -= dt;
    if (aiPowerupTimer <= 0) {
      aiPowerup = RUMBLE_POWERUPS[Math.floor(Math.random() * RUMBLE_POWERUPS.length)];
    }
  }

  // Ball freeze timer â€” use unscaled _frameDt so slow-mo doesn't extend freeze duration
  if (ballFrozen) {
    ballFreezeTimer -= _frameDt;
    bV.set(0, 0, 0); // keep ball frozen (overrides gravity)
    if (ballFreezeTimer <= 0) {
      ballFrozen = false;
      ballFreezeTimer = 0;
    }
  }

  // AI uses power-up with type-aware strategy
  if (aiPowerup && gameState === 'playing') {
    var _aDistToBall = Math.sqrt((aP.x - bP.x) * (aP.x - bP.x) + (aP.z - bP.z) * (aP.z - bP.z));
    var _ballInAIGoalZone = bP.z < -FL / 4;  // ball threatening AI goal
    var _ballInPlayerHalf = bP.z > 0;        // ball on player's side â€” good time to attack
    var _useNow = false;
    switch (aiPowerup) {
      case 'haymaker':
        // Offensive â€” use when ball is on player's half or near player goal
        _useNow = _ballInPlayerHalf || _aDistToBall < 20;
        break;
      case 'freeze':
        // Defensive â€” freeze ball when it threatens AI goal or AI is in position
        _useNow = _ballInAIGoalZone || (_aDistToBall < 12 && !_ballInPlayerHalf);
        break;
      case 'spikes':
        // Offensive â€” grab ball when close and in neutral/player half
        _useNow = _aDistToBall < 10 && !_ballInAIGoalZone;
        break;
      case 'boot':
        // Use boot when player car is close to AI goal (defensive) or AI is near player
        var _pDistToAIGoal = Math.abs(pP.z + FL / 2);
        _useNow = _pDistToAIGoal < 20 || _aDistToBall < 15;
        break;
      default:
        _useNow = _aDistToBall < 15 || _ballInAIGoalZone;
    }
    if (_useNow) activateRumblePowerup('ai');
  }

  // Spikes: ball sticks to car (timer-based, safe across game state changes)
  // Freeze takes priority â€” spikes don't move ball while frozen
  if (playerSpikesAttached && !ballFrozen) {
    _spikesTimerP -= dt;
    bP.set(pP.x + Math.sin(pRot) * CL * 0.6, pP.y + CH, pP.z + Math.cos(pRot) * CL * 0.6);
    bV.set(pV.x, pV.y, pV.z);
    if (_spikesTimerP <= 0) {
      playerSpikesAttached = false;
      bV.set(pV.x + Math.sin(pRot) * 20, pV.y + 5, pV.z + Math.cos(pRot) * 20);
    }
  }
  if (aiSpikesAttached && !ballFrozen) {
    _spikesTimerA -= dt;
    bP.set(aP.x + Math.sin(aRot) * CL * 0.6, aP.y + CH, aP.z + Math.cos(aRot) * CL * 0.6);
    bV.set(aV.x, aV.y, aV.z);
    if (_spikesTimerA <= 0) {
      aiSpikesAttached = false;
      bV.set(aV.x + Math.sin(aRot) * 20, aV.y + 5, aV.z + Math.cos(aRot) * 20);
    }
  }
}

function activateRumblePowerup(who) {
  var powerup = who === 'player' ? playerPowerup : aiPowerup;
  if (!powerup) return;

  var targetCar = who === 'player' ? { p: pP, v: pV } : { p: aP, v: aV };
  var enemyCar = who === 'player' ? { p: aP, v: aV } : { p: pP, v: pV };

  switch (powerup) {
    case 'freeze':
      // Freeze ball in place for 3 seconds (timer-based, no setTimeout)
      ballFrozen = true;
      ballFreezeTimer = 3.0;
      bV.set(0, 0, 0);
      break;

    case 'spikes':
      // Ball attaches to car for 5 seconds (RL uses ~10s but that's too dominant in 1v1; 5s allows reaching goal without free scoring)
      if (who === 'player') {
        playerSpikesAttached = true;
        _spikesTimerP = 5.0;
      } else {
        aiSpikesAttached = true;
        _spikesTimerA = 5.0;
      }
      break;

    case 'boot':
      // Kick enemy car into the air (skip if already demoed)
      var _enemyDemoed = who === 'player' ? aDemoed : pDemoed;
      if (!_enemyDemoed) {
        enemyCar.v.y = 30;
        enemyCar.v.x += (Math.random() - 0.5) * 20;
        enemyCar.v.z += (Math.random() - 0.5) * 20;
      }
      break;

    case 'haymaker':
      // Punch ball hard toward enemy goal
      var goalZ = who === 'player' ? -FL / 2 : FL / 2;
      var dx = 0 - bP.x;
      var dz = goalZ - bP.z;
      var dist = Math.sqrt(dx * dx + dz * dz);
      if (dist > 0.1) {
        bV.x = (dx / dist) * 70;
        bV.z = (dz / dist) * 70;
        bV.y = 10;
      }
      break;
  }

  // Reset power-up
  if (who === 'player') {
    playerPowerup = null;
    playerPowerupTimer = RUMBLE_COOLDOWN;
  } else {
    aiPowerup = null;
    aiPowerupTimer = RUMBLE_COOLDOWN;
  }
  updateRumbleHUD();
}

function updateRumbleHUD() {
  var el = document.getElementById('gamemode-hud');
  if (!el) return;
  if (playerPowerup) {
    var names = { freeze: 'FREEZE', spikes: 'SPIKES', boot: 'BOOT', haymaker: 'HAYMAKER' };
    var activateHint = gamepad.connected ? '[E / D-pad Up]' : '[E]';
    // Show active duration remaining for duration-based powerups
    var durationStr = '';
    if (playerSpikesAttached) durationStr = ' (' + Math.ceil(_spikesTimerP) + 's)';
    else if (ballFrozen) durationStr = ' (' + Math.ceil(ballFreezeTimer) + 's)';
    el.textContent = 'RUMBLE: ' + (names[playerPowerup] || '--') + durationStr + ' ' + activateHint;
    el.style.color = '#ffcc00';
  } else if (playerPowerupTimer > 0) {
    el.textContent = 'RUMBLE: ' + Math.ceil(playerPowerupTimer) + 's...';
    el.style.color = '#888';
  } else {
    el.textContent = 'RUMBLE: recharging...';
    el.style.color = '#888';
  }
}

// --- DROPSHOT ---
function createDropshotTiles() {
  if (dropshotGroup) {
    scene.remove(dropshotGroup);
    dropshotGroup.traverse(function(obj) {
      if (obj.geometry) obj.geometry.dispose();
      if (obj.material) obj.material.dispose();
    });
  }
  dropshotGroup = new THREE.Group();
  dropshotTiles = [];

  var hexR = DROPSHOT_HEX_SIZE;
  // Shared hex geometry (6-sided circle = flat-top hexagon), laid flat on XZ plane
  var hexShape = new THREE.Shape();
  for (var i = 0; i < 6; i++) {
    var angle = (Math.PI / 3) * i;
    var hx = hexR * 0.93 * Math.cos(angle);
    var hz = hexR * 0.93 * Math.sin(angle);
    if (i === 0) hexShape.moveTo(hx, hz);
    else hexShape.lineTo(hx, hz);
  }
  hexShape.closePath();
  var hexGeo = new THREE.ShapeGeometry(hexShape);
  hexGeo.rotateX(-Math.PI / 2); // lay flat

  // Flat-top hex grid spacing
  var colSpacing = 1.5 * hexR;
  var rowSpacing = Math.sqrt(3) * hexR;

  // Calculate grid size to fill field
  var numCols = Math.floor((FW - hexR) / colSpacing) + 1;
  var numRows = Math.floor((FL - hexR) / rowSpacing) + 1;
  if (numCols % 2 === 0) numCols--; // keep odd for symmetry
  if (numRows % 2 === 0) numRows--; // keep odd for symmetry

  var startX = -(numCols - 1) * colSpacing / 2;
  var startZ = -(numRows - 1) * rowSpacing / 2;

  for (var col = 0; col < numCols; col++) {
    for (var row = 0; row < numRows; row++) {
      var x = startX + col * colSpacing;
      var z = startZ + row * rowSpacing + (col % 2 ? rowSpacing * 0.5 : 0);

      // Skip tiles outside field (with margin for ramps)
      if (Math.abs(x) > FW / 2 - CURVE_R - hexR * 0.3) continue;
      if (Math.abs(z) > FL / 2 - CURVE_R - hexR * 0.3) continue;
      // Skip center tile row (neutral zone)
      if (Math.abs(z) < hexR * 0.3) continue;

      var team = z > 0 ? 'orange' : 'blue';
      var baseColor = team === 'orange' ? 0xff6622 : 0x2266ff;

      var mat = new THREE.MeshStandardMaterial({
        color: baseColor,
        emissive: baseColor,
        emissiveIntensity: 0.15,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.85
      });

      var mesh = new THREE.Mesh(hexGeo.clone(), mat);
      mesh.position.set(x, 0.08, z);
      mesh.receiveShadow = true;
      dropshotGroup.add(mesh);

      dropshotTiles.push({
        x: x, z: z,
        team: team,
        state: 0,
        mesh: mesh,
        baseColor: baseColor
      });
    }
  }

  hexGeo.dispose();
  scene.add(dropshotGroup);
}

function resetDropshotTiles() {
  for (var i = 0; i < dropshotTiles.length; i++) {
    var tile = dropshotTiles[i];
    tile.state = 0;
    updateTileVisual(tile);
  }
  dropshotHitCount = 0;
  dropshotBallPhase = 0;
  dropshotFallTile = null;
}

function updateTileVisual(tile) {
  if (!tile.mesh) return;
  if (tile.state === 0) {
    // Intact
    tile.mesh.material.color.setHex(tile.baseColor);
    tile.mesh.material.emissive.setHex(tile.baseColor);
    tile.mesh.material.emissiveIntensity = 0.15;
    tile.mesh.material.opacity = 0.85;
    tile.mesh.visible = true;
  } else if (tile.state === 1) {
    // Damaged â€” cracked appearance
    var crackColor = tile.team === 'orange' ? 0xaa3300 : 0x0033aa;
    tile.mesh.material.color.setHex(crackColor);
    tile.mesh.material.emissive.setHex(crackColor);
    tile.mesh.material.emissiveIntensity = 0.4;
    tile.mesh.material.opacity = 0.6;
    tile.mesh.visible = true;
  } else {
    // Open â€” hole in floor
    tile.mesh.material.color.setHex(0x111111);
    tile.mesh.material.emissive.setHex(0x000000);
    tile.mesh.material.emissiveIntensity = 0;
    tile.mesh.material.opacity = 0.15;
    tile.mesh.visible = true;
  }
}

function getDropshotTileAt(x, z) {
  var bestTile = null;
  var bestDist = DROPSHOT_HEX_SIZE;
  for (var i = 0; i < dropshotTiles.length; i++) {
    var t = dropshotTiles[i];
    var dx = x - t.x, dz = z - t.z;
    var d = Math.sqrt(dx * dx + dz * dz);
    if (d < bestDist) { bestDist = d; bestTile = t; }
  }
  return bestTile;
}

function getDropshotTilesNear(x, z, phase) {
  // Phase 0: 1 tile, Phase 1: ~7 tiles, Phase 2: ~19 tiles
  var radius;
  if (phase >= 2) radius = DROPSHOT_HEX_SIZE * 3.5;
  else if (phase >= 1) radius = DROPSHOT_HEX_SIZE * 2.2;
  else radius = DROPSHOT_HEX_SIZE * 0.9;

  var result = [];
  for (var i = 0; i < dropshotTiles.length; i++) {
    var t = dropshotTiles[i];
    var dx = x - t.x, dz = z - t.z;
    if (Math.sqrt(dx * dx + dz * dz) < radius) result.push(t);
  }
  return result;
}

function updateDropshot(dt) {
  if (!dropshotActive) return;

  // Ball phase increases based on aerial hits (hits while ball is airborne)
  if (dropshotHitCount >= 6) dropshotBallPhase = 2;
  else if (dropshotHitCount >= 2) dropshotBallPhase = 1;
  else dropshotBallPhase = 0;

  // Update HUD
  var el = document.getElementById('gamemode-hud');
  if (el) {
    var phaseNames = ['DROPSHOT', 'DROPSHOT - CHARGED', 'DROPSHOT - SUPER CHARGED'];
    el.textContent = phaseNames[dropshotBallPhase] || 'DROPSHOT';
    el.style.color = dropshotBallPhase >= 2 ? '#ff2200' : dropshotBallPhase >= 1 ? '#ffaa00' : '#ffcc00';
  }
}

function dropshotFloorCheck() {
  // Called when ball hits the floor in updateBall
  // Returns true if ball should fall through (open tile), false otherwise
  if (!dropshotActive) return false;

  // Only check tiles in the flat floor zone (not ramp/corner zones)
  if (Math.abs(bP.x) > FW / 2 - CURVE_R || Math.abs(bP.z) > FL / 2 - CURVE_R) return false;

  var tile = getDropshotTileAt(bP.x, bP.z);
  if (!tile) return false;

  // Open tile â€” ball falls through, store which tile for scoring
  if (tile.state === 2) { dropshotFallTile = tile; return true; }

  // Ball has charge â€” damage tiles on impact
  if (dropshotHitCount > 0) {
    var tilesHit = getDropshotTilesNear(bP.x, bP.z, dropshotBallPhase);
    var anyDamaged = false;
    for (var i = 0; i < tilesHit.length; i++) {
      var t = tilesHit[i];
      // Only damage opponent's tiles (based on last touch team)
      var isAttack = (lastTouchTeam === 'orange' && t.team === 'blue') ||
                     (lastTouchTeam === 'blue' && t.team === 'orange');
      if (isAttack && t.state < 2) {
        t.state++;
        updateTileVisual(t);
        anyDamaged = true;
      }
    }
    // Reset ball charge after floor impact
    dropshotHitCount = 0;
    dropshotBallPhase = 0;

    // Impact visual feedback only when tiles were actually damaged
    if (anyDamaged) {
      triggerScreenShake(0.3);
      playBounceSound(15);
    }
  }

  return false;
}

function updateBall(dt) {
  if (gameState !== 'playing') {
    if (gameState === 'countdown') {
      bP.set(0, BR_ACTIVE, 0);
      if (activeGameMode !== 'heatseeker') bV.set(0, 0, 0); // heatseeker serve set in game loop, not wiped here
    }
    return;
  }

  // Gravity
  bV.y += GRAV_ACTIVE * dt;

  // Air drag (all axes) â€” frame-rate independent
  var dragFactor = Math.pow(BALL_DRAG, dt * 60);
  bV.x *= dragFactor;
  bV.y *= dragFactor;
  bV.z *= dragFactor;

  // Ground roll friction â€” frame-rate independent
  if (bP.y <= BR_ACTIVE + 0.3 && Math.abs(bV.y) < 2) {
    var rollFric = Math.pow(0.997, dt * 60);
    bV.x *= rollFric; bV.z *= rollFric;
  }

  // Game mode updates
  if (activeGameMode === 'heatseeker') updateHeatseeker(dt);
  if (activeGameMode === 'snowday') updateSnowDay(dt);
  if (activeGameMode === 'rumble') updateRumble(dt);
  if (activeGameMode === 'dropshot') updateDropshot(dt);

  // High-speed goal detection â€” check if ball crosses goal line this frame
  // (disabled in hoops mode â€” hoops uses ring detection instead)
  // (disabled in dropshot â€” scoring via floor holes only)
  var prevZ = bP.z;
  var nextZ = bP.z + bV.z * dt;
  var goalLineP = FL / 2;   // player's goal
  var goalLineA = -FL / 2;  // AI's goal
  if (gameState === 'playing' && !hoopsActive && !dropshotActive) {
    // Check player goal crossing (ball moving +Z)
    if (prevZ < goalLineP && nextZ >= goalLineP) {
      var t = (goalLineP - prevZ) / (nextZ - prevZ);
      var crossX = bP.x + bV.x * dt * t;
      var crossY = bP.y + bV.y * dt * t;
      if (Math.abs(crossX) < GW / 2 && crossY < GH && crossY > 0) {
        // Ball crosses goal line into goal â€” if it overshoots the entire goal box, force the goal
        if (nextZ > goalLineP + GD) {
          bP.set(crossX, crossY, goalLineP + 1);
          bV.z = Math.abs(bV.z) * 0.5;
          onGoal('ai');
          return;
        }
      }
    }
    // Check AI goal crossing (ball moving -Z)
    if (prevZ > goalLineA && nextZ <= goalLineA) {
      var t2 = (goalLineA - prevZ) / (nextZ - prevZ);
      var crossX2 = bP.x + bV.x * dt * t2;
      var crossY2 = bP.y + bV.y * dt * t2;
      if (Math.abs(crossX2) < GW / 2 && crossY2 < GH && crossY2 > 0) {
        // Ball will enter AI's goal â€” ensure it registers
        // Place ball just past goal line so the detection below catches it
        if (nextZ < goalLineA - GD) {
          bP.set(crossX2, crossY2, goalLineA - 1);
          bV.z = -Math.abs(bV.z) * 0.5;
          onGoal('player');
          return;
        }
      }
    }
    // Same for player's goal with very fast ball (ball already past line at frame start)
    if (prevZ > goalLineP && nextZ > goalLineP + GD && Math.abs(bP.x) < GW / 2 && bP.y < GH) {
      bP.set(bP.x, bP.y, goalLineP + 1);
      bV.z = Math.abs(bV.z) * 0.5;
      onGoal('ai');
      return;
    }
    // Same for AI's goal with very fast ball (ball already past line at frame start)
    if (prevZ < goalLineA && nextZ < goalLineA - GD && Math.abs(bP.x) < GW / 2 && bP.y < GH) {
      bP.set(bP.x, bP.y, goalLineA - 1);
      bV.z = -Math.abs(bV.z) * 0.5;
      onGoal('player');
      return;
    }
  }

  // Update position
  bP.x += bV.x * dt;
  bP.y += bV.y * dt;
  bP.z += bV.z * dt;

  // === Curved surface collision (ball rolls smoothly up ramps) ===
  var curveHandled = false;
  var curveHit = getCurveInfo(bP.x, bP.y, bP.z, BR_ACTIVE);
  if (curveHit && curveHit.onCurve) {
    var penetration = curveHit.radius - curveHit.dist + BR_ACTIVE;
    if (penetration > 0) {
      // Only apply curve push if it keeps ball within arena bounds
      var newX = bP.x + curveHit.normal.x * penetration;
      var newY = bP.y + curveHit.normal.y * penetration;
      var newZ = bP.z + curveHit.normal.z * penetration;
      if (newY >= BR_ACTIVE && newY <= WH - BR_ACTIVE &&
          newX >= -FW / 2 + BR_ACTIVE && newX <= FW / 2 - BR_ACTIVE) {
        // Push ball out along curve normal
        bP.set(newX, newY, newZ);
        // Deflect velocity â€” gentle impacts roll along curve, hard impacts bounce
        var dot = bV.dot(curveHit.normal);
        if (dot < 0) {
          var impactSpd = Math.abs(dot);
          // Roll factor: 0 at low speed (pure redirect), 1 at high speed (full bounce)
          var rollFactor = Math.min(1, impactSpd / 8);
          var curveBounce = 1.0 + BOUNCE_ACTIVE * rollFactor;
          bV.addScaledVector(curveHit.normal, -dot * curveBounce);
          bV.multiplyScalar(BALL_FRIC);
          if (impactSpd > 8) playWallHitSound();
        }
        curveHandled = true;
      }
      // If push goes out of bounds, fall through to flat checks
    }
  }

  // Floor bounce (flat section only â€” curve handled above)
  if (bP.y <= BR_ACTIVE && !curveHandled && bP.x > -FW / 2 + CURVE_R && bP.x < FW / 2 - CURVE_R
      && bP.z > -FL / 2 + CURVE_R && bP.z < FL / 2 - CURVE_R) {
    // Dropshot: check if ball should fall through open tile
    if (dropshotActive && dropshotFloorCheck()) {
      // Ball falls through open tile â€” don't bounce, let it fall
      // Score when ball drops well below floor
    } else {
      var floorImpact = Math.abs(bV.y);
      bP.y = BR_ACTIVE;
      bV.y = -bV.y * BOUNCE_ACTIVE;
      if (activeGameMode === 'snowday') bV.y *= 0.65; // puck bounces lower
      bV.x *= BALL_FRIC;
      bV.z *= BALL_FRIC;
      if (Math.abs(bV.y) < 1) bV.y = 0;
      if (floorImpact > 3) playBounceSound(floorImpact);
    }
  } else if (bP.y <= BR_ACTIVE && !curveHandled) {
    if (dropshotActive && dropshotFloorCheck()) {
      // Ball falls through open tile
    } else {
      var floorImpact2 = Math.abs(bV.y);
      bP.y = BR_ACTIVE;
      if (bV.y < 0) { bV.y = -bV.y * BOUNCE_ACTIVE; if (activeGameMode === 'snowday') bV.y *= 0.65; bV.x *= BALL_FRIC; bV.z *= BALL_FRIC; }
      if (floorImpact2 > 3) playBounceSound(floorImpact2);
    }
  }

  // Dropshot: ball fell through floor â€” score goal
  if (dropshotActive && bP.y < -BR_ACTIVE * 3 && gameState === 'playing') {
    var fallTile = dropshotFallTile || getDropshotTileAt(bP.x, bP.z);
    if (fallTile) {
      if (fallTile.team === 'orange') onGoal('ai');
      else onGoal('player');
    } else {
      // Fallback: use last touch team to determine who caused the breach, then field position
      if (lastTouchTeam === 'orange') onGoal('player');      // orange hit ball through their own floor
      else if (lastTouchTeam === 'blue') onGoal('ai');       // blue hit ball through their own floor
      else if (bP.z > 0) onGoal('ai');
      else onGoal('player');
    }
    return;
  }

  // Ceiling â€” RL-style: ball rolls on ceiling, gravity pulls it down naturally
  if (bP.y >= WH - BR_ACTIVE) {
    bP.y = WH - BR_ACTIVE;
    if (bV.y > 0) {
      if (bV.y < 5) {
        // Low impact: roll on ceiling (zero perpendicular, apply surface friction)
        bV.y = 0;
        var _sf = Math.pow(0.995, dt * 60); bV.x *= _sf; bV.z *= _sf;
      } else {
        bV.y = -bV.y * BOUNCE_ACTIVE;
      }
    }
  }

  // Rounded corner collision â€” RL has smooth curved corners
  var cR = CORNER_R;
  var corners = [
    { cx: -FW/2 + cR, cz: -FL/2 + cR }, // back-left
    { cx: FW/2 - cR, cz: -FL/2 + cR },  // back-right
    { cx: FW/2 - cR, cz: FL/2 - cR },   // front-right
    { cx: -FW/2 + cR, cz: FL/2 - cR }   // front-left
  ];
  for (var ci = 0; ci < 4; ci++) {
    var cc = corners[ci];
    // Only apply if ball is in the corner zone (past both wall lines)
    var inCornerX = (cc.cx < 0) ? (bP.x < cc.cx) : (bP.x > cc.cx);
    var inCornerZ = (cc.cz < 0) ? (bP.z < cc.cz) : (bP.z > cc.cz);
    if (inCornerX && inCornerZ) {
      var cdx = bP.x - cc.cx, cdz = bP.z - cc.cz;
      var cdist = Math.sqrt(cdx * cdx + cdz * cdz);
      if (cdist > cR - BR_ACTIVE && cdist > 0.01) {
        // Push ball out along corner circle normal
        var cnx = cdx / cdist, cnz = cdz / cdist;
        bP.x = cc.cx + cnx * (cR - BR_ACTIVE);
        bP.z = cc.cz + cnz * (cR - BR_ACTIVE);
        // Deflect velocity off the curved corner wall
        var cdot = bV.x * cnx + bV.z * cnz;
        if (cdot > 0) {
          bV.x -= cnx * cdot * (1 + BOUNCE_ACTIVE);
          bV.z -= cnz * cdot * (1 + BOUNCE_ACTIVE);
          bV.x *= BALL_FRIC; bV.z *= BALL_FRIC;
          if (Math.abs(cdot) > 5) playWallHitSound();
        }
      }
    }
  }

  // Side walls â€” RL-style: ball rolls on walls (skip corner zones and curve-handled)
  var inCornerZoneZ = bP.z < -FL/2 + cR || bP.z > FL/2 - cR;
  if (bP.x <= -FW / 2 + BR_ACTIVE && bP.y > CURVE_R && !inCornerZoneZ && !curveHandled) {
    bP.x = -FW / 2 + BR_ACTIVE;
    if (bV.x < 0) {
      if (Math.abs(bV.x) < 5) {
        bV.x = 0;
        var _wsf1 = Math.pow(0.995, dt * 60); bV.y *= _wsf1; bV.z *= _wsf1;
      } else {
        bV.x = Math.abs(bV.x) * BOUNCE_ACTIVE;
        playWallHitSound();
      }
    }
  }
  if (bP.x >= FW / 2 - BR_ACTIVE && bP.y > CURVE_R && !inCornerZoneZ && !curveHandled) {
    bP.x = FW / 2 - BR_ACTIVE;
    if (bV.x > 0) {
      if (Math.abs(bV.x) < 5) {
        bV.x = 0;
        var _wsf2 = Math.pow(0.995, dt * 60); bV.y *= _wsf2; bV.z *= _wsf2;
      } else {
        bV.x = -Math.abs(bV.x) * BOUNCE_ACTIVE;
        playWallHitSound();
      }
    }
  }

  // End walls (with goal openings, skip corner zones)
  // In hoops mode, there are no ground goals â€” all end walls are solid
  var inCornerZoneX = bP.x < -FW/2 + cR || bP.x > FW/2 - cR;
  var hasGroundGoals = !hoopsActive && !dropshotActive;
  // Player's end (z = FL/2)
  if (bP.z >= FL / 2 - BR_ACTIVE && !inCornerZoneX && (bP.y > CURVE_R || !curveHandled)) {
    if (hasGroundGoals && Math.abs(bP.x) < GW / 2 && bP.y < GH) {
      // In goal opening â€” allow through
      if (bP.z >= FL / 2 + GD - BR_ACTIVE) {
        bP.z = FL / 2 + GD - BR_ACTIVE;
        bV.z = -Math.abs(bV.z) * BOUNCE_ACTIVE;
      }
      if (bP.z > FL / 2 + 1 && gameState === 'playing') {
        onGoal('ai');
      }
    } else {
      // Solid end wall (backboard) â€” roll or bounce
      bP.z = FL / 2 - BR_ACTIVE;
      if (bV.z > 0) {
        if (bV.z < 5 && activeGameMode !== 'heatseeker') {
          bV.z = 0; var _esf1 = Math.pow(0.995, dt * 60); bV.x *= _esf1; bV.y *= _esf1;
        } else {
          bV.z = -Math.abs(bV.z) * BOUNCE_ACTIVE;
          playWallHitSound();
          // Heatseeker backboard: reverse target (no speed increase â€” only car touches increase speed)
          if (activeGameMode === 'heatseeker' && heatseekerTarget !== 0) {
            heatseekerTarget = -1; // now heads toward AI goal
          }
        }
      }
    }
  }

  // AI's end (z = -FL/2)
  if (bP.z <= -FL / 2 + BR_ACTIVE && !inCornerZoneX && (bP.y > CURVE_R || !curveHandled)) {
    if (hasGroundGoals && Math.abs(bP.x) < GW / 2 && bP.y < GH) {
      if (bP.z <= -FL / 2 - GD + BR_ACTIVE) {
        bP.z = -FL / 2 - GD + BR_ACTIVE;
        bV.z = Math.abs(bV.z) * BOUNCE_ACTIVE;
      }
      if (bP.z < -FL / 2 - 1 && gameState === 'playing') {
        onGoal('player');
      }
    } else {
      bP.z = -FL / 2 + BR_ACTIVE;
      if (bV.z < 0) {
        if (Math.abs(bV.z) < 5 && activeGameMode !== 'heatseeker') {
          bV.z = 0; var _esf2 = Math.pow(0.995, dt * 60); bV.x *= _esf2; bV.y *= _esf2;
        } else {
          bV.z = Math.abs(bV.z) * BOUNCE_ACTIVE;
          playWallHitSound();
          // Heatseeker backboard: reverse target (no speed increase â€” only car touches increase speed)
          if (activeGameMode === 'heatseeker' && heatseekerTarget !== 0) {
            heatseekerTarget = 1; // now heads toward player goal
          }
        }
      }
    }
  }

  // Goal box side walls
  if (bP.z > FL / 2 && bP.z < FL / 2 + GD) {
    if (bP.x < -GW / 2 + BR_ACTIVE) { bP.x = -GW / 2 + BR_ACTIVE; bV.x = Math.abs(bV.x) * BOUNCE_ACTIVE; }
    if (bP.x > GW / 2 - BR_ACTIVE) { bP.x = GW / 2 - BR_ACTIVE; bV.x = -Math.abs(bV.x) * BOUNCE_ACTIVE; }
  }
  if (bP.z < -FL / 2 && bP.z > -FL / 2 - GD) {
    if (bP.x < -GW / 2 + BR_ACTIVE) { bP.x = -GW / 2 + BR_ACTIVE; bV.x = Math.abs(bV.x) * BOUNCE_ACTIVE; }
    if (bP.x > GW / 2 - BR_ACTIVE) { bP.x = GW / 2 - BR_ACTIVE; bV.x = -Math.abs(bV.x) * BOUNCE_ACTIVE; }
  }

  // Goal box crossbar (ceiling) â€” prevent ball flying above GH inside goal
  if (hasGroundGoals) {
    if ((bP.z > FL / 2 && bP.z < FL / 2 + GD) || (bP.z < -FL / 2 && bP.z > -FL / 2 - GD)) {
      if (Math.abs(bP.x) < GW / 2 && bP.y > GH - BR_ACTIVE) {
        bP.y = GH - BR_ACTIVE;
        if (bV.y > 0) bV.y = -bV.y * BOUNCE_ACTIVE;
      }
    }
  }

  // Hoops goal check â€” ball must pass through elevated ring from above
  if (hoopsActive && gameState === 'playing') {
    var hoopsScorer = checkHoopsGoal();
    if (hoopsScorer) {
      onGoal(hoopsScorer);
      return;
    }
  }

  // Speed clamp
  var bSpd = bV.length();
  var maxBallSpd = activeGameMode === 'heatseeker' ? HEATSEEKER_MAX_SPEED + 20 : 100;
  if (bSpd > maxBallSpd) bV.multiplyScalar(maxBallSpd / bSpd);

  // Safety clamp â€” absolute boundary enforcement to prevent ball escaping
  var safeHW = FW / 2 - BR_ACTIVE;
  var safeHL = FL / 2 - BR_ACTIVE;
  if (bP.x < -safeHW) { bP.x = -safeHW; if (bV.x < 0) bV.x = 0; }
  if (bP.x > safeHW) { bP.x = safeHW; if (bV.x > 0) bV.x = 0; }
  var _dsTile = dropshotActive && bP.y < BR_ACTIVE ? getDropshotTileAt(bP.x, bP.z) : null;
  var dropshotFalling = _dsTile && _dsTile.state === 2;
  if (bP.y < BR_ACTIVE && !dropshotFalling) { bP.y = BR_ACTIVE; if (bV.y < 0) bV.y = 0; }
  if (bP.y > WH - BR_ACTIVE) { bP.y = WH - BR_ACTIVE; if (bV.y > 0) bV.y = 0; }
  // Z bounds: allow into goal boxes but clamp beyond them (hoops has no goal boxes)
  var inGoalOpening = hasGroundGoals && Math.abs(bP.x) < GW / 2 && bP.y < GH;
  var zMax = inGoalOpening ? FL / 2 + GD - BR_ACTIVE : safeHL;
  var zMin = inGoalOpening ? -(FL / 2 + GD - BR_ACTIVE) : -safeHL;
  if (bP.z > zMax) { bP.z = zMax; if (bV.z > 0) bV.z = 0; }
  if (bP.z < zMin) { bP.z = zMin; if (bV.z < 0) bV.z = 0; }
}

function clampCar(pos, vel) {
  var hw = CW / 2 + 0.2;
  var hl = CL / 2 + 0.2;

  // Rounded corner collision for car (horizontal XZ corners)
  var cR = CORNER_R;
  var carCorners = [
    { cx: -FW/2 + cR, cz: -FL/2 + cR },
    { cx: FW/2 - cR, cz: -FL/2 + cR },
    { cx: FW/2 - cR, cz: FL/2 - cR },
    { cx: -FW/2 + cR, cz: FL/2 - cR }
  ];
  for (var ci = 0; ci < 4; ci++) {
    var cc = carCorners[ci];
    var inCX = (cc.cx < 0) ? (pos.x < cc.cx) : (pos.x > cc.cx);
    var inCZ = (cc.cz < 0) ? (pos.z < cc.cz) : (pos.z > cc.cz);
    if (inCX && inCZ) {
      var cdx = pos.x - cc.cx, cdz = pos.z - cc.cz;
      var cdist = Math.sqrt(cdx * cdx + cdz * cdz);
      if (cdist > cR - hw && cdist > 0.01) {
        var cnx = cdx / cdist, cnz = cdz / cdist;
        pos.x = cc.cx + cnx * (cR - hw);
        pos.z = cc.cz + cnz * (cR - hw);
        var cdot = vel.x * cnx + vel.z * cnz;
        if (cdot > 0) { vel.x -= cnx * cdot; vel.z -= cnz * cdot; }
      }
    }
  }

  // Corner zone guards â€” skip flat wall clamping where corner arc handles it
  var inCornerZoneZ = pos.z < -FL/2 + CORNER_R || pos.z > FL/2 - CORNER_R;
  var inCornerZoneX = pos.x < -FW/2 + CORNER_R || pos.x > FW/2 - CORNER_R;

  // Vertical curve zone guards â€” skip flat wall clamps in ramp zones (ramp code handles them).
  // Mirrors ball physics: ball side-wall clamps use bP.y > CURVE_R to stay out of curve zones.
  var inFloorCurveZone = pos.y < CURVE_R;
  var inCeilCurveZone  = pos.y > WH - CURVE_R;

  // Side walls (flat section â€” above floor curve, below ceiling curve)
  if (pos.x < -FW / 2 + hw && !inCornerZoneZ && !inFloorCurveZone && !inCeilCurveZone) { pos.x = -FW / 2 + hw; if (vel.x < 0) vel.x = 0; }
  if (pos.x > FW / 2 - hw && !inCornerZoneZ && !inFloorCurveZone && !inCeilCurveZone) { pos.x = FW / 2 - hw; if (vel.x > 0) vel.x = 0; }
  // End walls (allow into goal opening, unless hoops/dropshot mode â€” solid walls).
  // Bypass inFloorCurveZone guard when inside the goal mouth so the back wall
  // still clamps at ground level (car was able to drive through otherwise).
  var inGoalMouth = Math.abs(pos.x) < GW / 2 - hw && pos.y <= GH;
  if (pos.z > FL / 2 - hl && !inCornerZoneX && (!inFloorCurveZone || inGoalMouth) && !inCeilCurveZone) {
    if (hoopsActive || dropshotActive || Math.abs(pos.x) >= GW / 2 - hw || pos.y > GH) {
      pos.z = FL / 2 - hl; if (vel.z > 0) vel.z = 0;
    } else if (pos.z > FL / 2 + GD - hl) {
      pos.z = FL / 2 + GD - hl; if (vel.z > 0) vel.z = 0;
    }
  }
  if (pos.z < -FL / 2 + hl && !inCornerZoneX && (!inFloorCurveZone || inGoalMouth) && !inCeilCurveZone) {
    if (hoopsActive || dropshotActive || Math.abs(pos.x) >= GW / 2 - hw || pos.y > GH) {
      pos.z = -FL / 2 + hl; if (vel.z < 0) vel.z = 0;
    } else if (pos.z < -FL / 2 - GD + hl) {
      pos.z = -FL / 2 - GD + hl; if (vel.z < 0) vel.z = 0;
    }
  }
  // Ceiling â€” skip when car is in a wall-ceiling curve zone (wall physics handles transition)
  var inCeilingCurveZone = inCeilCurveZone && (Math.abs(pos.x) > FW / 2 - CURVE_R || Math.abs(pos.z) > FL / 2 - CURVE_R);
  if (pos.y > WH - CH / 2 && !inCeilingCurveZone) { pos.y = WH - CH / 2; if (vel.y > 0) vel.y = 0; }
}

// ==========================================================================
// COLLISIONS
// ==========================================================================
function checkCarBall(carPos, carVel, carRot, carSpeed) {
  var dx = bP.x - carPos.x;
  var dy = bP.y - carPos.y;
  var dz = bP.z - carPos.z;
  var dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
  var minDist = BR_ACTIVE + Math.max(CW, CL) * 0.55;

  if (dist < minDist && dist > 0.01) {
    // Collision normal
    var nx = dx / dist;
    var ny = dy / dist;
    var nz = dz / dist;

    // Push ball out
    var overlap = minDist - dist;
    bP.x += nx * overlap;
    bP.y += ny * overlap;
    bP.z += nz * overlap;

    // Calculate hit impulse
    var carVelMag = Math.sqrt(carVel.x * carVel.x + carVel.y * carVel.y + carVel.z * carVel.z);
    var dotProduct = (carVel.x * nx + carVel.y * ny + carVel.z * nz);
    var hitStrength = Math.max(dotProduct, carVelMag * 0.3, 5);

    // Apply impulse to ball (scaled by ball speed multiplier)
    var sm = BALL_SPEED_MULT;
    bV.x = (nx * hitStrength * 1.3 + carVel.x * 0.35) * sm;
    // Only pop ball up if hitting from below (ny > 0.3), otherwise minimal lift
    var yPop = ny > 0.3 ? 3 : 0.5;
    bV.y = (ny * hitStrength * 1.3 + Math.abs(carVel.y) * 0.5 + yPop) * sm;
    bV.z = (nz * hitStrength * 1.3 + carVel.z * 0.35) * sm;

    // Clamp ball velocity
    var bSpd = bV.length();
    var maxBallSpd = activeGameMode === 'heatseeker' ? HEATSEEKER_MAX_SPEED + 20 : 100;
    if (bSpd > maxBallSpd) bV.multiplyScalar(maxBallSpd / bSpd);

    playHitSound(hitStrength);
    vibrateController(Math.min(hitStrength * 5, 200), Math.min(hitStrength / 50, 0.8), Math.min(hitStrength / 40, 1.0));
    if (hitStrength > 15) triggerScreenShake(Math.min(hitStrength / 40, 0.7));

    // Hit sparks at contact point (RL-style)
    var sparkCount = Math.min(Math.floor(hitStrength / 5), 8);
    for (var sp = 0; sp < sparkCount; sp++) {
      spawnParticle(
        bP.x + (Math.random() - 0.5) * BR_ACTIVE,
        bP.y + (Math.random() - 0.5) * BR_ACTIVE,
        bP.z + (Math.random() - 0.5) * BR_ACTIVE,
        (Math.random() - 0.5) * 20, Math.random() * 12 + 3, (Math.random() - 0.5) * 20,
        hitStrength > 25 ? 0xff6600 : 0xffff88, 0.15, 0.1 + Math.random() * 0.15
      );
    }

    return true;
  }
  return false;
}

function checkCarCar() {
  if (pDemoed || aDemoed) return;
  var dx = aP.x - pP.x;
  var dy = aP.y - pP.y;
  var dz = aP.z - pP.z;
  var dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
  var minDist = CL * 0.9;

  if (dist < minDist && dist > 0.01) {
    var nx = dx / dist;
    var ny = dy / dist;
    var nz = dz / dist;
    var overlap = (minDist - dist) / 2;

    // Demolition check â€” supersonic speed demolishes opponent
    var maxSpd = CAR_BOOST_MAX * CAR_SPEED_MULT;
    var playerSS = Math.abs(pSpeed) > maxSpd * SUPERSONIC_THRESH;
    var aiSS = Math.abs(aSpeed) > maxSpd * AI_MULT * SUPERSONIC_THRESH;

    if (playerSS && !aiSS) {
      triggerDemo(false); // demo the AI
      triggerScreenShake(0.6);
      return;
    } else if (aiSS && !playerSS) {
      triggerDemo(true); // demo the player
      triggerScreenShake(0.6);
      return;
    }
    // Both supersonic or neither â€” just bump
    pP.x -= nx * overlap;
    pP.z -= nz * overlap;
    aP.x += nx * overlap;
    aP.z += nz * overlap;

    // Exchange some momentum
    var pMom = pSpeed * 0.3;
    var aMom = aSpeed * 0.3;
    pSpeed -= pMom; pSpeed += aMom * 0.2;
    aSpeed -= aMom; aSpeed += pMom * 0.2;

    triggerScreenShake(0.3);
    playHitSound(Math.abs(pSpeed) + Math.abs(aSpeed));
  }
}

// Generic car-car collision for 2v2 extra pairs (no demolition, just bumping)
function checkCarCarGeneric(pos1, vel1, spd1, pos2, vel2, spd2) {
  var dx = pos2.x - pos1.x;
  var dy = pos2.y - pos1.y;
  var dz = pos2.z - pos1.z;
  var dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
  var minDist = CL * 0.9;

  if (dist < minDist && dist > 0.01) {
    var nx = dx / dist;
    var nz = dz / dist;
    var overlap = (minDist - dist) / 2;

    // Push apart
    pos1.x -= nx * overlap;
    pos1.z -= nz * overlap;
    pos2.x += nx * overlap;
    pos2.z += nz * overlap;

    // Exchange momentum
    var mom1 = spd1 * 0.3;
    var mom2 = spd2 * 0.3;
    // Note: speed is a primitive so we can't modify it from here directly,
    // but position correction prevents overlap. Vel adjustment via position is enough.
    vel1.x -= nx * mom1 * 0.5;
    vel1.z -= nz * mom1 * 0.5;
    vel2.x += nx * mom2 * 0.5;
    vel2.z += nz * mom2 * 0.5;
  }
}

// ==========================================================================
// BOOST PAD COLLECTION
// ==========================================================================
function updateBoostPads(dt) {
  if (gameState !== 'playing') return; // don't tick or collect during goal/gameover/countdown
  var _now = Date.now();
  boostPads.forEach(function(pad) {
    if (!pad.active) {
      pad.respawnT -= dt;
      if (pad.respawnT <= 0) {
        pad.active = true;
        pad.mesh.visible = true;
      }
      return;
    }

    // Pulse animation â€” animate children materials
    var pulse = 0.8 + Math.sin(_now * 0.004) * 0.2;
    pad.mesh.children.forEach(function(child) {
      if (child.material && child.material.emissiveIntensity !== undefined) {
        child.material.emissiveIntensity = 0.4 + pulse * 0.4;
      }
    });
    // Float animation for big pad orbs
    if (pad.big) {
      pad.mesh.children.forEach(function(child) {
        if (child.position.y > 1) child.position.y = 2.0 + Math.sin(_now * 0.003) * 0.3;
      });
    }

    // Check player collection
    var pdx = pP.x - pad.x;
    var pdz = pP.z - pad.z;
    if (Math.sqrt(pdx * pdx + pdz * pdz) < pad.r + CW * 0.6 && pP.y < 3) {
      pBoost = pad.big ? BOOST_MAX : Math.min(BOOST_MAX, pBoost + 12);
      pad.active = false;
      pad.mesh.visible = false;
      pad.respawnT = pad.cooldown;
      playBoostPickupSound(pad.big);
    }

    // Check AI collection
    if (pad.active) {
    var adx = aP.x - pad.x;
    var adz = aP.z - pad.z;
    if (Math.sqrt(adx * adx + adz * adz) < pad.r + CW * 0.6 && aP.y < 3) {
      aBoost = pad.big ? BOOST_MAX : Math.min(BOOST_MAX, aBoost + 12);
      pad.active = false;
      pad.mesh.visible = false;
      pad.respawnT = pad.cooldown;
    }
    }

    // 2v2/3v3: Check extra AI car boost collection
    if (pad.active && (settings.teams === '2v2' || settings.teams === '3v3')) {
      var a2dx = a2P.x - pad.x, a2dz = a2P.z - pad.z;
      if (Math.sqrt(a2dx * a2dx + a2dz * a2dz) < pad.r + CW * 0.6 && a2P.y < 3) {
        a2Boost = pad.big ? BOOST_MAX : Math.min(BOOST_MAX, a2Boost + 12);
        pad.active = false; pad.mesh.visible = false; pad.respawnT = pad.cooldown;
      }
      if (pad.active) {
        var a3dx = a3P.x - pad.x, a3dz = a3P.z - pad.z;
        if (Math.sqrt(a3dx * a3dx + a3dz * a3dz) < pad.r + CW * 0.6 && a3P.y < 3) {
          a3Boost = pad.big ? BOOST_MAX : Math.min(BOOST_MAX, a3Boost + 12);
          pad.active = false; pad.mesh.visible = false; pad.respawnT = pad.cooldown;
        }
      }
    }
    // 3v3: extra cars boost collection
    if (pad.active && settings.teams === '3v3') {
      var a4dx = a4P.x - pad.x, a4dz = a4P.z - pad.z;
      if (Math.sqrt(a4dx * a4dx + a4dz * a4dz) < pad.r + CW * 0.6 && a4P.y < 3) {
        a4Boost = pad.big ? BOOST_MAX : Math.min(BOOST_MAX, a4Boost + 12);
        pad.active = false; pad.mesh.visible = false; pad.respawnT = pad.cooldown;
      }
      if (pad.active) {
        var a5dx = a5P.x - pad.x, a5dz = a5P.z - pad.z;
        if (Math.sqrt(a5dx * a5dx + a5dz * a5dz) < pad.r + CW * 0.6 && a5P.y < 3) {
          a5Boost = pad.big ? BOOST_MAX : Math.min(BOOST_MAX, a5Boost + 12);
          pad.active = false; pad.mesh.visible = false; pad.respawnT = pad.cooldown;
        }
      }
    }
  });
}

// ==========================================================================
// CAMERA
// ==========================================================================
var _ballCamTransTimer = 0; // ball cam transition boost timer
var _prevBallCam = false;
var _camSwivelAngle = 0; // persistent swivel angle that decays back to 0

function updateCamera(dt) {
  // During replay playback, camera is handled by updateReplayCamera
  if (replayActive) return;

  // Detect ball cam toggle for transition
  if (ballCam !== _prevBallCam) {
    _ballCamTransTimer = 0.3;
    _prevBallCam = ballCam;
  }
  if (_ballCamTransTimer > 0) _ballCamTransTimer -= dt;

  // Surface-aware camera â€” "behind" along surface forward, "above" along surface normal
  var camAxes = getSurfaceAxes(pSurface === 'air' ? 'floor' : pSurface);
  var camFwd = _v4.set(0, 0, 0);
  camFwd.addScaledVector(camAxes.tx, Math.sin(pRot));
  camFwd.addScaledVector(camAxes.tz, Math.cos(pRot));
  camFwd.normalize();
  var camNorm = _pOnCurve ? _pSmoothNormal : camAxes.normal;

  // Camera angle offset (tilt down by CAM_ANGLE degrees)
  var angleRad = CAM_ANGLE * Math.PI / 180;

  var idealPos, idealTarget;

  if (ballCam) {
    // Ball cam: position behind car relative to ball direction, offset by surface normal
    var toBall = _v1.copy(bP).sub(pP);
    // Project toBall onto surface plane (remove normal component), reuse _v5
    var projBehind = _v5.copy(toBall).addScaledVector(camNorm, -toBall.dot(camNorm)).normalize();
    if (projBehind.length() < 0.01) {
      // Ball directly above car â€” use previous camera direction to avoid sudden jump
      projBehind.copy(cameraPos).sub(pP);
      var _pbl = projBehind.length();
      if (_pbl > 0.01) { projBehind.divideScalar(_pbl); } else { projBehind.copy(camFwd); }
    }
    idealPos = _v2.copy(pP).addScaledVector(projBehind, -CAM_DIST);
    idealPos.addScaledVector(camNorm, CAM_HEIGHT);
    idealPos.addScaledVector(projBehind, Math.sin(angleRad) * CAM_HEIGHT * 0.3);
    idealTarget = _v3.copy(bP);
  } else {
    // Chase cam: behind car along surface-local forward
    var camAngle = pRot;
    // Right stick swivel â€” persistent angle that decays smoothly (like RL look-around)
    if (gamepad.connected && gamepad.rightStickX !== 0) {
      _camSwivelAngle += gamepad.rightStickX * CAM_SWIVEL * dt * 2.0;
      _camSwivelAngle = Math.max(-Math.PI * 0.8, Math.min(Math.PI * 0.8, _camSwivelAngle));
    } else {
      _camSwivelAngle *= Math.max(0, 1 - 5 * dt);
      if (Math.abs(_camSwivelAngle) < 0.01) _camSwivelAngle = 0;
    }
    camAngle += _camSwivelAngle;
    var swivelFwd = _v5.set(0, 0, 0);
    swivelFwd.addScaledVector(camAxes.tx, Math.sin(camAngle));
    swivelFwd.addScaledVector(camAxes.tz, Math.cos(camAngle));
    swivelFwd.normalize();
    idealPos = _v2.copy(pP).addScaledVector(swivelFwd, -CAM_DIST);
    idealPos.addScaledVector(camNorm, CAM_HEIGHT - (gamepad.connected ? gamepad.rightStickY * 4 : 0));
    idealPos.addScaledVector(swivelFwd, Math.sin(angleRad) * CAM_HEIGHT * 0.3);
    idealTarget = _v3.copy(pP).addScaledVector(swivelFwd, 10);
    idealTarget.addScaledVector(camNorm, Math.sin(angleRad) * 2);
  }

  // Stiffness-based camera â€” lower stiffness = more lag/float, higher = tighter follow
  // RL stiffness 0 = very floaty, 1 = rigid
  var stiffBase = 3 + CAM_STIFFNESS * 7; // range: 3 to 10
  var transBoost = _ballCamTransTimer > 0 ? CAM_TRANSITION * 3 : 0;
  var lerpSpeed = stiffBase + transBoost;

  // Keep camera in bounds â€” tighter clamping when on walls/ceiling
  var camPad = (pSurface !== 'floor' && pSurface !== 'air') ? 4 : 2;
  idealPos.x = Math.max(-FW / 2 + camPad, Math.min(FW / 2 - camPad, idealPos.x));
  idealPos.z = Math.max(-FL / 2 + camPad, Math.min(FL / 2 - camPad, idealPos.z));
  idealPos.y = Math.max(1.5, Math.min(WH - 1, idealPos.y));

  cameraPos.lerp(idealPos, lerpSpeed * dt);
  cameraTarget.lerp(idealTarget, (lerpSpeed + transBoost) * dt);

  // Smoothly lerp camera up vector toward surface normal â€” slower on curves to avoid spinning
  var upLerp = _pOnCurve ? 3 : ((pSurface !== 'floor' && pSurface !== 'air') ? 6 : 4);
  cameraUp.lerp(_v6.copy(camNorm), upLerp * dt).normalize();

  camera.position.copy(cameraPos);
  camera.up.copy(cameraUp);
  camera.lookAt(cameraTarget);
}

// Wheel spin â€” module-scope to avoid per-frame function allocation
var _wheelRadius = 0.55;
function spinWheels(carGroup, speed) {
  if (carGroup && carGroup.userData && carGroup.userData.wheels) {
    var spinRate = speed / _wheelRadius * _frameDt;
    carGroup.userData.wheels.forEach(function(wg) {
      wg.rotation.x += spinRate;
    });
  }
}

// ==========================================================================
// SYNC VISUALS
// ==========================================================================
function syncVisuals() {
  ball.position.copy(bP);
  // Ball spin based on velocity
  var bSpd2D = Math.sqrt(bV.x * bV.x + bV.z * bV.z);
  var bSpd = bV.length(); // 3D speed for glow/emissive
  if (bSpd2D > 0.5) {
    ball.rotation.x += bV.z * 0.02 * _frameDt * 60;
    ball.rotation.z -= bV.x * 0.02 * _frameDt * 60;
  }

  playerCar.position.copy(pP);

  // Build target quaternion from surface orientation + heading (using pre-allocated objects)
  var axes = getSurfaceAxes(pSurface === 'air' ? 'floor' : pSurface);
  // Forward direction on the surface
  var fwd = _v4.set(0, 0, 0);
  fwd.addScaledVector(axes.tx, Math.sin(pRot));
  fwd.addScaledVector(axes.tz, Math.cos(pRot));
  fwd.normalize();
  // Up direction = surface normal (use smooth normal on curves to prevent snapping)
  var up = _pOnCurve ? _v5.copy(_pSmoothNormal) : _v5.copy(axes.normal);
  // Right = up cross forward (right-handed); guard against parallel vectors (would produce zero/NaN)
  var right = _v6.crossVectors(up, fwd);
  if (right.lengthSq() < 0.0001) right.set(1, 0, 0);
  else right.normalize();
  // Recompute up to ensure orthogonality
  up.crossVectors(fwd, right).normalize();

  _m1.makeBasis(right, up, fwd); // Car model faces +Z
  pTargetQuat.setFromRotationMatrix(_m1);

  // Apply aerial pitch and roll to target quaternion using local axes
  // Extract local axes from the target quaternion so rotation is always in car's frame
  if (pSurface === 'air') {
    if (Math.abs(pPitch) > 0.01) {
      _v4.set(1, 0, 0).applyQuaternion(pTargetQuat); // local right in world space
      _q1.setFromAxisAngle(_v4, -pPitch);
      pTargetQuat.multiply(_q1);
    }
    if (Math.abs(pRoll) > 0.01) {
      _v4.set(0, 0, 1).applyQuaternion(pTargetQuat); // local forward in world space
      _q1.setFromAxisAngle(_v4, pRoll);
      pTargetQuat.multiply(_q1);
    }
  }

  // Slerp visual quaternion for smooth transitions; snap immediately on respawn.
  // Frame-rate-independent: Math.min(18*dt,1) matches 0.25/frame at 60 fps.
  if (_pSnapVisual) { pVisualQuat.copy(pTargetQuat); _pSnapVisual = false; }
  else { pVisualQuat.slerp(pTargetQuat, Math.min(18 * _frameDt, 1.0)); }

  // Apply dodge spin as temporary overlay (not slerped â€” fast effect)
  // Derive spin axis from the already-slerped visual quaternion to avoid axis mismatch
  if (pSpin > 0) {
    _v6.set(1, 0, 0).applyQuaternion(pVisualQuat); // visual right axis
    _q2.setFromAxisAngle(_v6, Math.sin((1 - pSpin / 0.45) * Math.PI * 2) * Math.PI);
    pVisualQuat.multiply(_q2);
  }

  playerCar.setRotationFromQuaternion(pVisualQuat);

  aiCar.position.copy(aP);
  aiCar.rotation.y = aRot;

  // 2v2 extra cars
  if (aiCar2 && aiCar2.visible) {
    aiCar2.position.copy(a2P);
    aiCar2.rotation.y = a2Rot;
  }
  if (aiCar3 && aiCar3.visible) {
    aiCar3.position.copy(a3P);
    aiCar3.rotation.y = a3Rot;
  }
  if (aiCar4 && aiCar4.visible) {
    aiCar4.position.copy(a4P);
    aiCar4.rotation.y = a4Rot;
  }
  if (aiCar5 && aiCar5.visible) {
    aiCar5.position.copy(a5P);
    aiCar5.rotation.y = a5Rot;
  }

  // Wheel spin animation â€” rotate based on car speed
  spinWheels(playerCar, pSpeed);
  spinWheels(aiCar, aSpeed);
  if (aiCar2 && aiCar2.visible) spinWheels(aiCar2, a2Speed);
  if (aiCar3 && aiCar3.visible) spinWheels(aiCar3, a3Speed);
  if (aiCar4 && aiCar4.visible) spinWheels(aiCar4, a4Speed);
  if (aiCar5 && aiCar5.visible) spinWheels(aiCar5, a5Speed);

  // Ball glow â€” RL-style: color based on last team touch, intensity based on speed
  ballGlow.intensity = Math.min(0.5 + bSpd * 0.03, 2.5);
  var ballBaseColor, ballEmissiveColor;
  // Heatseeker: ball turns purple at max speed, orange/yellow at medium
  if (activeGameMode === 'heatseeker' && heatseekerTarget !== 0) {
    var hsRatio = heatseekerSpeed / HEATSEEKER_MAX_SPEED;
    if (hsRatio >= 0.95) {
      // Max speed â€” purple
      ballBaseColor = 0xaa44ff;
      ballEmissiveColor = 0x8800ff;
      ballGlow.intensity = 2.5;
    } else if (hsRatio >= 0.6) {
      // High speed â€” red/orange
      ballBaseColor = 0xff3300;
      ballEmissiveColor = 0xff2200;
      ballGlow.intensity = 1.5 + hsRatio;
    } else if (hsRatio >= 0.3) {
      // Medium speed â€” orange/yellow
      ballBaseColor = 0xff8800;
      ballEmissiveColor = 0xff6600;
    } else {
      // Low speed â€” normal team color
      ballBaseColor = heatseekerTarget > 0 ? 0xff7b00 : 0x0088ff;
      ballEmissiveColor = heatseekerTarget > 0 ? 0xff6600 : 0x0066cc;
    }
  } else if (dropshotActive && dropshotBallPhase > 0) {
    // Dropshot: ball glows based on charge phase
    if (dropshotBallPhase >= 2) {
      ballBaseColor = 0xff2200; ballEmissiveColor = 0xff0000;
      ballGlow.intensity = 2.0;
    } else {
      ballBaseColor = 0xffaa00; ballEmissiveColor = 0xff8800;
      ballGlow.intensity = 1.2;
    }
  } else if (lastTouchTeam === 'orange') {
    ballBaseColor = bSpd > 40 ? 0xff4400 : 0xff7b00;
    ballEmissiveColor = bSpd > 40 ? 0xff4400 : 0xff6600;
  } else if (lastTouchTeam === 'blue') {
    ballBaseColor = bSpd > 40 ? 0x2266ff : 0x0088ff;
    ballEmissiveColor = bSpd > 40 ? 0x2266ff : 0x0066cc;
  } else {
    ballBaseColor = 0xffdd88;
    ballEmissiveColor = 0xffcc66;
  }
  ballGlow.color.setHex(ballBaseColor);
  if ((activeGameMode === 'heatseeker' && heatseekerTarget !== 0) ||
      (dropshotActive && dropshotBallPhase > 0)) {
    ball.material.color.setHex(ballBaseColor);
  } else {
    ball.material.color.setHex(0xf0f0f4); // default white
  }
  ball.material.emissive.setHex(ballEmissiveColor);
  if (activeGameMode === 'heatseeker' && heatseekerTarget !== 0) {
    var hsRatio2 = heatseekerSpeed / HEATSEEKER_MAX_SPEED;
    ball.material.emissiveIntensity = 0.2 + hsRatio2 * 0.6;
  } else if (dropshotActive && dropshotBallPhase > 0) {
    ball.material.emissiveIntensity = dropshotBallPhase === 2 ? 0.8 : 0.5;
  } else if (bSpd > 50) {
    ball.material.emissiveIntensity = 0.3 + (bSpd - 50) * 0.01;
  } else if (bSpd > 25) {
    ball.material.emissiveIntensity = 0.1 + (bSpd - 25) * 0.005;
  } else {
    ball.material.emissiveIntensity = 0.08;
  }

  // Ball ground indicator â€” shows where ball is above the floor
  if (ballIndicator) {
    ballIndicator.position.x = bP.x;
    ballIndicator.position.z = bP.z;
    var heightAboveGround = bP.y - BR_ACTIVE;
    var heightFade = Math.max(0, 1 - heightAboveGround / (WH * 0.5));
    var indicatorOpacity = Math.min(0.25, heightAboveGround / 30) * heightFade;
    var indicatorScale = 1.0 + heightAboveGround * 0.03;
    ballIndicator.material.opacity = heightAboveGround > 0.5 ? indicatorOpacity : 0;
    ballIndicator.scale.setScalar(indicatorScale);
  }
}

// ==========================================================================
// UI UPDATE
// ==========================================================================
function updateUI() {
  // Boost meter
  var pct = Math.min(100, Math.round(pBoost));
  _elBoostFill.style.setProperty('--pct', pct + '%');
  _elBoostText.textContent = pct;

  // Ball cam indicator
  _elBallcam.className = ballCam ? 'active' : '';

  // Powerslide indicator
  _elPowerslide.className = pPowerslide ? 'active' : '';

  // Ball speed display (convert to "km/h" for feel)
  var bSpd = Math.round(bV.length() * 2.5);
  _elBallSpeed.textContent = bSpd + ' km/h';
  _elBallSpeed.className = bSpd > 150 ? 'super' : (bSpd > 80 ? 'fast' : '');

  // Supersonic indicator
  _elSupersonic.className = pSupersonic ? 'active' : '';

  // Speed lines overlay
  _elSpeedLines.className = (pSupersonic || Math.abs(pSpeed) > CAR_BOOST_MAX * CAR_SPEED_MULT * 0.8) ? 'active' : '';

  // Last touch indicator
  if (lastTouchTeam && lastTouchTimer > 0) {
    _elLastTouch.className = lastTouchTeam;
    _elLastTouch.textContent = lastTouchTeam === 'orange' ? 'LAST TOUCH: ORANGE' : 'LAST TOUCH: BLUE';
  } else {
    _elLastTouch.className = '';
    _elLastTouch.textContent = '';
  }

  // Rumble HUD â€” keep powerup display in sync every frame
  if (rumbleActive) updateRumbleHUD();

  // Timer
  updateScoreboard();
}

// ==========================================================================
// INPUT
// ==========================================================================
function setupInput() {
  window.addEventListener('keydown', function(e) {
    // Handle key rebinding first
    if (_rebindingAction) {
      handleRebindKey(e);
      return;
    }
    // Cancel gamepad rebind on Escape
    if (_rebindingGpAction && e.key === 'Escape') {
      cancelGamepadRebind();
      e.preventDefault();
      return;
    }

    keys[e.key.toLowerCase()] = true;

    // Ball cam toggle (skip auto-repeat to prevent flickering)
    if (!e.repeat && e.key.toLowerCase() === settings.controls.ballcam && gameState === 'playing') {
      ballCam = !ballCam;
      if (tutorialActive) tutorialProgress.ballCamToggled = true;
    }

    // Quick chat toggle (skip auto-repeat)
    if (!e.repeat && e.key.toLowerCase() === settings.controls.quickchat && (gameState === 'playing' || gameState === 'goal')) {
      toggleQuickChat();
    }

    // Rumble power-up activation
    if (e.key.toLowerCase() === 'e' && rumbleActive && playerPowerup && gameState === 'playing') {
      activateRumblePowerup('player');
    }

    // Escape to menu (or close quick chat)
    if (e.key === 'Escape' && _quickChatOpen) {
      closeQuickChat();
    } else if (e.key === 'Escape' && gameState === 'menu') {
      // Close settings or garage panels with ESC
      var settingsEl = document.getElementById('settings');
      var garageEl = document.getElementById('garage');
      if (settingsEl && settingsEl.style.display !== 'none') {
        settingsEl.style.display = 'none';
        document.getElementById('menu').style.display = 'flex';
      } else if (garageEl && garageEl.style.display !== 'none') {
        garageEl.style.display = 'none';
        document.getElementById('menu').style.display = 'flex';
      }
    } else if (e.key === 'Escape' && (gameState === 'playing' || gameState === 'countdown' || gameState === 'goal' || gameState === 'overtime_announce')) {
      if (replayActive) { endReplay(); }
      gameState = 'menu';
      keys = {}; // clear held keys to prevent ghost inputs on next session
      _slowmoTimer = 0; _goalBloomTimer = 0; countdownT = 0; goalT = 0; overtimeAnnounceT = 0;
      closeQuickChat();
      document.getElementById('menu').style.display = 'flex';
      document.getElementById('hud').style.display = 'none';
      document.getElementById('boost-container').style.display = 'none';
      document.getElementById('ball-speed').style.display = 'none';
      document.getElementById('gamemode-hud').style.display = 'none';
      document.getElementById('tutorial-hud').style.display = 'none';
      document.getElementById('tutorial-skip').style.display = 'none';
      cleanupGameModeMeshes();
      if (tutorialActive) {
        settings.ai = _tutorialSavedAI;
        settings.boost = _tutorialSavedBoost;
        recalcActiveValues();
        tutorialActive = false;
      }
      hideOverlay();
    }

    // Prevent scrolling for game keys
    if ([' ', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].indexOf(e.key) > -1) {
      e.preventDefault();
    }
  });

  window.addEventListener('keyup', function(e) {
    keys[e.key.toLowerCase()] = false;
  });

  window.addEventListener('blur', function() { keys = {}; });

  // Cancel rebinding when clicking outside a key/gamepad button
  document.addEventListener('click', function(e) {
    if (_rebindingAction && !e.target.classList.contains('control-key')) {
      cancelRebind();
    }
    if (_rebindingGpAction && !e.target.classList.contains('control-gp')) {
      cancelGamepadRebind();
    }
  });

  document.getElementById('startBtn').addEventListener('click', function() {
    getAudio(); // Init audio on user gesture
    startEngineSound();
    startCrowdNoise();
    startGame();
  });

  document.getElementById('tutorialBtn').addEventListener('click', function() {
    getAudio();
    startEngineSound();
    startCrowdNoise();
    startTutorial();
  });

  document.getElementById('tutorial-skip').addEventListener('click', function() {
    endTutorial();
  });

  document.getElementById('restartBtn').addEventListener('click', function() {
    getAudio();
    startGame();
  });

  document.getElementById('menuBtn').addEventListener('click', function() {
    document.getElementById('game-over').style.display = 'none';
    document.getElementById('hud').style.display = 'none';
    document.getElementById('boost-container').style.display = 'none';
    document.getElementById('ball-speed').style.display = 'none';
    document.getElementById('gamemode-hud').style.display = 'none';
    document.getElementById('menu').style.display = 'flex';
    gameState = 'menu';
    cleanupGameModeMeshes();
  });

  // Settings UI
  document.getElementById('garageBtn').addEventListener('click', function() {
    _garageFocusIdx = -1; // reset focus so it initialises cleanly on open
    buildGarageUI();
    document.getElementById('menu').style.display = 'none';
    document.getElementById('garage').style.display = 'flex';
  });

  document.getElementById('garageBackBtn').addEventListener('click', function() {
    document.getElementById('garage').style.display = 'none';
    document.getElementById('menu').style.display = 'flex';
  });

  document.getElementById('settingsBtn').addEventListener('click', function() {
    settingsToUI();
    _settingsFocusIdx = -1;
    document.getElementById('menu').style.display = 'none';
    document.getElementById('settings').style.display = 'flex';
  });

  document.getElementById('settingsBackBtn').addEventListener('click', function() {
    cancelRebind();
    cancelGamepadRebind();
    settingsToUI(); // discard unsaved slider changes â€” reload UI from last-saved state
    _settingsFocusIdx = -1;
    var old = document.querySelector('.settings-focus');
    if (old) old.classList.remove('settings-focus');
    document.getElementById('settings').style.display = 'none';
    document.getElementById('menu').style.display = 'flex';
  });

  document.getElementById('settingsSaveBtn').addEventListener('click', function() {
    cancelRebind();
    cancelGamepadRebind();
    _settingsFocusIdx = -1;
    var old = document.querySelector('.settings-focus');
    if (old) old.classList.remove('settings-focus');
    uiToSettings();
    saveSettings();
    recalcActiveValues();
    applySettings();
    updateMenuControls();
    document.getElementById('settings').style.display = 'none';
    document.getElementById('menu').style.display = 'flex';
  });

  document.getElementById('settingsResetBtn').addEventListener('click', function() {
    cancelRebind();
    cancelGamepadRebind();
    settings = JSON.parse(JSON.stringify(DEFAULTS));
    saveSettings();
    settingsToUI();
    recalcActiveValues();
    applySettings();
    updateMenuControls();
  });

  // Range slider live update displays
  ['s-volume', 's-fov', 's-camdist', 's-camheight', 's-camangle', 's-camstiff', 's-camswivel', 's-camtransition', 's-deadzone', 's-sensitivity'].forEach(function(id) {
    document.getElementById(id).addEventListener('input', function() {
      updateRangeDisplays();
      uiToSettings();
      recalcActiveValues();
      applySettings();
    });
  });

  // Vibration checkbox live update
  document.getElementById('s-vibration').addEventListener('change', function() {
    settings.vibration = this.checked;
  });

  // Controller preset dropdown
  document.getElementById('s-controller-preset').addEventListener('change', function() {
    if (this.value) applyControllerPreset(this.value);
  });

  // Quick chat buttons
  document.querySelectorAll('.qc-btn').forEach(function(btn) {
    btn.addEventListener('click', function() {
      showChatBubble(btn.getAttribute('data-msg'));
    });
  });

  // Gamepad connection/disconnection indicators
  window.addEventListener('gamepadconnected', function(e) {
    var type = detectControllerType(e.gamepad.id);
    gamepad.type = type;
    var presetEl = document.getElementById('s-controller-preset');
    if (presetEl && type !== 'generic') presetEl.value = type;
    var toast = document.getElementById('gamepad-toast');
    toast.textContent = controllerTypeName(type) + ' Connected';
    toast.style.display = 'block';
    toast.style.animation = 'none';
    toast.offsetHeight;
    toast.style.animation = 'toastFade 2.5s ease-out forwards';
  });
  window.addEventListener('gamepaddisconnected', function() {
    var toast = document.getElementById('gamepad-toast');
    toast.textContent = 'Controller Disconnected';
    toast.style.display = 'block';
    toast.style.animation = 'none';
    toast.offsetHeight;
    toast.style.animation = 'toastFade 2.5s ease-out forwards';
  });
}

// ==========================================================================
// MAIN GAME LOOP
// ==========================================================================
function update() {
  requestAnimationFrame(update);

  var dt = clock.getDelta();
  dt = Math.min(dt, 0.05); // Prevent physics explosions
  _frameDt = dt;

  // Slow-motion effect (goal celebration)
  var realDt = dt; // unscaled dt for timers that should not be affected by slow-mo
  if (_slowmoTimer > 0) {
    dt *= _slowmoScale + (1 - _slowmoScale) * (1 - _slowmoTimer / _slowmoDuration); // ease out of slow-mo
    _slowmoTimer -= realDt;
    if (_slowmoTimer < 0) _slowmoTimer = 0;
  }

  // Poll gamepad each frame
  pollGamepad();
  pollGamepadRebind();
  pollSettingsNav();
  pollMenuGamepad();
  pollGarageNav();

  if (gameState === 'countdown') {
    countdownT += dt;
    if (countdownT >= 1) {
      countdownT -= 1;
      countdownVal--;
      if (countdownVal > 0) {
        showOverlay(String(countdownVal));
        playCountdownBeep(false);
      } else if (countdownVal === 0) {
        showOverlay('GO!');
        playCountdownBeep(true);
      } else {
        hideOverlay();
        gameState = 'playing';
        // Heatseeker: launch the serve when play begins (countdown wipes bV)
        if (activeGameMode === 'heatseeker') {
          var serveSpd = HEATSEEKER_BASE_SPEED * 0.35;
          var lateral = (Math.random() - 0.5) * 12;
          if (goalScorer === 'player') {
            bV.set(lateral, 4, -serveSpd);
          } else if (goalScorer === 'ai') {
            bV.set(lateral, 4, serveSpd);
          } else {
            var sDir = Math.random() < 0.5 ? 1 : -1;
            bV.set(lateral, 4, sDir * serveSpd);
          }
        }
      }
    }
  }

  if (gameState === 'playing') {
    if (settings.duration > 0 && !isOvertime && activeGameMode !== 'heatseeker') {
      gameTime -= dt;
      if (gameTime <= 0) {
        gameTime = 0;
        if (score[0] === score[1]) {
          showOverlay('OVERTIME!');
          gameState = 'overtime_announce';
          isOvertime = true;
          overtimeAnnounceT = 0;
        } else {
          endGame();
        }
      }
    } else if (isOvertime) {
      gameTime += dt; // Count up during overtime for display
    } else {
      gameTime += dt; // Count up for unlimited
    }
  }

  if (gameState === 'overtime_announce') {
    overtimeAnnounceT += dt;
    if (overtimeAnnounceT > 2) {
      hideOverlay();
      gameState = 'playing'; // Sudden death overtime
    }
  }

  if (gameState === 'goal') {
    goalT += dt;
    // Wait for replay to finish (or 3.5s minimum if no replay data)
    var replayDone = !replayActive;
    var minTime = replayDone ? 2.5 : 999; // wait for replay
    if (goalT > minTime && replayDone) {
      if (score[0] >= WIN_SCORE || score[1] >= WIN_SCORE || (isOvertime && score[0] !== score[1])) {
        endGame();
      } else {
        hideOverlay();
        closeQuickChat();
        resetPositions();
        gameState = 'countdown';
        countdownVal = 3;
        countdownT = 0;
        showOverlay(String(countdownVal));
        playCountdownBeep(false);
      }
    }
  }

  // Record replay frames during play
  if (gameState === 'playing') recordReplayFrame();

  // During replay playback, update replay and skip normal physics/visuals
  if (replayActive) {
    updateReplay(dt);
    // Still update visual effects during replay
    updateParticles(dt);
    updateScreenShake(dt);
    updateGoalFlash(dt);
    updateGoalScorer(dt);
    updateCamera(dt);
    updateUI();
  } else {
    // Physics updates
    updatePlayer(dt);
    updateAI(dt);
    updateBall(dt);

    // 2v2/3v3 extra AI updates
    if (settings.teams === '2v2' || settings.teams === '3v3') {
      updateExtraAI(dt, a2P, a2V, a2Rot, a2Speed, a2Ground, a2Boost, FL / 2, true);   // orange teammate
      updateExtraAI(dt, a3P, a3V, a3Rot, a3Speed, a3Ground, a3Boost, -FL / 2, false);  // blue enemy
    }
    if (settings.teams === '3v3') {
      updateExtraAI(dt, a4P, a4V, a4Rot, a4Speed, a4Ground, a4Boost, FL / 2, true, 4);   // orange teammate #2
      updateExtraAI(dt, a5P, a5V, a5Rot, a5Speed, a5Ground, a5Boost, -FL / 2, false, 5);  // blue enemy #2
    }

    // Collisions
    if (gameState === 'playing') {
      // Track shots/saves: check ball direction after hit
      var prevBZ = bV.z;
      var pHit = checkCarBall(pP, pV, pRot, pSpeed);
      if (pHit) {
        lastTouchTeam = 'orange';
        lastTouchTimer = 5;
        if (bV.z < -5) matchStats.pShots++;
        if (prevBZ > 5 && bP.z > FL * 0.2) matchStats.pSaves++;
        if (activeGameMode === 'heatseeker') onHeatseekerTouch('orange');
        if (dropshotActive) dropshotHitCount++;
      }
      var aHit = checkCarBall(aP, aV, aRot, aSpeed);
      if (aHit) {
        lastTouchTeam = 'blue';
        lastTouchTimer = 5;
        if (bV.z > 5) matchStats.aShots++;
        if (prevBZ < -5 && bP.z < -FL * 0.2) matchStats.aSaves++;
        if (activeGameMode === 'heatseeker') onHeatseekerTouch('blue');
        if (dropshotActive) dropshotHitCount++;
      }
      checkCarCar();
      if (settings.teams === '2v2' || settings.teams === '3v3') {
        var a2Hit = checkCarBall(a2P, a2V, a2Rot, a2Speed);
        if (a2Hit) {
          lastTouchTeam = 'orange'; lastTouchTimer = 5;
          if (activeGameMode === 'heatseeker') onHeatseekerTouch('orange');
          if (dropshotActive) dropshotHitCount++;
        }
        var a3Hit = checkCarBall(a3P, a3V, a3Rot, a3Speed);
        if (a3Hit) {
          lastTouchTeam = 'blue'; lastTouchTimer = 5;
          if (activeGameMode === 'heatseeker') onHeatseekerTouch('blue');
          if (dropshotActive) dropshotHitCount++;
        }
        // All car-car collision pairs
        checkCarCarGeneric(pP, pV, pSpeed, a2P, a2V, a2Speed);
        checkCarCarGeneric(pP, pV, pSpeed, a3P, a3V, a3Speed);
        checkCarCarGeneric(aP, aV, aSpeed, a2P, a2V, a2Speed);
        checkCarCarGeneric(aP, aV, aSpeed, a3P, a3V, a3Speed);
        checkCarCarGeneric(a2P, a2V, a2Speed, a3P, a3V, a3Speed);
      }
      if (settings.teams === '3v3') {
        var a4Hit = checkCarBall(a4P, a4V, a4Rot, a4Speed);
        if (a4Hit) {
          lastTouchTeam = 'orange'; lastTouchTimer = 5;
          if (activeGameMode === 'heatseeker') onHeatseekerTouch('orange');
          if (dropshotActive) dropshotHitCount++;
        }
        var a5Hit = checkCarBall(a5P, a5V, a5Rot, a5Speed);
        if (a5Hit) {
          lastTouchTeam = 'blue'; lastTouchTimer = 5;
          if (activeGameMode === 'heatseeker') onHeatseekerTouch('blue');
          if (dropshotActive) dropshotHitCount++;
        }
        checkCarCarGeneric(pP, pV, pSpeed, a4P, a4V, a4Speed);
        checkCarCarGeneric(pP, pV, pSpeed, a5P, a5V, a5Speed);
        checkCarCarGeneric(aP, aV, aSpeed, a4P, a4V, a4Speed);
        checkCarCarGeneric(aP, aV, aSpeed, a5P, a5V, a5Speed);
        checkCarCarGeneric(a2P, a2V, a2Speed, a4P, a4V, a4Speed);
        checkCarCarGeneric(a2P, a2V, a2Speed, a5P, a5V, a5Speed);
        checkCarCarGeneric(a3P, a3V, a3Speed, a4P, a4V, a4Speed);
        checkCarCarGeneric(a3P, a3V, a3Speed, a5P, a5V, a5Speed);
        checkCarCarGeneric(a4P, a4V, a4Speed, a5P, a5V, a5Speed);
      }
    }

    // Boost pads
    updateBoostPads(dt);

    // Particles
    updateParticles(dt);

    // Ball trail
    updateBallTrail(dt);

    // Demolitions â€” use unscaled realDt so respawn timer is not affected by goal slow-mo
    updateDemos(realDt);

    // Bloom reset timer
    if (_goalBloomTimer > 0) {
      _goalBloomTimer -= realDt;
      if (_goalBloomTimer <= 0 && bloomPass) bloomPass.strength = 0.4;
    }

    // Screen shake
    updateScreenShake(dt);

    // Goal flash
    updateGoalFlash(dt);

    // Demo text
    updateDemoText(dt);

    // Quick chat bubble
    updateChatBubble(dt);

    // Goal scorer display
    updateGoalScorer(dt);

    // Last touch timer
    if (lastTouchTimer > 0) lastTouchTimer -= dt;

    // Sync Three.js visuals
    syncVisuals();

    // Camera
    updateCamera(dt);

    // UI
    updateUI();
  }

  // Tutorial
  updateTutorial(dt);

  // Audio systems
  updateEngineSound();
  updateCrowdNoise();

  // Render with bloom post-processing
  if (composer) {
    composer.render();
  } else {
    renderer.render(scene, camera);
  }
}

// ==========================================================================
// START
// ==========================================================================
init();
cameraPos.set(0, 30, 60);
cameraTarget.set(0, 0, 0);
update();

})();
</script>
</body>
</html>
